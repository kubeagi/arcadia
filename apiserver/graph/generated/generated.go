// Code generated by github.com/99designs/gqlgen, DO NOT EDIT.

package generated

import (
	"bytes"
	"context"
	"errors"
	"fmt"
	"strconv"
	"sync"
	"sync/atomic"
	"time"

	"github.com/99designs/gqlgen/graphql"
	"github.com/99designs/gqlgen/graphql/introspection"
	gqlparser "github.com/vektah/gqlparser/v2"
	"github.com/vektah/gqlparser/v2/ast"
)

// region    ************************** generated!.gotpl **************************

// NewExecutableSchema creates an ExecutableSchema from the ResolverRoot interface.
func NewExecutableSchema(cfg Config) graphql.ExecutableSchema {
	return &executableSchema{
		schema:     cfg.Schema,
		resolvers:  cfg.Resolvers,
		directives: cfg.Directives,
		complexity: cfg.Complexity,
	}
}

type Config struct {
	Schema     *ast.Schema
	Resolvers  ResolverRoot
	Directives DirectiveRoot
	Complexity ComplexityRoot
}

type ResolverRoot interface {
	ApplicationMutation() ApplicationMutationResolver
	ApplicationQuery() ApplicationQueryResolver
	DataProcessMutation() DataProcessMutationResolver
	DataProcessQuery() DataProcessQueryResolver
	Dataset() DatasetResolver
	DatasetMutation() DatasetMutationResolver
	DatasetQuery() DatasetQueryResolver
	DatasourceMutation() DatasourceMutationResolver
	DatasourceQuery() DatasourceQueryResolver
	EmbedderMutation() EmbedderMutationResolver
	EmbedderQuery() EmbedderQueryResolver
	GPTQuery() GPTQueryResolver
	KnowledgeBaseMutation() KnowledgeBaseMutationResolver
	KnowledgeBaseQuery() KnowledgeBaseQueryResolver
	LLMQuery() LLMQueryResolver
	Model() ModelResolver
	ModelMutation() ModelMutationResolver
	ModelQuery() ModelQueryResolver
	ModelServiceMutation() ModelServiceMutationResolver
	ModelServiceQuery() ModelServiceQueryResolver
	Mutation() MutationResolver
	Query() QueryResolver
	RAG() RAGResolver
	RAGMutation() RAGMutationResolver
	RAGQuery() RAGQueryResolver
	RayClusterQuery() RayClusterQueryResolver
	VersionedDataset() VersionedDatasetResolver
	VersionedDatasetMutation() VersionedDatasetMutationResolver
	VersionedDatasetQuery() VersionedDatasetQueryResolver
	WorkerMutation() WorkerMutationResolver
	WorkerQuery() WorkerQueryResolver
}

type DirectiveRoot struct {
}

type ComplexityRoot struct {
	Application struct {
		ConversionWindowSize func(childComplexity int) int
		DocNullReturn        func(childComplexity int) int
		Knowledgebase        func(childComplexity int) int
		Llm                  func(childComplexity int) int
		MaxLength            func(childComplexity int) int
		MaxTokens            func(childComplexity int) int
		Metadata             func(childComplexity int) int
		Model                func(childComplexity int) int
		NumDocuments         func(childComplexity int) int
		Prologue             func(childComplexity int) int
		ScoreThreshold       func(childComplexity int) int
		ShowNextGuide        func(childComplexity int) int
		ShowRespInfo         func(childComplexity int) int
		ShowRetrievalInfo    func(childComplexity int) int
		Temperature          func(childComplexity int) int
		Tools                func(childComplexity int) int
		UserPrompt           func(childComplexity int) int
	}

	ApplicationMetadata struct {
		Annotations       func(childComplexity int) int
		Category          func(childComplexity int) int
		CreationTimestamp func(childComplexity int) int
		Creator           func(childComplexity int) int
		Description       func(childComplexity int) int
		DisplayName       func(childComplexity int) int
		ID                func(childComplexity int) int
		Icon              func(childComplexity int) int
		IsPublic          func(childComplexity int) int
		Labels            func(childComplexity int) int
		Name              func(childComplexity int) int
		Namespace         func(childComplexity int) int
		Status            func(childComplexity int) int
		UpdateTimestamp   func(childComplexity int) int
	}

	ApplicationMutation struct {
		CreateApplication       func(childComplexity int, input CreateApplicationMetadataInput) int
		DeleteApplication       func(childComplexity int, input DeleteCommonInput) int
		UpdateApplication       func(childComplexity int, input UpdateApplicationMetadataInput) int
		UpdateApplicationConfig func(childComplexity int, input UpdateApplicationConfigInput) int
	}

	ApplicationQuery struct {
		GetApplication          func(childComplexity int, name string, namespace string) int
		ListApplicationMetadata func(childComplexity int, input ListCommonInput) int
	}

	CountDataProcessItem struct {
		Data    func(childComplexity int) int
		Message func(childComplexity int) int
		Status  func(childComplexity int) int
	}

	DataProcessConfig struct {
		Children    func(childComplexity int) int
		Description func(childComplexity int) int
		FileNum     func(childComplexity int) int
		Name        func(childComplexity int) int
		Status      func(childComplexity int) int
	}

	DataProcessConfigChildren struct {
		ChunkOverlap func(childComplexity int) int
		ChunkSize    func(childComplexity int) int
		Description  func(childComplexity int) int
		Enable       func(childComplexity int) int
		FileProgress func(childComplexity int) int
		LlmConfig    func(childComplexity int) int
		Name         func(childComplexity int) int
		Preview      func(childComplexity int) int
		ZhName       func(childComplexity int) int
	}

	DataProcessConfigInfo struct {
		LlmConfig             func(childComplexity int) int
		RemoveDuplicateConfig func(childComplexity int) int
		Type                  func(childComplexity int) int
	}

	DataProcessConfigpreFileProgress struct {
		EndTime   func(childComplexity int) int
		FileName  func(childComplexity int) int
		ID        func(childComplexity int) int
		Progress  func(childComplexity int) int
		StartTime func(childComplexity int) int
		Status    func(childComplexity int) int
	}

	DataProcessConfigpreView struct {
		Content  func(childComplexity int) int
		FileName func(childComplexity int) int
	}

	DataProcessConfigpreViewContent struct {
		Post func(childComplexity int) int
		Pre  func(childComplexity int) int
	}

	DataProcessDetails struct {
		Data    func(childComplexity int) int
		Message func(childComplexity int) int
		Status  func(childComplexity int) int
	}

	DataProcessDetailsItem struct {
		Config                func(childComplexity int) int
		Creator               func(childComplexity int) int
		DataProcessConfigInfo func(childComplexity int) int
		EndTime               func(childComplexity int) int
		ErrorMsg              func(childComplexity int) int
		FileNum               func(childComplexity int) int
		FileType              func(childComplexity int) int
		ID                    func(childComplexity int) int
		Name                  func(childComplexity int) int
		PostDatasetName       func(childComplexity int) int
		PostDatasetVersion    func(childComplexity int) int
		PreDatasetName        func(childComplexity int) int
		PreDatasetVersion     func(childComplexity int) int
		StartTime             func(childComplexity int) int
		Status                func(childComplexity int) int
	}

	DataProcessItem struct {
		ErrorMsg           func(childComplexity int) int
		ID                 func(childComplexity int) int
		Name               func(childComplexity int) int
		PostDataSetName    func(childComplexity int) int
		PostDataSetVersion func(childComplexity int) int
		PreDataSetName     func(childComplexity int) int
		PreDataSetVersion  func(childComplexity int) int
		StartDatetime      func(childComplexity int) int
		Status             func(childComplexity int) int
	}

	DataProcessMutation struct {
		CreateDataProcessTask func(childComplexity int, input *AddDataProcessInput) int
		DeleteDataProcessTask func(childComplexity int, input *DeleteDataProcessInput) int
	}

	DataProcessQuery struct {
		AllDataProcessListByCount    func(childComplexity int, input *AllDataProcessListByCountInput) int
		AllDataProcessListByPage     func(childComplexity int, input *AllDataProcessListByPageInput) int
		CheckDataProcessTaskName     func(childComplexity int, input *CheckDataProcessTaskNameInput) int
		DataProcessDetails           func(childComplexity int, input *DataProcessDetailsInput) int
		DataProcessLogInfoByFileName func(childComplexity int, input *DataProcessFileLogInput) int
		DataProcessRetry             func(childComplexity int, input *DataProcessRetryInput) int
		DataProcessSupportType       func(childComplexity int) int
		GetLogInfo                   func(childComplexity int, input *DataProcessDetailsInput) int
	}

	DataProcessResponse struct {
		Data    func(childComplexity int) int
		Message func(childComplexity int) int
		Status  func(childComplexity int) int
	}

	DataProcessSupportType struct {
		Data    func(childComplexity int) int
		Message func(childComplexity int) int
		Status  func(childComplexity int) int
	}

	DataProcessSupportTypeChildren struct {
		Description func(childComplexity int) int
		Enable      func(childComplexity int) int
		Name        func(childComplexity int) int
		ZhName      func(childComplexity int) int
	}

	DataProcessSupportTypeItem struct {
		Children    func(childComplexity int) int
		Description func(childComplexity int) int
		Name        func(childComplexity int) int
	}

	Dataset struct {
		Annotations       func(childComplexity int) int
		ContentType       func(childComplexity int) int
		CreationTimestamp func(childComplexity int) int
		Creator           func(childComplexity int) int
		Description       func(childComplexity int) int
		DisplayName       func(childComplexity int) int
		Field             func(childComplexity int) int
		Labels            func(childComplexity int) int
		Name              func(childComplexity int) int
		Namespace         func(childComplexity int) int
		UpdateTimestamp   func(childComplexity int) int
		Versions          func(childComplexity int, input ListVersionedDatasetInput) int
	}

	DatasetMutation struct {
		CreateDataset  func(childComplexity int, input *CreateDatasetInput) int
		DeleteDatasets func(childComplexity int, input *DeleteCommonInput) int
		UpdateDataset  func(childComplexity int, input *UpdateDatasetInput) int
	}

	DatasetQuery struct {
		GetDataset   func(childComplexity int, name string, namespace string) int
		ListDatasets func(childComplexity int, input *ListDatasetInput) int
	}

	Datasource struct {
		Annotations       func(childComplexity int) int
		CreationTimestamp func(childComplexity int) int
		Creator           func(childComplexity int) int
		Description       func(childComplexity int) int
		DisplayName       func(childComplexity int) int
		Endpoint          func(childComplexity int) int
		ID                func(childComplexity int) int
		Labels            func(childComplexity int) int
		Message           func(childComplexity int) int
		Name              func(childComplexity int) int
		Namespace         func(childComplexity int) int
		Oss               func(childComplexity int) int
		Status            func(childComplexity int) int
		Type              func(childComplexity int) int
		UpdateTimestamp   func(childComplexity int) int
		Web               func(childComplexity int) int
	}

	DatasourceMutation struct {
		CreateDatasource  func(childComplexity int, input CreateDatasourceInput) int
		DeleteDatasources func(childComplexity int, input *DeleteCommonInput) int
		UpdateDatasource  func(childComplexity int, input *UpdateDatasourceInput) int
	}

	DatasourceQuery struct {
		CheckDatasource func(childComplexity int, input CreateDatasourceInput) int
		GetDatasource   func(childComplexity int, name string, namespace string) int
		ListDatasources func(childComplexity int, input ListCommonInput) int
	}

	Embedder struct {
		Annotations       func(childComplexity int) int
		BaseURL           func(childComplexity int) int
		CreationTimestamp func(childComplexity int) int
		Creator           func(childComplexity int) int
		Description       func(childComplexity int) int
		DisplayName       func(childComplexity int) int
		ID                func(childComplexity int) int
		Labels            func(childComplexity int) int
		Message           func(childComplexity int) int
		Models            func(childComplexity int) int
		Name              func(childComplexity int) int
		Namespace         func(childComplexity int) int
		Provider          func(childComplexity int) int
		Status            func(childComplexity int) int
		Type              func(childComplexity int) int
		UpdateTimestamp   func(childComplexity int) int
	}

	EmbedderMutation struct {
		CreateEmbedder  func(childComplexity int, input CreateEmbedderInput) int
		DeleteEmbedders func(childComplexity int, input *DeleteCommonInput) int
		UpdateEmbedder  func(childComplexity int, input *UpdateEmbedderInput) int
	}

	EmbedderQuery struct {
		GetEmbedder   func(childComplexity int, name string, namespace string) int
		ListEmbedders func(childComplexity int, input ListCommonInput) int
	}

	Endpoint struct {
		AuthSecret func(childComplexity int) int
		Insecure   func(childComplexity int) int
		URL        func(childComplexity int) int
	}

	F struct {
		Count             func(childComplexity int) int
		CreationTimestamp func(childComplexity int) int
		FileType          func(childComplexity int) int
		Path              func(childComplexity int) int
		Size              func(childComplexity int) int
		Time              func(childComplexity int) int
	}

	GPT struct {
		Category    func(childComplexity int) int
		Creator     func(childComplexity int) int
		Description func(childComplexity int) int
		DisplayName func(childComplexity int) int
		Hot         func(childComplexity int) int
		Icon        func(childComplexity int) int
		Name        func(childComplexity int) int
		Prologue    func(childComplexity int) int
	}

	GPTQuery struct {
		GetGpt  func(childComplexity int, name string) int
		ListGpt func(childComplexity int, input ListGPTInput) int
	}

	KnowledgeBase struct {
		Annotations       func(childComplexity int) int
		BatchSize         func(childComplexity int) int
		ChunkOverlap      func(childComplexity int) int
		ChunkSize         func(childComplexity int) int
		CreationTimestamp func(childComplexity int) int
		Creator           func(childComplexity int) int
		Description       func(childComplexity int) int
		DisplayName       func(childComplexity int) int
		Embedder          func(childComplexity int) int
		EmbedderType      func(childComplexity int) int
		FileGroupDetails  func(childComplexity int) int
		ID                func(childComplexity int) int
		Labels            func(childComplexity int) int
		Message           func(childComplexity int) int
		Name              func(childComplexity int) int
		Namespace         func(childComplexity int) int
		Reason            func(childComplexity int) int
		Status            func(childComplexity int) int
		UpdateTimestamp   func(childComplexity int) int
		VectorStore       func(childComplexity int) int
	}

	KnowledgeBaseMutation struct {
		CreateKnowledgeBase func(childComplexity int, input CreateKnowledgeBaseInput) int
		DeleteKnowledgeBase func(childComplexity int, input *DeleteCommonInput) int
		UpdateKnowledgeBase func(childComplexity int, input *UpdateKnowledgeBaseInput) int
	}

	KnowledgeBaseQuery struct {
		GetKnowledgeBase   func(childComplexity int, name string, namespace string) int
		ListKnowledgeBases func(childComplexity int, input ListKnowledgeBaseInput) int
	}

	LLM struct {
		Annotations       func(childComplexity int) int
		BaseURL           func(childComplexity int) int
		CreationTimestamp func(childComplexity int) int
		Creator           func(childComplexity int) int
		Description       func(childComplexity int) int
		DisplayName       func(childComplexity int) int
		ID                func(childComplexity int) int
		Labels            func(childComplexity int) int
		Message           func(childComplexity int) int
		Models            func(childComplexity int) int
		Name              func(childComplexity int) int
		Namespace         func(childComplexity int) int
		Provider          func(childComplexity int) int
		Status            func(childComplexity int) int
		Type              func(childComplexity int) int
		UpdateTimestamp   func(childComplexity int) int
	}

	LLMConfig struct {
		MaxTokens      func(childComplexity int) int
		Model          func(childComplexity int) int
		Name           func(childComplexity int) int
		Namespace      func(childComplexity int) int
		PromptTemplate func(childComplexity int) int
		Provider       func(childComplexity int) int
		Temperature    func(childComplexity int) int
		TopP           func(childComplexity int) int
	}

	LLMQuery struct {
		GetLlm   func(childComplexity int, name string, namespace string) int
		ListLLMs func(childComplexity int, input ListCommonInput) int
	}

	LabelSelectorRequirement struct {
		Key      func(childComplexity int) int
		Operator func(childComplexity int) int
		Values   func(childComplexity int) int
	}

	Model struct {
		Annotations       func(childComplexity int) int
		CreationTimestamp func(childComplexity int) int
		Creator           func(childComplexity int) int
		Description       func(childComplexity int) int
		DisplayName       func(childComplexity int) int
		Files             func(childComplexity int, input *FileFilter) int
		HuggingFaceRepo   func(childComplexity int) int
		ID                func(childComplexity int) int
		Labels            func(childComplexity int) int
		Message           func(childComplexity int) int
		ModelScopeRepo    func(childComplexity int) int
		ModelSource       func(childComplexity int) int
		Name              func(childComplexity int) int
		Namespace         func(childComplexity int) int
		Revision          func(childComplexity int) int
		Status            func(childComplexity int) int
		SystemModel       func(childComplexity int) int
		Types             func(childComplexity int) int
		UpdateTimestamp   func(childComplexity int) int
	}

	ModelMutation struct {
		CreateModel  func(childComplexity int, input CreateModelInput) int
		DeleteModels func(childComplexity int, input *DeleteCommonInput) int
		UpdateModel  func(childComplexity int, input *UpdateModelInput) int
	}

	ModelQuery struct {
		GetModel   func(childComplexity int, name string, namespace string) int
		ListModels func(childComplexity int, input ListModelInput) int
	}

	ModelService struct {
		APIType           func(childComplexity int) int
		Annotations       func(childComplexity int) int
		BaseURL           func(childComplexity int) int
		CreationTimestamp func(childComplexity int) int
		Creator           func(childComplexity int) int
		Description       func(childComplexity int) int
		DisplayName       func(childComplexity int) int
		EmbeddingModels   func(childComplexity int) int
		ID                func(childComplexity int) int
		Labels            func(childComplexity int) int
		LlmModels         func(childComplexity int) int
		Message           func(childComplexity int) int
		Name              func(childComplexity int) int
		Namespace         func(childComplexity int) int
		ProviderType      func(childComplexity int) int
		Status            func(childComplexity int) int
		Types             func(childComplexity int) int
		UpdateTimestamp   func(childComplexity int) int
	}

	ModelServiceMutation struct {
		CreateModelService func(childComplexity int, input CreateModelServiceInput) int
		DeleteModelService func(childComplexity int, input *DeleteCommonInput) int
		UpdateModelService func(childComplexity int, input *UpdateModelServiceInput) int
	}

	ModelServiceQuery struct {
		CheckModelService func(childComplexity int, input CreateModelServiceInput) int
		GetModelService   func(childComplexity int, name string, namespace string) int
		ListModelServices func(childComplexity int, input *ListModelServiceInput) int
	}

	Mutation struct {
		Application      func(childComplexity int) int
		DataProcess      func(childComplexity int) int
		Dataset          func(childComplexity int) int
		Datasource       func(childComplexity int) int
		Embedder         func(childComplexity int) int
		Hello            func(childComplexity int, name string) int
		KnowledgeBase    func(childComplexity int) int
		Model            func(childComplexity int) int
		ModelService     func(childComplexity int) int
		Rag              func(childComplexity int) int
		VersionedDataset func(childComplexity int) int
		Worker           func(childComplexity int) int
	}

	NodeSelectorRequirement struct {
		Key      func(childComplexity int) int
		Operator func(childComplexity int) int
		Values   func(childComplexity int) int
	}

	Oss struct {
		Bucket func(childComplexity int) int
		Object func(childComplexity int) int
	}

	PaginatedDataProcessItem struct {
		Data    func(childComplexity int) int
		Message func(childComplexity int) int
		Status  func(childComplexity int) int
	}

	PaginatedResult struct {
		HasNextPage func(childComplexity int) int
		Nodes       func(childComplexity int) int
		Page        func(childComplexity int) int
		PageSize    func(childComplexity int) int
		TotalCount  func(childComplexity int) int
	}

	Parameter struct {
		Key   func(childComplexity int) int
		Value func(childComplexity int) int
	}

	PersistentVolumeClaimSpec struct {
		AccessModes      func(childComplexity int) int
		DataSourceRef    func(childComplexity int) int
		Datasource       func(childComplexity int) int
		Resources        func(childComplexity int) int
		Selector         func(childComplexity int) int
		StorageClassName func(childComplexity int) int
		VolumeMode       func(childComplexity int) int
		VolumeName       func(childComplexity int) int
	}

	Query struct {
		Application      func(childComplexity int) int
		DataProcess      func(childComplexity int) int
		Dataset          func(childComplexity int) int
		Datasource       func(childComplexity int) int
		Embedder         func(childComplexity int) int
		Gpt              func(childComplexity int) int
		Hello            func(childComplexity int, name string) int
		KnowledgeBase    func(childComplexity int) int
		Llm              func(childComplexity int) int
		Model            func(childComplexity int) int
		ModelService     func(childComplexity int) int
		Rag              func(childComplexity int) int
		RayCluster       func(childComplexity int) int
		VersionedDataset func(childComplexity int) int
		Worker           func(childComplexity int) int
	}

	RAG struct {
		Annotations        func(childComplexity int) int
		Application        func(childComplexity int) int
		CompleteTimestamp  func(childComplexity int) int
		CreationTimestamp  func(childComplexity int) int
		Creator            func(childComplexity int) int
		Datasets           func(childComplexity int) int
		Description        func(childComplexity int) int
		DisplayName        func(childComplexity int) int
		JudgeLlm           func(childComplexity int) int
		Labels             func(childComplexity int) int
		Metrics            func(childComplexity int) int
		Name               func(childComplexity int) int
		Namespace          func(childComplexity int) int
		Phase              func(childComplexity int) int
		PhaseMessage       func(childComplexity int) int
		ServiceAccountName func(childComplexity int) int
		Status             func(childComplexity int) int
		Storage            func(childComplexity int) int
		Suspend            func(childComplexity int) int
	}

	RAGDataset struct {
		Files  func(childComplexity int) int
		Source func(childComplexity int) int
	}

	RAGMetric struct {
		MetricKind          func(childComplexity int) int
		Parameters          func(childComplexity int) int
		ToleranceThreshbold func(childComplexity int) int
	}

	RAGMutation struct {
		CreateRag    func(childComplexity int, input CreateRAGInput) int
		DeleteRag    func(childComplexity int, input DeleteRAGInput) int
		DuplicateRag func(childComplexity int, input DuplicateRAGInput) int
		UpdateRag    func(childComplexity int, input UpdateRAGInput) int
	}

	RAGQuery struct {
		GetRag  func(childComplexity int, name string, namespace string) int
		ListRag func(childComplexity int, input ListRAGInput) int
	}

	RayCluster struct {
		DashboardHost func(childComplexity int) int
		HeadAddress   func(childComplexity int) int
		Index         func(childComplexity int) int
		Name          func(childComplexity int) int
		PythonVersion func(childComplexity int) int
	}

	RayClusterQuery struct {
		ListRayClusters func(childComplexity int, input ListCommonInput) int
	}

	RemoveDuplicateConfigItem struct {
		EmbeddingModel     func(childComplexity int) int
		EmbeddingName      func(childComplexity int) int
		EmbeddingNamespace func(childComplexity int) int
		EmbeddingProvider  func(childComplexity int) int
		Similarity         func(childComplexity int) int
	}

	Resource struct {
		Limits   func(childComplexity int) int
		Requests func(childComplexity int) int
	}

	Resources struct {
		CPU       func(childComplexity int) int
		Memory    func(childComplexity int) int
		NvidiaGpu func(childComplexity int) int
	}

	Selector struct {
		MatchExpressions func(childComplexity int) int
		MatchLabels      func(childComplexity int) int
	}

	Tool struct {
		Name   func(childComplexity int) int
		Params func(childComplexity int) int
	}

	TypedObjectReference struct {
		APIGroup    func(childComplexity int) int
		DisplayName func(childComplexity int) int
		Kind        func(childComplexity int) int
		Name        func(childComplexity int) int
		Namespace   func(childComplexity int) int
	}

	VersionedDataset struct {
		Annotations       func(childComplexity int) int
		CreationTimestamp func(childComplexity int) int
		Creator           func(childComplexity int) int
		DataProcessMsg    func(childComplexity int) int
		DataProcessStatus func(childComplexity int) int
		Dataset           func(childComplexity int) int
		Description       func(childComplexity int) int
		DisplayName       func(childComplexity int) int
		Files             func(childComplexity int, input *FileFilter) int
		ID                func(childComplexity int) int
		Labels            func(childComplexity int) int
		Name              func(childComplexity int) int
		Namespace         func(childComplexity int) int
		Released          func(childComplexity int) int
		SyncMsg           func(childComplexity int) int
		SyncStatus        func(childComplexity int) int
		UpdateTimestamp   func(childComplexity int) int
		Version           func(childComplexity int) int
	}

	VersionedDatasetMutation struct {
		CreateVersionedDataset  func(childComplexity int, input CreateVersionedDatasetInput) int
		DeleteVersionedDatasets func(childComplexity int, input DeleteVersionedDatasetInput) int
		UpdateVersionedDataset  func(childComplexity int, input UpdateVersionedDatasetInput) int
	}

	VersionedDatasetQuery struct {
		GetVersionedDataset   func(childComplexity int, name string, namespace string) int
		ListVersionedDatasets func(childComplexity int, input ListVersionedDatasetInput) int
	}

	Web struct {
		RecommendIntervalTime func(childComplexity int) int
	}

	Worker struct {
		API               func(childComplexity int) int
		AdditionalEnvs    func(childComplexity int) int
		Annotations       func(childComplexity int) int
		CreationTimestamp func(childComplexity int) int
		Creator           func(childComplexity int) int
		Description       func(childComplexity int) int
		DisplayName       func(childComplexity int) int
		ID                func(childComplexity int) int
		Labels            func(childComplexity int) int
		MatchExpressions  func(childComplexity int) int
		Message           func(childComplexity int) int
		Model             func(childComplexity int) int
		ModelTypes        func(childComplexity int) int
		Name              func(childComplexity int) int
		Namespace         func(childComplexity int) int
		Replicas          func(childComplexity int) int
		Resources         func(childComplexity int) int
		Status            func(childComplexity int) int
		Type              func(childComplexity int) int
		UpdateTimestamp   func(childComplexity int) int
	}

	WorkerMutation struct {
		CreateWorker  func(childComplexity int, input CreateWorkerInput) int
		DeleteWorkers func(childComplexity int, input *DeleteCommonInput) int
		UpdateWorker  func(childComplexity int, input *UpdateWorkerInput) int
	}

	WorkerQuery struct {
		GetWorker   func(childComplexity int, name string, namespace string) int
		ListWorkers func(childComplexity int, input ListWorkerInput) int
	}

	Filedetail struct {
		Count           func(childComplexity int) int
		FileType        func(childComplexity int) int
		Path            func(childComplexity int) int
		Phase           func(childComplexity int) int
		Size            func(childComplexity int) int
		TimeCost        func(childComplexity int) int
		UpdateTimestamp func(childComplexity int) int
	}

	Filegroup struct {
		Path   func(childComplexity int) int
		Source func(childComplexity int) int
	}

	Filegroupdetail struct {
		Filedetails func(childComplexity int) int
		Source      func(childComplexity int) int
	}
}

type ApplicationMutationResolver interface {
	CreateApplication(ctx context.Context, obj *ApplicationMutation, input CreateApplicationMetadataInput) (*ApplicationMetadata, error)
	UpdateApplication(ctx context.Context, obj *ApplicationMutation, input UpdateApplicationMetadataInput) (*ApplicationMetadata, error)
	DeleteApplication(ctx context.Context, obj *ApplicationMutation, input DeleteCommonInput) (*string, error)
	UpdateApplicationConfig(ctx context.Context, obj *ApplicationMutation, input UpdateApplicationConfigInput) (*Application, error)
}
type ApplicationQueryResolver interface {
	GetApplication(ctx context.Context, obj *ApplicationQuery, name string, namespace string) (*Application, error)
	ListApplicationMetadata(ctx context.Context, obj *ApplicationQuery, input ListCommonInput) (*PaginatedResult, error)
}
type DataProcessMutationResolver interface {
	CreateDataProcessTask(ctx context.Context, obj *DataProcessMutation, input *AddDataProcessInput) (*DataProcessResponse, error)
	DeleteDataProcessTask(ctx context.Context, obj *DataProcessMutation, input *DeleteDataProcessInput) (*DataProcessResponse, error)
}
type DataProcessQueryResolver interface {
	AllDataProcessListByPage(ctx context.Context, obj *DataProcessQuery, input *AllDataProcessListByPageInput) (*PaginatedDataProcessItem, error)
	AllDataProcessListByCount(ctx context.Context, obj *DataProcessQuery, input *AllDataProcessListByCountInput) (*CountDataProcessItem, error)
	DataProcessSupportType(ctx context.Context, obj *DataProcessQuery) (*DataProcessSupportType, error)
	DataProcessDetails(ctx context.Context, obj *DataProcessQuery, input *DataProcessDetailsInput) (*DataProcessDetails, error)
	CheckDataProcessTaskName(ctx context.Context, obj *DataProcessQuery, input *CheckDataProcessTaskNameInput) (*DataProcessResponse, error)
	GetLogInfo(ctx context.Context, obj *DataProcessQuery, input *DataProcessDetailsInput) (*DataProcessResponse, error)
	DataProcessLogInfoByFileName(ctx context.Context, obj *DataProcessQuery, input *DataProcessFileLogInput) (*DataProcessResponse, error)
	DataProcessRetry(ctx context.Context, obj *DataProcessQuery, input *DataProcessRetryInput) (*DataProcessResponse, error)
}
type DatasetResolver interface {
	Versions(ctx context.Context, obj *Dataset, input ListVersionedDatasetInput) (*PaginatedResult, error)
}
type DatasetMutationResolver interface {
	CreateDataset(ctx context.Context, obj *DatasetMutation, input *CreateDatasetInput) (*Dataset, error)
	UpdateDataset(ctx context.Context, obj *DatasetMutation, input *UpdateDatasetInput) (*Dataset, error)
	DeleteDatasets(ctx context.Context, obj *DatasetMutation, input *DeleteCommonInput) (*string, error)
}
type DatasetQueryResolver interface {
	GetDataset(ctx context.Context, obj *DatasetQuery, name string, namespace string) (*Dataset, error)
	ListDatasets(ctx context.Context, obj *DatasetQuery, input *ListDatasetInput) (*PaginatedResult, error)
}
type DatasourceMutationResolver interface {
	CreateDatasource(ctx context.Context, obj *DatasourceMutation, input CreateDatasourceInput) (*Datasource, error)
	UpdateDatasource(ctx context.Context, obj *DatasourceMutation, input *UpdateDatasourceInput) (*Datasource, error)
	DeleteDatasources(ctx context.Context, obj *DatasourceMutation, input *DeleteCommonInput) (*string, error)
}
type DatasourceQueryResolver interface {
	GetDatasource(ctx context.Context, obj *DatasourceQuery, name string, namespace string) (*Datasource, error)
	CheckDatasource(ctx context.Context, obj *DatasourceQuery, input CreateDatasourceInput) (*Datasource, error)
	ListDatasources(ctx context.Context, obj *DatasourceQuery, input ListCommonInput) (*PaginatedResult, error)
}
type EmbedderMutationResolver interface {
	CreateEmbedder(ctx context.Context, obj *EmbedderMutation, input CreateEmbedderInput) (*Embedder, error)
	UpdateEmbedder(ctx context.Context, obj *EmbedderMutation, input *UpdateEmbedderInput) (*Embedder, error)
	DeleteEmbedders(ctx context.Context, obj *EmbedderMutation, input *DeleteCommonInput) (*string, error)
}
type EmbedderQueryResolver interface {
	GetEmbedder(ctx context.Context, obj *EmbedderQuery, name string, namespace string) (*Embedder, error)
	ListEmbedders(ctx context.Context, obj *EmbedderQuery, input ListCommonInput) (*PaginatedResult, error)
}
type GPTQueryResolver interface {
	GetGpt(ctx context.Context, obj *GPTQuery, name string) (*Gpt, error)
	ListGpt(ctx context.Context, obj *GPTQuery, input ListGPTInput) (*PaginatedResult, error)
}
type KnowledgeBaseMutationResolver interface {
	CreateKnowledgeBase(ctx context.Context, obj *KnowledgeBaseMutation, input CreateKnowledgeBaseInput) (*KnowledgeBase, error)
	UpdateKnowledgeBase(ctx context.Context, obj *KnowledgeBaseMutation, input *UpdateKnowledgeBaseInput) (*KnowledgeBase, error)
	DeleteKnowledgeBase(ctx context.Context, obj *KnowledgeBaseMutation, input *DeleteCommonInput) (*string, error)
}
type KnowledgeBaseQueryResolver interface {
	GetKnowledgeBase(ctx context.Context, obj *KnowledgeBaseQuery, name string, namespace string) (*KnowledgeBase, error)
	ListKnowledgeBases(ctx context.Context, obj *KnowledgeBaseQuery, input ListKnowledgeBaseInput) (*PaginatedResult, error)
}
type LLMQueryResolver interface {
	GetLlm(ctx context.Context, obj *LLMQuery, name string, namespace string) (*Llm, error)
	ListLLMs(ctx context.Context, obj *LLMQuery, input ListCommonInput) (*PaginatedResult, error)
}
type ModelResolver interface {
	Files(ctx context.Context, obj *Model, input *FileFilter) (*PaginatedResult, error)
}
type ModelMutationResolver interface {
	CreateModel(ctx context.Context, obj *ModelMutation, input CreateModelInput) (*Model, error)
	UpdateModel(ctx context.Context, obj *ModelMutation, input *UpdateModelInput) (*Model, error)
	DeleteModels(ctx context.Context, obj *ModelMutation, input *DeleteCommonInput) (*string, error)
}
type ModelQueryResolver interface {
	GetModel(ctx context.Context, obj *ModelQuery, name string, namespace string) (*Model, error)
	ListModels(ctx context.Context, obj *ModelQuery, input ListModelInput) (*PaginatedResult, error)
}
type ModelServiceMutationResolver interface {
	CreateModelService(ctx context.Context, obj *ModelServiceMutation, input CreateModelServiceInput) (*ModelService, error)
	UpdateModelService(ctx context.Context, obj *ModelServiceMutation, input *UpdateModelServiceInput) (*ModelService, error)
	DeleteModelService(ctx context.Context, obj *ModelServiceMutation, input *DeleteCommonInput) (*string, error)
}
type ModelServiceQueryResolver interface {
	GetModelService(ctx context.Context, obj *ModelServiceQuery, name string, namespace string) (*ModelService, error)
	ListModelServices(ctx context.Context, obj *ModelServiceQuery, input *ListModelServiceInput) (*PaginatedResult, error)
	CheckModelService(ctx context.Context, obj *ModelServiceQuery, input CreateModelServiceInput) (*ModelService, error)
}
type MutationResolver interface {
	Hello(ctx context.Context, name string) (string, error)
	Application(ctx context.Context) (*ApplicationMutation, error)
	DataProcess(ctx context.Context) (*DataProcessMutation, error)
	Dataset(ctx context.Context) (*DatasetMutation, error)
	Datasource(ctx context.Context) (*DatasourceMutation, error)
	Embedder(ctx context.Context) (*EmbedderMutation, error)
	KnowledgeBase(ctx context.Context) (*KnowledgeBaseMutation, error)
	Model(ctx context.Context) (*ModelMutation, error)
	ModelService(ctx context.Context) (*ModelServiceMutation, error)
	Rag(ctx context.Context) (*RAGMutation, error)
	VersionedDataset(ctx context.Context) (*VersionedDatasetMutation, error)
	Worker(ctx context.Context) (*WorkerMutation, error)
}
type QueryResolver interface {
	Hello(ctx context.Context, name string) (string, error)
	Application(ctx context.Context) (*ApplicationQuery, error)
	DataProcess(ctx context.Context) (*DataProcessQuery, error)
	Dataset(ctx context.Context) (*DatasetQuery, error)
	Datasource(ctx context.Context) (*DatasourceQuery, error)
	Embedder(ctx context.Context) (*EmbedderQuery, error)
	Gpt(ctx context.Context) (*GPTQuery, error)
	KnowledgeBase(ctx context.Context) (*KnowledgeBaseQuery, error)
	Llm(ctx context.Context) (*LLMQuery, error)
	Model(ctx context.Context) (*ModelQuery, error)
	ModelService(ctx context.Context) (*ModelServiceQuery, error)
	Rag(ctx context.Context) (*RAGQuery, error)
	RayCluster(ctx context.Context) (*RayClusterQuery, error)
	VersionedDataset(ctx context.Context) (*VersionedDatasetQuery, error)
	Worker(ctx context.Context) (*WorkerQuery, error)
}
type RAGResolver interface {
	Application(ctx context.Context, obj *Rag) (*Application, error)
	Datasets(ctx context.Context, obj *Rag) ([]*RAGDataset, error)
	JudgeLlm(ctx context.Context, obj *Rag) (*Llm, error)
	Metrics(ctx context.Context, obj *Rag) ([]*RAGMetric, error)
}
type RAGMutationResolver interface {
	CreateRag(ctx context.Context, obj *RAGMutation, input CreateRAGInput) (*Rag, error)
	UpdateRag(ctx context.Context, obj *RAGMutation, input UpdateRAGInput) (*Rag, error)
	DeleteRag(ctx context.Context, obj *RAGMutation, input DeleteRAGInput) (*string, error)
	DuplicateRag(ctx context.Context, obj *RAGMutation, input DuplicateRAGInput) (*Rag, error)
}
type RAGQueryResolver interface {
	GetRag(ctx context.Context, obj *RAGQuery, name string, namespace string) (*Rag, error)
	ListRag(ctx context.Context, obj *RAGQuery, input ListRAGInput) (*PaginatedResult, error)
}
type RayClusterQueryResolver interface {
	ListRayClusters(ctx context.Context, obj *RayClusterQuery, input ListCommonInput) (*PaginatedResult, error)
}
type VersionedDatasetResolver interface {
	Files(ctx context.Context, obj *VersionedDataset, input *FileFilter) (*PaginatedResult, error)
}
type VersionedDatasetMutationResolver interface {
	CreateVersionedDataset(ctx context.Context, obj *VersionedDatasetMutation, input CreateVersionedDatasetInput) (*VersionedDataset, error)
	UpdateVersionedDataset(ctx context.Context, obj *VersionedDatasetMutation, input UpdateVersionedDatasetInput) (*VersionedDataset, error)
	DeleteVersionedDatasets(ctx context.Context, obj *VersionedDatasetMutation, input DeleteVersionedDatasetInput) (*string, error)
}
type VersionedDatasetQueryResolver interface {
	GetVersionedDataset(ctx context.Context, obj *VersionedDatasetQuery, name string, namespace string) (*VersionedDataset, error)
	ListVersionedDatasets(ctx context.Context, obj *VersionedDatasetQuery, input ListVersionedDatasetInput) (*PaginatedResult, error)
}
type WorkerMutationResolver interface {
	CreateWorker(ctx context.Context, obj *WorkerMutation, input CreateWorkerInput) (*Worker, error)
	UpdateWorker(ctx context.Context, obj *WorkerMutation, input *UpdateWorkerInput) (*Worker, error)
	DeleteWorkers(ctx context.Context, obj *WorkerMutation, input *DeleteCommonInput) (*string, error)
}
type WorkerQueryResolver interface {
	GetWorker(ctx context.Context, obj *WorkerQuery, name string, namespace string) (*Worker, error)
	ListWorkers(ctx context.Context, obj *WorkerQuery, input ListWorkerInput) (*PaginatedResult, error)
}

type executableSchema struct {
	schema     *ast.Schema
	resolvers  ResolverRoot
	directives DirectiveRoot
	complexity ComplexityRoot
}

func (e *executableSchema) Schema() *ast.Schema {
	if e.schema != nil {
		return e.schema
	}
	return parsedSchema
}

func (e *executableSchema) Complexity(typeName, field string, childComplexity int, rawArgs map[string]interface{}) (int, bool) {
	ec := executionContext{nil, e, 0, 0, nil}
	_ = ec
	switch typeName + "." + field {

	case "Application.conversionWindowSize":
		if e.complexity.Application.ConversionWindowSize == nil {
			break
		}

		return e.complexity.Application.ConversionWindowSize(childComplexity), true

	case "Application.docNullReturn":
		if e.complexity.Application.DocNullReturn == nil {
			break
		}

		return e.complexity.Application.DocNullReturn(childComplexity), true

	case "Application.knowledgebase":
		if e.complexity.Application.Knowledgebase == nil {
			break
		}

		return e.complexity.Application.Knowledgebase(childComplexity), true

	case "Application.llm":
		if e.complexity.Application.Llm == nil {
			break
		}

		return e.complexity.Application.Llm(childComplexity), true

	case "Application.maxLength":
		if e.complexity.Application.MaxLength == nil {
			break
		}

		return e.complexity.Application.MaxLength(childComplexity), true

	case "Application.maxTokens":
		if e.complexity.Application.MaxTokens == nil {
			break
		}

		return e.complexity.Application.MaxTokens(childComplexity), true

	case "Application.metadata":
		if e.complexity.Application.Metadata == nil {
			break
		}

		return e.complexity.Application.Metadata(childComplexity), true

	case "Application.model":
		if e.complexity.Application.Model == nil {
			break
		}

		return e.complexity.Application.Model(childComplexity), true

	case "Application.numDocuments":
		if e.complexity.Application.NumDocuments == nil {
			break
		}

		return e.complexity.Application.NumDocuments(childComplexity), true

	case "Application.prologue":
		if e.complexity.Application.Prologue == nil {
			break
		}

		return e.complexity.Application.Prologue(childComplexity), true

	case "Application.scoreThreshold":
		if e.complexity.Application.ScoreThreshold == nil {
			break
		}

		return e.complexity.Application.ScoreThreshold(childComplexity), true

	case "Application.showNextGuide":
		if e.complexity.Application.ShowNextGuide == nil {
			break
		}

		return e.complexity.Application.ShowNextGuide(childComplexity), true

	case "Application.showRespInfo":
		if e.complexity.Application.ShowRespInfo == nil {
			break
		}

		return e.complexity.Application.ShowRespInfo(childComplexity), true

	case "Application.showRetrievalInfo":
		if e.complexity.Application.ShowRetrievalInfo == nil {
			break
		}

		return e.complexity.Application.ShowRetrievalInfo(childComplexity), true

	case "Application.temperature":
		if e.complexity.Application.Temperature == nil {
			break
		}

		return e.complexity.Application.Temperature(childComplexity), true

	case "Application.tools":
		if e.complexity.Application.Tools == nil {
			break
		}

		return e.complexity.Application.Tools(childComplexity), true

	case "Application.userPrompt":
		if e.complexity.Application.UserPrompt == nil {
			break
		}

		return e.complexity.Application.UserPrompt(childComplexity), true

	case "ApplicationMetadata.annotations":
		if e.complexity.ApplicationMetadata.Annotations == nil {
			break
		}

		return e.complexity.ApplicationMetadata.Annotations(childComplexity), true

	case "ApplicationMetadata.category":
		if e.complexity.ApplicationMetadata.Category == nil {
			break
		}

		return e.complexity.ApplicationMetadata.Category(childComplexity), true

	case "ApplicationMetadata.creationTimestamp":
		if e.complexity.ApplicationMetadata.CreationTimestamp == nil {
			break
		}

		return e.complexity.ApplicationMetadata.CreationTimestamp(childComplexity), true

	case "ApplicationMetadata.creator":
		if e.complexity.ApplicationMetadata.Creator == nil {
			break
		}

		return e.complexity.ApplicationMetadata.Creator(childComplexity), true

	case "ApplicationMetadata.description":
		if e.complexity.ApplicationMetadata.Description == nil {
			break
		}

		return e.complexity.ApplicationMetadata.Description(childComplexity), true

	case "ApplicationMetadata.displayName":
		if e.complexity.ApplicationMetadata.DisplayName == nil {
			break
		}

		return e.complexity.ApplicationMetadata.DisplayName(childComplexity), true

	case "ApplicationMetadata.id":
		if e.complexity.ApplicationMetadata.ID == nil {
			break
		}

		return e.complexity.ApplicationMetadata.ID(childComplexity), true

	case "ApplicationMetadata.icon":
		if e.complexity.ApplicationMetadata.Icon == nil {
			break
		}

		return e.complexity.ApplicationMetadata.Icon(childComplexity), true

	case "ApplicationMetadata.isPublic":
		if e.complexity.ApplicationMetadata.IsPublic == nil {
			break
		}

		return e.complexity.ApplicationMetadata.IsPublic(childComplexity), true

	case "ApplicationMetadata.labels":
		if e.complexity.ApplicationMetadata.Labels == nil {
			break
		}

		return e.complexity.ApplicationMetadata.Labels(childComplexity), true

	case "ApplicationMetadata.name":
		if e.complexity.ApplicationMetadata.Name == nil {
			break
		}

		return e.complexity.ApplicationMetadata.Name(childComplexity), true

	case "ApplicationMetadata.namespace":
		if e.complexity.ApplicationMetadata.Namespace == nil {
			break
		}

		return e.complexity.ApplicationMetadata.Namespace(childComplexity), true

	case "ApplicationMetadata.status":
		if e.complexity.ApplicationMetadata.Status == nil {
			break
		}

		return e.complexity.ApplicationMetadata.Status(childComplexity), true

	case "ApplicationMetadata.updateTimestamp":
		if e.complexity.ApplicationMetadata.UpdateTimestamp == nil {
			break
		}

		return e.complexity.ApplicationMetadata.UpdateTimestamp(childComplexity), true

	case "ApplicationMutation.createApplication":
		if e.complexity.ApplicationMutation.CreateApplication == nil {
			break
		}

		args, err := ec.field_ApplicationMutation_createApplication_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.ApplicationMutation.CreateApplication(childComplexity, args["input"].(CreateApplicationMetadataInput)), true

	case "ApplicationMutation.deleteApplication":
		if e.complexity.ApplicationMutation.DeleteApplication == nil {
			break
		}

		args, err := ec.field_ApplicationMutation_deleteApplication_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.ApplicationMutation.DeleteApplication(childComplexity, args["input"].(DeleteCommonInput)), true

	case "ApplicationMutation.updateApplication":
		if e.complexity.ApplicationMutation.UpdateApplication == nil {
			break
		}

		args, err := ec.field_ApplicationMutation_updateApplication_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.ApplicationMutation.UpdateApplication(childComplexity, args["input"].(UpdateApplicationMetadataInput)), true

	case "ApplicationMutation.updateApplicationConfig":
		if e.complexity.ApplicationMutation.UpdateApplicationConfig == nil {
			break
		}

		args, err := ec.field_ApplicationMutation_updateApplicationConfig_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.ApplicationMutation.UpdateApplicationConfig(childComplexity, args["input"].(UpdateApplicationConfigInput)), true

	case "ApplicationQuery.getApplication":
		if e.complexity.ApplicationQuery.GetApplication == nil {
			break
		}

		args, err := ec.field_ApplicationQuery_getApplication_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.ApplicationQuery.GetApplication(childComplexity, args["name"].(string), args["namespace"].(string)), true

	case "ApplicationQuery.listApplicationMetadata":
		if e.complexity.ApplicationQuery.ListApplicationMetadata == nil {
			break
		}

		args, err := ec.field_ApplicationQuery_listApplicationMetadata_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.ApplicationQuery.ListApplicationMetadata(childComplexity, args["input"].(ListCommonInput)), true

	case "CountDataProcessItem.data":
		if e.complexity.CountDataProcessItem.Data == nil {
			break
		}

		return e.complexity.CountDataProcessItem.Data(childComplexity), true

	case "CountDataProcessItem.message":
		if e.complexity.CountDataProcessItem.Message == nil {
			break
		}

		return e.complexity.CountDataProcessItem.Message(childComplexity), true

	case "CountDataProcessItem.status":
		if e.complexity.CountDataProcessItem.Status == nil {
			break
		}

		return e.complexity.CountDataProcessItem.Status(childComplexity), true

	case "DataProcessConfig.children":
		if e.complexity.DataProcessConfig.Children == nil {
			break
		}

		return e.complexity.DataProcessConfig.Children(childComplexity), true

	case "DataProcessConfig.description":
		if e.complexity.DataProcessConfig.Description == nil {
			break
		}

		return e.complexity.DataProcessConfig.Description(childComplexity), true

	case "DataProcessConfig.file_num":
		if e.complexity.DataProcessConfig.FileNum == nil {
			break
		}

		return e.complexity.DataProcessConfig.FileNum(childComplexity), true

	case "DataProcessConfig.name":
		if e.complexity.DataProcessConfig.Name == nil {
			break
		}

		return e.complexity.DataProcessConfig.Name(childComplexity), true

	case "DataProcessConfig.status":
		if e.complexity.DataProcessConfig.Status == nil {
			break
		}

		return e.complexity.DataProcessConfig.Status(childComplexity), true

	case "DataProcessConfigChildren.chunk_overlap":
		if e.complexity.DataProcessConfigChildren.ChunkOverlap == nil {
			break
		}

		return e.complexity.DataProcessConfigChildren.ChunkOverlap(childComplexity), true

	case "DataProcessConfigChildren.chunk_size":
		if e.complexity.DataProcessConfigChildren.ChunkSize == nil {
			break
		}

		return e.complexity.DataProcessConfigChildren.ChunkSize(childComplexity), true

	case "DataProcessConfigChildren.description":
		if e.complexity.DataProcessConfigChildren.Description == nil {
			break
		}

		return e.complexity.DataProcessConfigChildren.Description(childComplexity), true

	case "DataProcessConfigChildren.enable":
		if e.complexity.DataProcessConfigChildren.Enable == nil {
			break
		}

		return e.complexity.DataProcessConfigChildren.Enable(childComplexity), true

	case "DataProcessConfigChildren.file_progress":
		if e.complexity.DataProcessConfigChildren.FileProgress == nil {
			break
		}

		return e.complexity.DataProcessConfigChildren.FileProgress(childComplexity), true

	case "DataProcessConfigChildren.llm_config":
		if e.complexity.DataProcessConfigChildren.LlmConfig == nil {
			break
		}

		return e.complexity.DataProcessConfigChildren.LlmConfig(childComplexity), true

	case "DataProcessConfigChildren.name":
		if e.complexity.DataProcessConfigChildren.Name == nil {
			break
		}

		return e.complexity.DataProcessConfigChildren.Name(childComplexity), true

	case "DataProcessConfigChildren.preview":
		if e.complexity.DataProcessConfigChildren.Preview == nil {
			break
		}

		return e.complexity.DataProcessConfigChildren.Preview(childComplexity), true

	case "DataProcessConfigChildren.zh_name":
		if e.complexity.DataProcessConfigChildren.ZhName == nil {
			break
		}

		return e.complexity.DataProcessConfigChildren.ZhName(childComplexity), true

	case "DataProcessConfigInfo.llm_config":
		if e.complexity.DataProcessConfigInfo.LlmConfig == nil {
			break
		}

		return e.complexity.DataProcessConfigInfo.LlmConfig(childComplexity), true

	case "DataProcessConfigInfo.remove_duplicate_config":
		if e.complexity.DataProcessConfigInfo.RemoveDuplicateConfig == nil {
			break
		}

		return e.complexity.DataProcessConfigInfo.RemoveDuplicateConfig(childComplexity), true

	case "DataProcessConfigInfo.type":
		if e.complexity.DataProcessConfigInfo.Type == nil {
			break
		}

		return e.complexity.DataProcessConfigInfo.Type(childComplexity), true

	case "DataProcessConfigpreFileProgress.end_time":
		if e.complexity.DataProcessConfigpreFileProgress.EndTime == nil {
			break
		}

		return e.complexity.DataProcessConfigpreFileProgress.EndTime(childComplexity), true

	case "DataProcessConfigpreFileProgress.file_name":
		if e.complexity.DataProcessConfigpreFileProgress.FileName == nil {
			break
		}

		return e.complexity.DataProcessConfigpreFileProgress.FileName(childComplexity), true

	case "DataProcessConfigpreFileProgress.id":
		if e.complexity.DataProcessConfigpreFileProgress.ID == nil {
			break
		}

		return e.complexity.DataProcessConfigpreFileProgress.ID(childComplexity), true

	case "DataProcessConfigpreFileProgress.progress":
		if e.complexity.DataProcessConfigpreFileProgress.Progress == nil {
			break
		}

		return e.complexity.DataProcessConfigpreFileProgress.Progress(childComplexity), true

	case "DataProcessConfigpreFileProgress.start_time":
		if e.complexity.DataProcessConfigpreFileProgress.StartTime == nil {
			break
		}

		return e.complexity.DataProcessConfigpreFileProgress.StartTime(childComplexity), true

	case "DataProcessConfigpreFileProgress.status":
		if e.complexity.DataProcessConfigpreFileProgress.Status == nil {
			break
		}

		return e.complexity.DataProcessConfigpreFileProgress.Status(childComplexity), true

	case "DataProcessConfigpreView.content":
		if e.complexity.DataProcessConfigpreView.Content == nil {
			break
		}

		return e.complexity.DataProcessConfigpreView.Content(childComplexity), true

	case "DataProcessConfigpreView.file_name":
		if e.complexity.DataProcessConfigpreView.FileName == nil {
			break
		}

		return e.complexity.DataProcessConfigpreView.FileName(childComplexity), true

	case "DataProcessConfigpreViewContent.post":
		if e.complexity.DataProcessConfigpreViewContent.Post == nil {
			break
		}

		return e.complexity.DataProcessConfigpreViewContent.Post(childComplexity), true

	case "DataProcessConfigpreViewContent.pre":
		if e.complexity.DataProcessConfigpreViewContent.Pre == nil {
			break
		}

		return e.complexity.DataProcessConfigpreViewContent.Pre(childComplexity), true

	case "DataProcessDetails.data":
		if e.complexity.DataProcessDetails.Data == nil {
			break
		}

		return e.complexity.DataProcessDetails.Data(childComplexity), true

	case "DataProcessDetails.message":
		if e.complexity.DataProcessDetails.Message == nil {
			break
		}

		return e.complexity.DataProcessDetails.Message(childComplexity), true

	case "DataProcessDetails.status":
		if e.complexity.DataProcessDetails.Status == nil {
			break
		}

		return e.complexity.DataProcessDetails.Status(childComplexity), true

	case "DataProcessDetailsItem.config":
		if e.complexity.DataProcessDetailsItem.Config == nil {
			break
		}

		return e.complexity.DataProcessDetailsItem.Config(childComplexity), true

	case "DataProcessDetailsItem.creator":
		if e.complexity.DataProcessDetailsItem.Creator == nil {
			break
		}

		return e.complexity.DataProcessDetailsItem.Creator(childComplexity), true

	case "DataProcessDetailsItem.data_process_config_info":
		if e.complexity.DataProcessDetailsItem.DataProcessConfigInfo == nil {
			break
		}

		return e.complexity.DataProcessDetailsItem.DataProcessConfigInfo(childComplexity), true

	case "DataProcessDetailsItem.end_time":
		if e.complexity.DataProcessDetailsItem.EndTime == nil {
			break
		}

		return e.complexity.DataProcessDetailsItem.EndTime(childComplexity), true

	case "DataProcessDetailsItem.error_msg":
		if e.complexity.DataProcessDetailsItem.ErrorMsg == nil {
			break
		}

		return e.complexity.DataProcessDetailsItem.ErrorMsg(childComplexity), true

	case "DataProcessDetailsItem.file_num":
		if e.complexity.DataProcessDetailsItem.FileNum == nil {
			break
		}

		return e.complexity.DataProcessDetailsItem.FileNum(childComplexity), true

	case "DataProcessDetailsItem.file_type":
		if e.complexity.DataProcessDetailsItem.FileType == nil {
			break
		}

		return e.complexity.DataProcessDetailsItem.FileType(childComplexity), true

	case "DataProcessDetailsItem.id":
		if e.complexity.DataProcessDetailsItem.ID == nil {
			break
		}

		return e.complexity.DataProcessDetailsItem.ID(childComplexity), true

	case "DataProcessDetailsItem.name":
		if e.complexity.DataProcessDetailsItem.Name == nil {
			break
		}

		return e.complexity.DataProcessDetailsItem.Name(childComplexity), true

	case "DataProcessDetailsItem.post_dataset_name":
		if e.complexity.DataProcessDetailsItem.PostDatasetName == nil {
			break
		}

		return e.complexity.DataProcessDetailsItem.PostDatasetName(childComplexity), true

	case "DataProcessDetailsItem.post_dataset_version":
		if e.complexity.DataProcessDetailsItem.PostDatasetVersion == nil {
			break
		}

		return e.complexity.DataProcessDetailsItem.PostDatasetVersion(childComplexity), true

	case "DataProcessDetailsItem.pre_dataset_name":
		if e.complexity.DataProcessDetailsItem.PreDatasetName == nil {
			break
		}

		return e.complexity.DataProcessDetailsItem.PreDatasetName(childComplexity), true

	case "DataProcessDetailsItem.pre_dataset_version":
		if e.complexity.DataProcessDetailsItem.PreDatasetVersion == nil {
			break
		}

		return e.complexity.DataProcessDetailsItem.PreDatasetVersion(childComplexity), true

	case "DataProcessDetailsItem.start_time":
		if e.complexity.DataProcessDetailsItem.StartTime == nil {
			break
		}

		return e.complexity.DataProcessDetailsItem.StartTime(childComplexity), true

	case "DataProcessDetailsItem.status":
		if e.complexity.DataProcessDetailsItem.Status == nil {
			break
		}

		return e.complexity.DataProcessDetailsItem.Status(childComplexity), true

	case "DataProcessItem.error_msg":
		if e.complexity.DataProcessItem.ErrorMsg == nil {
			break
		}

		return e.complexity.DataProcessItem.ErrorMsg(childComplexity), true

	case "DataProcessItem.id":
		if e.complexity.DataProcessItem.ID == nil {
			break
		}

		return e.complexity.DataProcessItem.ID(childComplexity), true

	case "DataProcessItem.name":
		if e.complexity.DataProcessItem.Name == nil {
			break
		}

		return e.complexity.DataProcessItem.Name(childComplexity), true

	case "DataProcessItem.post_data_set_name":
		if e.complexity.DataProcessItem.PostDataSetName == nil {
			break
		}

		return e.complexity.DataProcessItem.PostDataSetName(childComplexity), true

	case "DataProcessItem.post_data_set_version":
		if e.complexity.DataProcessItem.PostDataSetVersion == nil {
			break
		}

		return e.complexity.DataProcessItem.PostDataSetVersion(childComplexity), true

	case "DataProcessItem.pre_data_set_name":
		if e.complexity.DataProcessItem.PreDataSetName == nil {
			break
		}

		return e.complexity.DataProcessItem.PreDataSetName(childComplexity), true

	case "DataProcessItem.pre_data_set_version":
		if e.complexity.DataProcessItem.PreDataSetVersion == nil {
			break
		}

		return e.complexity.DataProcessItem.PreDataSetVersion(childComplexity), true

	case "DataProcessItem.start_datetime":
		if e.complexity.DataProcessItem.StartDatetime == nil {
			break
		}

		return e.complexity.DataProcessItem.StartDatetime(childComplexity), true

	case "DataProcessItem.status":
		if e.complexity.DataProcessItem.Status == nil {
			break
		}

		return e.complexity.DataProcessItem.Status(childComplexity), true

	case "DataProcessMutation.createDataProcessTask":
		if e.complexity.DataProcessMutation.CreateDataProcessTask == nil {
			break
		}

		args, err := ec.field_DataProcessMutation_createDataProcessTask_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.DataProcessMutation.CreateDataProcessTask(childComplexity, args["input"].(*AddDataProcessInput)), true

	case "DataProcessMutation.deleteDataProcessTask":
		if e.complexity.DataProcessMutation.DeleteDataProcessTask == nil {
			break
		}

		args, err := ec.field_DataProcessMutation_deleteDataProcessTask_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.DataProcessMutation.DeleteDataProcessTask(childComplexity, args["input"].(*DeleteDataProcessInput)), true

	case "DataProcessQuery.allDataProcessListByCount":
		if e.complexity.DataProcessQuery.AllDataProcessListByCount == nil {
			break
		}

		args, err := ec.field_DataProcessQuery_allDataProcessListByCount_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.DataProcessQuery.AllDataProcessListByCount(childComplexity, args["input"].(*AllDataProcessListByCountInput)), true

	case "DataProcessQuery.allDataProcessListByPage":
		if e.complexity.DataProcessQuery.AllDataProcessListByPage == nil {
			break
		}

		args, err := ec.field_DataProcessQuery_allDataProcessListByPage_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.DataProcessQuery.AllDataProcessListByPage(childComplexity, args["input"].(*AllDataProcessListByPageInput)), true

	case "DataProcessQuery.checkDataProcessTaskName":
		if e.complexity.DataProcessQuery.CheckDataProcessTaskName == nil {
			break
		}

		args, err := ec.field_DataProcessQuery_checkDataProcessTaskName_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.DataProcessQuery.CheckDataProcessTaskName(childComplexity, args["input"].(*CheckDataProcessTaskNameInput)), true

	case "DataProcessQuery.dataProcessDetails":
		if e.complexity.DataProcessQuery.DataProcessDetails == nil {
			break
		}

		args, err := ec.field_DataProcessQuery_dataProcessDetails_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.DataProcessQuery.DataProcessDetails(childComplexity, args["input"].(*DataProcessDetailsInput)), true

	case "DataProcessQuery.dataProcessLogInfoByFileName":
		if e.complexity.DataProcessQuery.DataProcessLogInfoByFileName == nil {
			break
		}

		args, err := ec.field_DataProcessQuery_dataProcessLogInfoByFileName_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.DataProcessQuery.DataProcessLogInfoByFileName(childComplexity, args["input"].(*DataProcessFileLogInput)), true

	case "DataProcessQuery.dataProcessRetry":
		if e.complexity.DataProcessQuery.DataProcessRetry == nil {
			break
		}

		args, err := ec.field_DataProcessQuery_dataProcessRetry_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.DataProcessQuery.DataProcessRetry(childComplexity, args["input"].(*DataProcessRetryInput)), true

	case "DataProcessQuery.dataProcessSupportType":
		if e.complexity.DataProcessQuery.DataProcessSupportType == nil {
			break
		}

		return e.complexity.DataProcessQuery.DataProcessSupportType(childComplexity), true

	case "DataProcessQuery.getLogInfo":
		if e.complexity.DataProcessQuery.GetLogInfo == nil {
			break
		}

		args, err := ec.field_DataProcessQuery_getLogInfo_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.DataProcessQuery.GetLogInfo(childComplexity, args["input"].(*DataProcessDetailsInput)), true

	case "DataProcessResponse.data":
		if e.complexity.DataProcessResponse.Data == nil {
			break
		}

		return e.complexity.DataProcessResponse.Data(childComplexity), true

	case "DataProcessResponse.message":
		if e.complexity.DataProcessResponse.Message == nil {
			break
		}

		return e.complexity.DataProcessResponse.Message(childComplexity), true

	case "DataProcessResponse.status":
		if e.complexity.DataProcessResponse.Status == nil {
			break
		}

		return e.complexity.DataProcessResponse.Status(childComplexity), true

	case "DataProcessSupportType.data":
		if e.complexity.DataProcessSupportType.Data == nil {
			break
		}

		return e.complexity.DataProcessSupportType.Data(childComplexity), true

	case "DataProcessSupportType.message":
		if e.complexity.DataProcessSupportType.Message == nil {
			break
		}

		return e.complexity.DataProcessSupportType.Message(childComplexity), true

	case "DataProcessSupportType.status":
		if e.complexity.DataProcessSupportType.Status == nil {
			break
		}

		return e.complexity.DataProcessSupportType.Status(childComplexity), true

	case "DataProcessSupportTypeChildren.description":
		if e.complexity.DataProcessSupportTypeChildren.Description == nil {
			break
		}

		return e.complexity.DataProcessSupportTypeChildren.Description(childComplexity), true

	case "DataProcessSupportTypeChildren.enable":
		if e.complexity.DataProcessSupportTypeChildren.Enable == nil {
			break
		}

		return e.complexity.DataProcessSupportTypeChildren.Enable(childComplexity), true

	case "DataProcessSupportTypeChildren.name":
		if e.complexity.DataProcessSupportTypeChildren.Name == nil {
			break
		}

		return e.complexity.DataProcessSupportTypeChildren.Name(childComplexity), true

	case "DataProcessSupportTypeChildren.zh_name":
		if e.complexity.DataProcessSupportTypeChildren.ZhName == nil {
			break
		}

		return e.complexity.DataProcessSupportTypeChildren.ZhName(childComplexity), true

	case "DataProcessSupportTypeItem.children":
		if e.complexity.DataProcessSupportTypeItem.Children == nil {
			break
		}

		return e.complexity.DataProcessSupportTypeItem.Children(childComplexity), true

	case "DataProcessSupportTypeItem.description":
		if e.complexity.DataProcessSupportTypeItem.Description == nil {
			break
		}

		return e.complexity.DataProcessSupportTypeItem.Description(childComplexity), true

	case "DataProcessSupportTypeItem.name":
		if e.complexity.DataProcessSupportTypeItem.Name == nil {
			break
		}

		return e.complexity.DataProcessSupportTypeItem.Name(childComplexity), true

	case "Dataset.annotations":
		if e.complexity.Dataset.Annotations == nil {
			break
		}

		return e.complexity.Dataset.Annotations(childComplexity), true

	case "Dataset.contentType":
		if e.complexity.Dataset.ContentType == nil {
			break
		}

		return e.complexity.Dataset.ContentType(childComplexity), true

	case "Dataset.creationTimestamp":
		if e.complexity.Dataset.CreationTimestamp == nil {
			break
		}

		return e.complexity.Dataset.CreationTimestamp(childComplexity), true

	case "Dataset.creator":
		if e.complexity.Dataset.Creator == nil {
			break
		}

		return e.complexity.Dataset.Creator(childComplexity), true

	case "Dataset.description":
		if e.complexity.Dataset.Description == nil {
			break
		}

		return e.complexity.Dataset.Description(childComplexity), true

	case "Dataset.displayName":
		if e.complexity.Dataset.DisplayName == nil {
			break
		}

		return e.complexity.Dataset.DisplayName(childComplexity), true

	case "Dataset.field":
		if e.complexity.Dataset.Field == nil {
			break
		}

		return e.complexity.Dataset.Field(childComplexity), true

	case "Dataset.labels":
		if e.complexity.Dataset.Labels == nil {
			break
		}

		return e.complexity.Dataset.Labels(childComplexity), true

	case "Dataset.name":
		if e.complexity.Dataset.Name == nil {
			break
		}

		return e.complexity.Dataset.Name(childComplexity), true

	case "Dataset.namespace":
		if e.complexity.Dataset.Namespace == nil {
			break
		}

		return e.complexity.Dataset.Namespace(childComplexity), true

	case "Dataset.updateTimestamp":
		if e.complexity.Dataset.UpdateTimestamp == nil {
			break
		}

		return e.complexity.Dataset.UpdateTimestamp(childComplexity), true

	case "Dataset.versions":
		if e.complexity.Dataset.Versions == nil {
			break
		}

		args, err := ec.field_Dataset_versions_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Dataset.Versions(childComplexity, args["input"].(ListVersionedDatasetInput)), true

	case "DatasetMutation.createDataset":
		if e.complexity.DatasetMutation.CreateDataset == nil {
			break
		}

		args, err := ec.field_DatasetMutation_createDataset_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.DatasetMutation.CreateDataset(childComplexity, args["input"].(*CreateDatasetInput)), true

	case "DatasetMutation.deleteDatasets":
		if e.complexity.DatasetMutation.DeleteDatasets == nil {
			break
		}

		args, err := ec.field_DatasetMutation_deleteDatasets_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.DatasetMutation.DeleteDatasets(childComplexity, args["input"].(*DeleteCommonInput)), true

	case "DatasetMutation.updateDataset":
		if e.complexity.DatasetMutation.UpdateDataset == nil {
			break
		}

		args, err := ec.field_DatasetMutation_updateDataset_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.DatasetMutation.UpdateDataset(childComplexity, args["input"].(*UpdateDatasetInput)), true

	case "DatasetQuery.getDataset":
		if e.complexity.DatasetQuery.GetDataset == nil {
			break
		}

		args, err := ec.field_DatasetQuery_getDataset_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.DatasetQuery.GetDataset(childComplexity, args["name"].(string), args["namespace"].(string)), true

	case "DatasetQuery.listDatasets":
		if e.complexity.DatasetQuery.ListDatasets == nil {
			break
		}

		args, err := ec.field_DatasetQuery_listDatasets_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.DatasetQuery.ListDatasets(childComplexity, args["input"].(*ListDatasetInput)), true

	case "Datasource.annotations":
		if e.complexity.Datasource.Annotations == nil {
			break
		}

		return e.complexity.Datasource.Annotations(childComplexity), true

	case "Datasource.creationTimestamp":
		if e.complexity.Datasource.CreationTimestamp == nil {
			break
		}

		return e.complexity.Datasource.CreationTimestamp(childComplexity), true

	case "Datasource.creator":
		if e.complexity.Datasource.Creator == nil {
			break
		}

		return e.complexity.Datasource.Creator(childComplexity), true

	case "Datasource.description":
		if e.complexity.Datasource.Description == nil {
			break
		}

		return e.complexity.Datasource.Description(childComplexity), true

	case "Datasource.displayName":
		if e.complexity.Datasource.DisplayName == nil {
			break
		}

		return e.complexity.Datasource.DisplayName(childComplexity), true

	case "Datasource.endpoint":
		if e.complexity.Datasource.Endpoint == nil {
			break
		}

		return e.complexity.Datasource.Endpoint(childComplexity), true

	case "Datasource.id":
		if e.complexity.Datasource.ID == nil {
			break
		}

		return e.complexity.Datasource.ID(childComplexity), true

	case "Datasource.labels":
		if e.complexity.Datasource.Labels == nil {
			break
		}

		return e.complexity.Datasource.Labels(childComplexity), true

	case "Datasource.message":
		if e.complexity.Datasource.Message == nil {
			break
		}

		return e.complexity.Datasource.Message(childComplexity), true

	case "Datasource.name":
		if e.complexity.Datasource.Name == nil {
			break
		}

		return e.complexity.Datasource.Name(childComplexity), true

	case "Datasource.namespace":
		if e.complexity.Datasource.Namespace == nil {
			break
		}

		return e.complexity.Datasource.Namespace(childComplexity), true

	case "Datasource.oss":
		if e.complexity.Datasource.Oss == nil {
			break
		}

		return e.complexity.Datasource.Oss(childComplexity), true

	case "Datasource.status":
		if e.complexity.Datasource.Status == nil {
			break
		}

		return e.complexity.Datasource.Status(childComplexity), true

	case "Datasource.type":
		if e.complexity.Datasource.Type == nil {
			break
		}

		return e.complexity.Datasource.Type(childComplexity), true

	case "Datasource.updateTimestamp":
		if e.complexity.Datasource.UpdateTimestamp == nil {
			break
		}

		return e.complexity.Datasource.UpdateTimestamp(childComplexity), true

	case "Datasource.web":
		if e.complexity.Datasource.Web == nil {
			break
		}

		return e.complexity.Datasource.Web(childComplexity), true

	case "DatasourceMutation.createDatasource":
		if e.complexity.DatasourceMutation.CreateDatasource == nil {
			break
		}

		args, err := ec.field_DatasourceMutation_createDatasource_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.DatasourceMutation.CreateDatasource(childComplexity, args["input"].(CreateDatasourceInput)), true

	case "DatasourceMutation.deleteDatasources":
		if e.complexity.DatasourceMutation.DeleteDatasources == nil {
			break
		}

		args, err := ec.field_DatasourceMutation_deleteDatasources_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.DatasourceMutation.DeleteDatasources(childComplexity, args["input"].(*DeleteCommonInput)), true

	case "DatasourceMutation.updateDatasource":
		if e.complexity.DatasourceMutation.UpdateDatasource == nil {
			break
		}

		args, err := ec.field_DatasourceMutation_updateDatasource_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.DatasourceMutation.UpdateDatasource(childComplexity, args["input"].(*UpdateDatasourceInput)), true

	case "DatasourceQuery.checkDatasource":
		if e.complexity.DatasourceQuery.CheckDatasource == nil {
			break
		}

		args, err := ec.field_DatasourceQuery_checkDatasource_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.DatasourceQuery.CheckDatasource(childComplexity, args["input"].(CreateDatasourceInput)), true

	case "DatasourceQuery.getDatasource":
		if e.complexity.DatasourceQuery.GetDatasource == nil {
			break
		}

		args, err := ec.field_DatasourceQuery_getDatasource_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.DatasourceQuery.GetDatasource(childComplexity, args["name"].(string), args["namespace"].(string)), true

	case "DatasourceQuery.listDatasources":
		if e.complexity.DatasourceQuery.ListDatasources == nil {
			break
		}

		args, err := ec.field_DatasourceQuery_listDatasources_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.DatasourceQuery.ListDatasources(childComplexity, args["input"].(ListCommonInput)), true

	case "Embedder.annotations":
		if e.complexity.Embedder.Annotations == nil {
			break
		}

		return e.complexity.Embedder.Annotations(childComplexity), true

	case "Embedder.baseUrl":
		if e.complexity.Embedder.BaseURL == nil {
			break
		}

		return e.complexity.Embedder.BaseURL(childComplexity), true

	case "Embedder.creationTimestamp":
		if e.complexity.Embedder.CreationTimestamp == nil {
			break
		}

		return e.complexity.Embedder.CreationTimestamp(childComplexity), true

	case "Embedder.creator":
		if e.complexity.Embedder.Creator == nil {
			break
		}

		return e.complexity.Embedder.Creator(childComplexity), true

	case "Embedder.description":
		if e.complexity.Embedder.Description == nil {
			break
		}

		return e.complexity.Embedder.Description(childComplexity), true

	case "Embedder.displayName":
		if e.complexity.Embedder.DisplayName == nil {
			break
		}

		return e.complexity.Embedder.DisplayName(childComplexity), true

	case "Embedder.id":
		if e.complexity.Embedder.ID == nil {
			break
		}

		return e.complexity.Embedder.ID(childComplexity), true

	case "Embedder.labels":
		if e.complexity.Embedder.Labels == nil {
			break
		}

		return e.complexity.Embedder.Labels(childComplexity), true

	case "Embedder.message":
		if e.complexity.Embedder.Message == nil {
			break
		}

		return e.complexity.Embedder.Message(childComplexity), true

	case "Embedder.models":
		if e.complexity.Embedder.Models == nil {
			break
		}

		return e.complexity.Embedder.Models(childComplexity), true

	case "Embedder.name":
		if e.complexity.Embedder.Name == nil {
			break
		}

		return e.complexity.Embedder.Name(childComplexity), true

	case "Embedder.namespace":
		if e.complexity.Embedder.Namespace == nil {
			break
		}

		return e.complexity.Embedder.Namespace(childComplexity), true

	case "Embedder.provider":
		if e.complexity.Embedder.Provider == nil {
			break
		}

		return e.complexity.Embedder.Provider(childComplexity), true

	case "Embedder.status":
		if e.complexity.Embedder.Status == nil {
			break
		}

		return e.complexity.Embedder.Status(childComplexity), true

	case "Embedder.type":
		if e.complexity.Embedder.Type == nil {
			break
		}

		return e.complexity.Embedder.Type(childComplexity), true

	case "Embedder.updateTimestamp":
		if e.complexity.Embedder.UpdateTimestamp == nil {
			break
		}

		return e.complexity.Embedder.UpdateTimestamp(childComplexity), true

	case "EmbedderMutation.createEmbedder":
		if e.complexity.EmbedderMutation.CreateEmbedder == nil {
			break
		}

		args, err := ec.field_EmbedderMutation_createEmbedder_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.EmbedderMutation.CreateEmbedder(childComplexity, args["input"].(CreateEmbedderInput)), true

	case "EmbedderMutation.deleteEmbedders":
		if e.complexity.EmbedderMutation.DeleteEmbedders == nil {
			break
		}

		args, err := ec.field_EmbedderMutation_deleteEmbedders_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.EmbedderMutation.DeleteEmbedders(childComplexity, args["input"].(*DeleteCommonInput)), true

	case "EmbedderMutation.updateEmbedder":
		if e.complexity.EmbedderMutation.UpdateEmbedder == nil {
			break
		}

		args, err := ec.field_EmbedderMutation_updateEmbedder_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.EmbedderMutation.UpdateEmbedder(childComplexity, args["input"].(*UpdateEmbedderInput)), true

	case "EmbedderQuery.getEmbedder":
		if e.complexity.EmbedderQuery.GetEmbedder == nil {
			break
		}

		args, err := ec.field_EmbedderQuery_getEmbedder_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.EmbedderQuery.GetEmbedder(childComplexity, args["name"].(string), args["namespace"].(string)), true

	case "EmbedderQuery.listEmbedders":
		if e.complexity.EmbedderQuery.ListEmbedders == nil {
			break
		}

		args, err := ec.field_EmbedderQuery_listEmbedders_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.EmbedderQuery.ListEmbedders(childComplexity, args["input"].(ListCommonInput)), true

	case "Endpoint.authSecret":
		if e.complexity.Endpoint.AuthSecret == nil {
			break
		}

		return e.complexity.Endpoint.AuthSecret(childComplexity), true

	case "Endpoint.insecure":
		if e.complexity.Endpoint.Insecure == nil {
			break
		}

		return e.complexity.Endpoint.Insecure(childComplexity), true

	case "Endpoint.url":
		if e.complexity.Endpoint.URL == nil {
			break
		}

		return e.complexity.Endpoint.URL(childComplexity), true

	case "F.count":
		if e.complexity.F.Count == nil {
			break
		}

		return e.complexity.F.Count(childComplexity), true

	case "F.creationTimestamp":
		if e.complexity.F.CreationTimestamp == nil {
			break
		}

		return e.complexity.F.CreationTimestamp(childComplexity), true

	case "F.fileType":
		if e.complexity.F.FileType == nil {
			break
		}

		return e.complexity.F.FileType(childComplexity), true

	case "F.path":
		if e.complexity.F.Path == nil {
			break
		}

		return e.complexity.F.Path(childComplexity), true

	case "F.size":
		if e.complexity.F.Size == nil {
			break
		}

		return e.complexity.F.Size(childComplexity), true

	case "F.time":
		if e.complexity.F.Time == nil {
			break
		}

		return e.complexity.F.Time(childComplexity), true

	case "GPT.category":
		if e.complexity.GPT.Category == nil {
			break
		}

		return e.complexity.GPT.Category(childComplexity), true

	case "GPT.creator":
		if e.complexity.GPT.Creator == nil {
			break
		}

		return e.complexity.GPT.Creator(childComplexity), true

	case "GPT.description":
		if e.complexity.GPT.Description == nil {
			break
		}

		return e.complexity.GPT.Description(childComplexity), true

	case "GPT.displayName":
		if e.complexity.GPT.DisplayName == nil {
			break
		}

		return e.complexity.GPT.DisplayName(childComplexity), true

	case "GPT.hot":
		if e.complexity.GPT.Hot == nil {
			break
		}

		return e.complexity.GPT.Hot(childComplexity), true

	case "GPT.icon":
		if e.complexity.GPT.Icon == nil {
			break
		}

		return e.complexity.GPT.Icon(childComplexity), true

	case "GPT.name":
		if e.complexity.GPT.Name == nil {
			break
		}

		return e.complexity.GPT.Name(childComplexity), true

	case "GPT.prologue":
		if e.complexity.GPT.Prologue == nil {
			break
		}

		return e.complexity.GPT.Prologue(childComplexity), true

	case "GPTQuery.getGPT":
		if e.complexity.GPTQuery.GetGpt == nil {
			break
		}

		args, err := ec.field_GPTQuery_getGPT_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.GPTQuery.GetGpt(childComplexity, args["name"].(string)), true

	case "GPTQuery.listGPT":
		if e.complexity.GPTQuery.ListGpt == nil {
			break
		}

		args, err := ec.field_GPTQuery_listGPT_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.GPTQuery.ListGpt(childComplexity, args["input"].(ListGPTInput)), true

	case "KnowledgeBase.annotations":
		if e.complexity.KnowledgeBase.Annotations == nil {
			break
		}

		return e.complexity.KnowledgeBase.Annotations(childComplexity), true

	case "KnowledgeBase.batchSize":
		if e.complexity.KnowledgeBase.BatchSize == nil {
			break
		}

		return e.complexity.KnowledgeBase.BatchSize(childComplexity), true

	case "KnowledgeBase.chunkOverlap":
		if e.complexity.KnowledgeBase.ChunkOverlap == nil {
			break
		}

		return e.complexity.KnowledgeBase.ChunkOverlap(childComplexity), true

	case "KnowledgeBase.chunkSize":
		if e.complexity.KnowledgeBase.ChunkSize == nil {
			break
		}

		return e.complexity.KnowledgeBase.ChunkSize(childComplexity), true

	case "KnowledgeBase.creationTimestamp":
		if e.complexity.KnowledgeBase.CreationTimestamp == nil {
			break
		}

		return e.complexity.KnowledgeBase.CreationTimestamp(childComplexity), true

	case "KnowledgeBase.creator":
		if e.complexity.KnowledgeBase.Creator == nil {
			break
		}

		return e.complexity.KnowledgeBase.Creator(childComplexity), true

	case "KnowledgeBase.description":
		if e.complexity.KnowledgeBase.Description == nil {
			break
		}

		return e.complexity.KnowledgeBase.Description(childComplexity), true

	case "KnowledgeBase.displayName":
		if e.complexity.KnowledgeBase.DisplayName == nil {
			break
		}

		return e.complexity.KnowledgeBase.DisplayName(childComplexity), true

	case "KnowledgeBase.embedder":
		if e.complexity.KnowledgeBase.Embedder == nil {
			break
		}

		return e.complexity.KnowledgeBase.Embedder(childComplexity), true

	case "KnowledgeBase.embedderType":
		if e.complexity.KnowledgeBase.EmbedderType == nil {
			break
		}

		return e.complexity.KnowledgeBase.EmbedderType(childComplexity), true

	case "KnowledgeBase.fileGroupDetails":
		if e.complexity.KnowledgeBase.FileGroupDetails == nil {
			break
		}

		return e.complexity.KnowledgeBase.FileGroupDetails(childComplexity), true

	case "KnowledgeBase.id":
		if e.complexity.KnowledgeBase.ID == nil {
			break
		}

		return e.complexity.KnowledgeBase.ID(childComplexity), true

	case "KnowledgeBase.labels":
		if e.complexity.KnowledgeBase.Labels == nil {
			break
		}

		return e.complexity.KnowledgeBase.Labels(childComplexity), true

	case "KnowledgeBase.message":
		if e.complexity.KnowledgeBase.Message == nil {
			break
		}

		return e.complexity.KnowledgeBase.Message(childComplexity), true

	case "KnowledgeBase.name":
		if e.complexity.KnowledgeBase.Name == nil {
			break
		}

		return e.complexity.KnowledgeBase.Name(childComplexity), true

	case "KnowledgeBase.namespace":
		if e.complexity.KnowledgeBase.Namespace == nil {
			break
		}

		return e.complexity.KnowledgeBase.Namespace(childComplexity), true

	case "KnowledgeBase.reason":
		if e.complexity.KnowledgeBase.Reason == nil {
			break
		}

		return e.complexity.KnowledgeBase.Reason(childComplexity), true

	case "KnowledgeBase.status":
		if e.complexity.KnowledgeBase.Status == nil {
			break
		}

		return e.complexity.KnowledgeBase.Status(childComplexity), true

	case "KnowledgeBase.updateTimestamp":
		if e.complexity.KnowledgeBase.UpdateTimestamp == nil {
			break
		}

		return e.complexity.KnowledgeBase.UpdateTimestamp(childComplexity), true

	case "KnowledgeBase.vectorStore":
		if e.complexity.KnowledgeBase.VectorStore == nil {
			break
		}

		return e.complexity.KnowledgeBase.VectorStore(childComplexity), true

	case "KnowledgeBaseMutation.createKnowledgeBase":
		if e.complexity.KnowledgeBaseMutation.CreateKnowledgeBase == nil {
			break
		}

		args, err := ec.field_KnowledgeBaseMutation_createKnowledgeBase_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.KnowledgeBaseMutation.CreateKnowledgeBase(childComplexity, args["input"].(CreateKnowledgeBaseInput)), true

	case "KnowledgeBaseMutation.deleteKnowledgeBase":
		if e.complexity.KnowledgeBaseMutation.DeleteKnowledgeBase == nil {
			break
		}

		args, err := ec.field_KnowledgeBaseMutation_deleteKnowledgeBase_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.KnowledgeBaseMutation.DeleteKnowledgeBase(childComplexity, args["input"].(*DeleteCommonInput)), true

	case "KnowledgeBaseMutation.updateKnowledgeBase":
		if e.complexity.KnowledgeBaseMutation.UpdateKnowledgeBase == nil {
			break
		}

		args, err := ec.field_KnowledgeBaseMutation_updateKnowledgeBase_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.KnowledgeBaseMutation.UpdateKnowledgeBase(childComplexity, args["input"].(*UpdateKnowledgeBaseInput)), true

	case "KnowledgeBaseQuery.getKnowledgeBase":
		if e.complexity.KnowledgeBaseQuery.GetKnowledgeBase == nil {
			break
		}

		args, err := ec.field_KnowledgeBaseQuery_getKnowledgeBase_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.KnowledgeBaseQuery.GetKnowledgeBase(childComplexity, args["name"].(string), args["namespace"].(string)), true

	case "KnowledgeBaseQuery.listKnowledgeBases":
		if e.complexity.KnowledgeBaseQuery.ListKnowledgeBases == nil {
			break
		}

		args, err := ec.field_KnowledgeBaseQuery_listKnowledgeBases_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.KnowledgeBaseQuery.ListKnowledgeBases(childComplexity, args["input"].(ListKnowledgeBaseInput)), true

	case "LLM.annotations":
		if e.complexity.LLM.Annotations == nil {
			break
		}

		return e.complexity.LLM.Annotations(childComplexity), true

	case "LLM.baseUrl":
		if e.complexity.LLM.BaseURL == nil {
			break
		}

		return e.complexity.LLM.BaseURL(childComplexity), true

	case "LLM.creationTimestamp":
		if e.complexity.LLM.CreationTimestamp == nil {
			break
		}

		return e.complexity.LLM.CreationTimestamp(childComplexity), true

	case "LLM.creator":
		if e.complexity.LLM.Creator == nil {
			break
		}

		return e.complexity.LLM.Creator(childComplexity), true

	case "LLM.description":
		if e.complexity.LLM.Description == nil {
			break
		}

		return e.complexity.LLM.Description(childComplexity), true

	case "LLM.displayName":
		if e.complexity.LLM.DisplayName == nil {
			break
		}

		return e.complexity.LLM.DisplayName(childComplexity), true

	case "LLM.id":
		if e.complexity.LLM.ID == nil {
			break
		}

		return e.complexity.LLM.ID(childComplexity), true

	case "LLM.labels":
		if e.complexity.LLM.Labels == nil {
			break
		}

		return e.complexity.LLM.Labels(childComplexity), true

	case "LLM.message":
		if e.complexity.LLM.Message == nil {
			break
		}

		return e.complexity.LLM.Message(childComplexity), true

	case "LLM.models":
		if e.complexity.LLM.Models == nil {
			break
		}

		return e.complexity.LLM.Models(childComplexity), true

	case "LLM.name":
		if e.complexity.LLM.Name == nil {
			break
		}

		return e.complexity.LLM.Name(childComplexity), true

	case "LLM.namespace":
		if e.complexity.LLM.Namespace == nil {
			break
		}

		return e.complexity.LLM.Namespace(childComplexity), true

	case "LLM.provider":
		if e.complexity.LLM.Provider == nil {
			break
		}

		return e.complexity.LLM.Provider(childComplexity), true

	case "LLM.status":
		if e.complexity.LLM.Status == nil {
			break
		}

		return e.complexity.LLM.Status(childComplexity), true

	case "LLM.type":
		if e.complexity.LLM.Type == nil {
			break
		}

		return e.complexity.LLM.Type(childComplexity), true

	case "LLM.updateTimestamp":
		if e.complexity.LLM.UpdateTimestamp == nil {
			break
		}

		return e.complexity.LLM.UpdateTimestamp(childComplexity), true

	case "LLMConfig.max_tokens":
		if e.complexity.LLMConfig.MaxTokens == nil {
			break
		}

		return e.complexity.LLMConfig.MaxTokens(childComplexity), true

	case "LLMConfig.model":
		if e.complexity.LLMConfig.Model == nil {
			break
		}

		return e.complexity.LLMConfig.Model(childComplexity), true

	case "LLMConfig.name":
		if e.complexity.LLMConfig.Name == nil {
			break
		}

		return e.complexity.LLMConfig.Name(childComplexity), true

	case "LLMConfig.namespace":
		if e.complexity.LLMConfig.Namespace == nil {
			break
		}

		return e.complexity.LLMConfig.Namespace(childComplexity), true

	case "LLMConfig.prompt_template":
		if e.complexity.LLMConfig.PromptTemplate == nil {
			break
		}

		return e.complexity.LLMConfig.PromptTemplate(childComplexity), true

	case "LLMConfig.provider":
		if e.complexity.LLMConfig.Provider == nil {
			break
		}

		return e.complexity.LLMConfig.Provider(childComplexity), true

	case "LLMConfig.temperature":
		if e.complexity.LLMConfig.Temperature == nil {
			break
		}

		return e.complexity.LLMConfig.Temperature(childComplexity), true

	case "LLMConfig.top_p":
		if e.complexity.LLMConfig.TopP == nil {
			break
		}

		return e.complexity.LLMConfig.TopP(childComplexity), true

	case "LLMQuery.getLLM":
		if e.complexity.LLMQuery.GetLlm == nil {
			break
		}

		args, err := ec.field_LLMQuery_getLLM_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.LLMQuery.GetLlm(childComplexity, args["name"].(string), args["namespace"].(string)), true

	case "LLMQuery.listLLMs":
		if e.complexity.LLMQuery.ListLLMs == nil {
			break
		}

		args, err := ec.field_LLMQuery_listLLMs_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.LLMQuery.ListLLMs(childComplexity, args["input"].(ListCommonInput)), true

	case "LabelSelectorRequirement.key":
		if e.complexity.LabelSelectorRequirement.Key == nil {
			break
		}

		return e.complexity.LabelSelectorRequirement.Key(childComplexity), true

	case "LabelSelectorRequirement.operator":
		if e.complexity.LabelSelectorRequirement.Operator == nil {
			break
		}

		return e.complexity.LabelSelectorRequirement.Operator(childComplexity), true

	case "LabelSelectorRequirement.values":
		if e.complexity.LabelSelectorRequirement.Values == nil {
			break
		}

		return e.complexity.LabelSelectorRequirement.Values(childComplexity), true

	case "Model.annotations":
		if e.complexity.Model.Annotations == nil {
			break
		}

		return e.complexity.Model.Annotations(childComplexity), true

	case "Model.creationTimestamp":
		if e.complexity.Model.CreationTimestamp == nil {
			break
		}

		return e.complexity.Model.CreationTimestamp(childComplexity), true

	case "Model.creator":
		if e.complexity.Model.Creator == nil {
			break
		}

		return e.complexity.Model.Creator(childComplexity), true

	case "Model.description":
		if e.complexity.Model.Description == nil {
			break
		}

		return e.complexity.Model.Description(childComplexity), true

	case "Model.displayName":
		if e.complexity.Model.DisplayName == nil {
			break
		}

		return e.complexity.Model.DisplayName(childComplexity), true

	case "Model.files":
		if e.complexity.Model.Files == nil {
			break
		}

		args, err := ec.field_Model_files_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Model.Files(childComplexity, args["input"].(*FileFilter)), true

	case "Model.huggingFaceRepo":
		if e.complexity.Model.HuggingFaceRepo == nil {
			break
		}

		return e.complexity.Model.HuggingFaceRepo(childComplexity), true

	case "Model.id":
		if e.complexity.Model.ID == nil {
			break
		}

		return e.complexity.Model.ID(childComplexity), true

	case "Model.labels":
		if e.complexity.Model.Labels == nil {
			break
		}

		return e.complexity.Model.Labels(childComplexity), true

	case "Model.message":
		if e.complexity.Model.Message == nil {
			break
		}

		return e.complexity.Model.Message(childComplexity), true

	case "Model.modelScopeRepo":
		if e.complexity.Model.ModelScopeRepo == nil {
			break
		}

		return e.complexity.Model.ModelScopeRepo(childComplexity), true

	case "Model.modelSource":
		if e.complexity.Model.ModelSource == nil {
			break
		}

		return e.complexity.Model.ModelSource(childComplexity), true

	case "Model.name":
		if e.complexity.Model.Name == nil {
			break
		}

		return e.complexity.Model.Name(childComplexity), true

	case "Model.namespace":
		if e.complexity.Model.Namespace == nil {
			break
		}

		return e.complexity.Model.Namespace(childComplexity), true

	case "Model.revision":
		if e.complexity.Model.Revision == nil {
			break
		}

		return e.complexity.Model.Revision(childComplexity), true

	case "Model.status":
		if e.complexity.Model.Status == nil {
			break
		}

		return e.complexity.Model.Status(childComplexity), true

	case "Model.systemModel":
		if e.complexity.Model.SystemModel == nil {
			break
		}

		return e.complexity.Model.SystemModel(childComplexity), true

	case "Model.types":
		if e.complexity.Model.Types == nil {
			break
		}

		return e.complexity.Model.Types(childComplexity), true

	case "Model.updateTimestamp":
		if e.complexity.Model.UpdateTimestamp == nil {
			break
		}

		return e.complexity.Model.UpdateTimestamp(childComplexity), true

	case "ModelMutation.createModel":
		if e.complexity.ModelMutation.CreateModel == nil {
			break
		}

		args, err := ec.field_ModelMutation_createModel_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.ModelMutation.CreateModel(childComplexity, args["input"].(CreateModelInput)), true

	case "ModelMutation.deleteModels":
		if e.complexity.ModelMutation.DeleteModels == nil {
			break
		}

		args, err := ec.field_ModelMutation_deleteModels_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.ModelMutation.DeleteModels(childComplexity, args["input"].(*DeleteCommonInput)), true

	case "ModelMutation.updateModel":
		if e.complexity.ModelMutation.UpdateModel == nil {
			break
		}

		args, err := ec.field_ModelMutation_updateModel_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.ModelMutation.UpdateModel(childComplexity, args["input"].(*UpdateModelInput)), true

	case "ModelQuery.getModel":
		if e.complexity.ModelQuery.GetModel == nil {
			break
		}

		args, err := ec.field_ModelQuery_getModel_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.ModelQuery.GetModel(childComplexity, args["name"].(string), args["namespace"].(string)), true

	case "ModelQuery.listModels":
		if e.complexity.ModelQuery.ListModels == nil {
			break
		}

		args, err := ec.field_ModelQuery_listModels_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.ModelQuery.ListModels(childComplexity, args["input"].(ListModelInput)), true

	case "ModelService.apiType":
		if e.complexity.ModelService.APIType == nil {
			break
		}

		return e.complexity.ModelService.APIType(childComplexity), true

	case "ModelService.annotations":
		if e.complexity.ModelService.Annotations == nil {
			break
		}

		return e.complexity.ModelService.Annotations(childComplexity), true

	case "ModelService.baseUrl":
		if e.complexity.ModelService.BaseURL == nil {
			break
		}

		return e.complexity.ModelService.BaseURL(childComplexity), true

	case "ModelService.creationTimestamp":
		if e.complexity.ModelService.CreationTimestamp == nil {
			break
		}

		return e.complexity.ModelService.CreationTimestamp(childComplexity), true

	case "ModelService.creator":
		if e.complexity.ModelService.Creator == nil {
			break
		}

		return e.complexity.ModelService.Creator(childComplexity), true

	case "ModelService.description":
		if e.complexity.ModelService.Description == nil {
			break
		}

		return e.complexity.ModelService.Description(childComplexity), true

	case "ModelService.displayName":
		if e.complexity.ModelService.DisplayName == nil {
			break
		}

		return e.complexity.ModelService.DisplayName(childComplexity), true

	case "ModelService.embeddingModels":
		if e.complexity.ModelService.EmbeddingModels == nil {
			break
		}

		return e.complexity.ModelService.EmbeddingModels(childComplexity), true

	case "ModelService.id":
		if e.complexity.ModelService.ID == nil {
			break
		}

		return e.complexity.ModelService.ID(childComplexity), true

	case "ModelService.labels":
		if e.complexity.ModelService.Labels == nil {
			break
		}

		return e.complexity.ModelService.Labels(childComplexity), true

	case "ModelService.llmModels":
		if e.complexity.ModelService.LlmModels == nil {
			break
		}

		return e.complexity.ModelService.LlmModels(childComplexity), true

	case "ModelService.message":
		if e.complexity.ModelService.Message == nil {
			break
		}

		return e.complexity.ModelService.Message(childComplexity), true

	case "ModelService.name":
		if e.complexity.ModelService.Name == nil {
			break
		}

		return e.complexity.ModelService.Name(childComplexity), true

	case "ModelService.namespace":
		if e.complexity.ModelService.Namespace == nil {
			break
		}

		return e.complexity.ModelService.Namespace(childComplexity), true

	case "ModelService.providerType":
		if e.complexity.ModelService.ProviderType == nil {
			break
		}

		return e.complexity.ModelService.ProviderType(childComplexity), true

	case "ModelService.status":
		if e.complexity.ModelService.Status == nil {
			break
		}

		return e.complexity.ModelService.Status(childComplexity), true

	case "ModelService.types":
		if e.complexity.ModelService.Types == nil {
			break
		}

		return e.complexity.ModelService.Types(childComplexity), true

	case "ModelService.updateTimestamp":
		if e.complexity.ModelService.UpdateTimestamp == nil {
			break
		}

		return e.complexity.ModelService.UpdateTimestamp(childComplexity), true

	case "ModelServiceMutation.createModelService":
		if e.complexity.ModelServiceMutation.CreateModelService == nil {
			break
		}

		args, err := ec.field_ModelServiceMutation_createModelService_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.ModelServiceMutation.CreateModelService(childComplexity, args["input"].(CreateModelServiceInput)), true

	case "ModelServiceMutation.deleteModelService":
		if e.complexity.ModelServiceMutation.DeleteModelService == nil {
			break
		}

		args, err := ec.field_ModelServiceMutation_deleteModelService_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.ModelServiceMutation.DeleteModelService(childComplexity, args["input"].(*DeleteCommonInput)), true

	case "ModelServiceMutation.updateModelService":
		if e.complexity.ModelServiceMutation.UpdateModelService == nil {
			break
		}

		args, err := ec.field_ModelServiceMutation_updateModelService_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.ModelServiceMutation.UpdateModelService(childComplexity, args["input"].(*UpdateModelServiceInput)), true

	case "ModelServiceQuery.checkModelService":
		if e.complexity.ModelServiceQuery.CheckModelService == nil {
			break
		}

		args, err := ec.field_ModelServiceQuery_checkModelService_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.ModelServiceQuery.CheckModelService(childComplexity, args["input"].(CreateModelServiceInput)), true

	case "ModelServiceQuery.getModelService":
		if e.complexity.ModelServiceQuery.GetModelService == nil {
			break
		}

		args, err := ec.field_ModelServiceQuery_getModelService_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.ModelServiceQuery.GetModelService(childComplexity, args["name"].(string), args["namespace"].(string)), true

	case "ModelServiceQuery.listModelServices":
		if e.complexity.ModelServiceQuery.ListModelServices == nil {
			break
		}

		args, err := ec.field_ModelServiceQuery_listModelServices_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.ModelServiceQuery.ListModelServices(childComplexity, args["input"].(*ListModelServiceInput)), true

	case "Mutation.Application":
		if e.complexity.Mutation.Application == nil {
			break
		}

		return e.complexity.Mutation.Application(childComplexity), true

	case "Mutation.dataProcess":
		if e.complexity.Mutation.DataProcess == nil {
			break
		}

		return e.complexity.Mutation.DataProcess(childComplexity), true

	case "Mutation.Dataset":
		if e.complexity.Mutation.Dataset == nil {
			break
		}

		return e.complexity.Mutation.Dataset(childComplexity), true

	case "Mutation.Datasource":
		if e.complexity.Mutation.Datasource == nil {
			break
		}

		return e.complexity.Mutation.Datasource(childComplexity), true

	case "Mutation.Embedder":
		if e.complexity.Mutation.Embedder == nil {
			break
		}

		return e.complexity.Mutation.Embedder(childComplexity), true

	case "Mutation.hello":
		if e.complexity.Mutation.Hello == nil {
			break
		}

		args, err := ec.field_Mutation_hello_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.Hello(childComplexity, args["name"].(string)), true

	case "Mutation.KnowledgeBase":
		if e.complexity.Mutation.KnowledgeBase == nil {
			break
		}

		return e.complexity.Mutation.KnowledgeBase(childComplexity), true

	case "Mutation.Model":
		if e.complexity.Mutation.Model == nil {
			break
		}

		return e.complexity.Mutation.Model(childComplexity), true

	case "Mutation.ModelService":
		if e.complexity.Mutation.ModelService == nil {
			break
		}

		return e.complexity.Mutation.ModelService(childComplexity), true

	case "Mutation.RAG":
		if e.complexity.Mutation.Rag == nil {
			break
		}

		return e.complexity.Mutation.Rag(childComplexity), true

	case "Mutation.VersionedDataset":
		if e.complexity.Mutation.VersionedDataset == nil {
			break
		}

		return e.complexity.Mutation.VersionedDataset(childComplexity), true

	case "Mutation.Worker":
		if e.complexity.Mutation.Worker == nil {
			break
		}

		return e.complexity.Mutation.Worker(childComplexity), true

	case "NodeSelectorRequirement.key":
		if e.complexity.NodeSelectorRequirement.Key == nil {
			break
		}

		return e.complexity.NodeSelectorRequirement.Key(childComplexity), true

	case "NodeSelectorRequirement.operator":
		if e.complexity.NodeSelectorRequirement.Operator == nil {
			break
		}

		return e.complexity.NodeSelectorRequirement.Operator(childComplexity), true

	case "NodeSelectorRequirement.values":
		if e.complexity.NodeSelectorRequirement.Values == nil {
			break
		}

		return e.complexity.NodeSelectorRequirement.Values(childComplexity), true

	case "Oss.bucket":
		if e.complexity.Oss.Bucket == nil {
			break
		}

		return e.complexity.Oss.Bucket(childComplexity), true

	case "Oss.object":
		if e.complexity.Oss.Object == nil {
			break
		}

		return e.complexity.Oss.Object(childComplexity), true

	case "PaginatedDataProcessItem.data":
		if e.complexity.PaginatedDataProcessItem.Data == nil {
			break
		}

		return e.complexity.PaginatedDataProcessItem.Data(childComplexity), true

	case "PaginatedDataProcessItem.message":
		if e.complexity.PaginatedDataProcessItem.Message == nil {
			break
		}

		return e.complexity.PaginatedDataProcessItem.Message(childComplexity), true

	case "PaginatedDataProcessItem.status":
		if e.complexity.PaginatedDataProcessItem.Status == nil {
			break
		}

		return e.complexity.PaginatedDataProcessItem.Status(childComplexity), true

	case "PaginatedResult.hasNextPage":
		if e.complexity.PaginatedResult.HasNextPage == nil {
			break
		}

		return e.complexity.PaginatedResult.HasNextPage(childComplexity), true

	case "PaginatedResult.nodes":
		if e.complexity.PaginatedResult.Nodes == nil {
			break
		}

		return e.complexity.PaginatedResult.Nodes(childComplexity), true

	case "PaginatedResult.page":
		if e.complexity.PaginatedResult.Page == nil {
			break
		}

		return e.complexity.PaginatedResult.Page(childComplexity), true

	case "PaginatedResult.pageSize":
		if e.complexity.PaginatedResult.PageSize == nil {
			break
		}

		return e.complexity.PaginatedResult.PageSize(childComplexity), true

	case "PaginatedResult.totalCount":
		if e.complexity.PaginatedResult.TotalCount == nil {
			break
		}

		return e.complexity.PaginatedResult.TotalCount(childComplexity), true

	case "Parameter.key":
		if e.complexity.Parameter.Key == nil {
			break
		}

		return e.complexity.Parameter.Key(childComplexity), true

	case "Parameter.value":
		if e.complexity.Parameter.Value == nil {
			break
		}

		return e.complexity.Parameter.Value(childComplexity), true

	case "PersistentVolumeClaimSpec.accessModes":
		if e.complexity.PersistentVolumeClaimSpec.AccessModes == nil {
			break
		}

		return e.complexity.PersistentVolumeClaimSpec.AccessModes(childComplexity), true

	case "PersistentVolumeClaimSpec.dataSourceRef":
		if e.complexity.PersistentVolumeClaimSpec.DataSourceRef == nil {
			break
		}

		return e.complexity.PersistentVolumeClaimSpec.DataSourceRef(childComplexity), true

	case "PersistentVolumeClaimSpec.datasource":
		if e.complexity.PersistentVolumeClaimSpec.Datasource == nil {
			break
		}

		return e.complexity.PersistentVolumeClaimSpec.Datasource(childComplexity), true

	case "PersistentVolumeClaimSpec.resources":
		if e.complexity.PersistentVolumeClaimSpec.Resources == nil {
			break
		}

		return e.complexity.PersistentVolumeClaimSpec.Resources(childComplexity), true

	case "PersistentVolumeClaimSpec.selector":
		if e.complexity.PersistentVolumeClaimSpec.Selector == nil {
			break
		}

		return e.complexity.PersistentVolumeClaimSpec.Selector(childComplexity), true

	case "PersistentVolumeClaimSpec.storageClassName":
		if e.complexity.PersistentVolumeClaimSpec.StorageClassName == nil {
			break
		}

		return e.complexity.PersistentVolumeClaimSpec.StorageClassName(childComplexity), true

	case "PersistentVolumeClaimSpec.volumeMode":
		if e.complexity.PersistentVolumeClaimSpec.VolumeMode == nil {
			break
		}

		return e.complexity.PersistentVolumeClaimSpec.VolumeMode(childComplexity), true

	case "PersistentVolumeClaimSpec.volumeName":
		if e.complexity.PersistentVolumeClaimSpec.VolumeName == nil {
			break
		}

		return e.complexity.PersistentVolumeClaimSpec.VolumeName(childComplexity), true

	case "Query.Application":
		if e.complexity.Query.Application == nil {
			break
		}

		return e.complexity.Query.Application(childComplexity), true

	case "Query.dataProcess":
		if e.complexity.Query.DataProcess == nil {
			break
		}

		return e.complexity.Query.DataProcess(childComplexity), true

	case "Query.Dataset":
		if e.complexity.Query.Dataset == nil {
			break
		}

		return e.complexity.Query.Dataset(childComplexity), true

	case "Query.Datasource":
		if e.complexity.Query.Datasource == nil {
			break
		}

		return e.complexity.Query.Datasource(childComplexity), true

	case "Query.Embedder":
		if e.complexity.Query.Embedder == nil {
			break
		}

		return e.complexity.Query.Embedder(childComplexity), true

	case "Query.GPT":
		if e.complexity.Query.Gpt == nil {
			break
		}

		return e.complexity.Query.Gpt(childComplexity), true

	case "Query.hello":
		if e.complexity.Query.Hello == nil {
			break
		}

		args, err := ec.field_Query_hello_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Hello(childComplexity, args["name"].(string)), true

	case "Query.KnowledgeBase":
		if e.complexity.Query.KnowledgeBase == nil {
			break
		}

		return e.complexity.Query.KnowledgeBase(childComplexity), true

	case "Query.LLM":
		if e.complexity.Query.Llm == nil {
			break
		}

		return e.complexity.Query.Llm(childComplexity), true

	case "Query.Model":
		if e.complexity.Query.Model == nil {
			break
		}

		return e.complexity.Query.Model(childComplexity), true

	case "Query.ModelService":
		if e.complexity.Query.ModelService == nil {
			break
		}

		return e.complexity.Query.ModelService(childComplexity), true

	case "Query.RAG":
		if e.complexity.Query.Rag == nil {
			break
		}

		return e.complexity.Query.Rag(childComplexity), true

	case "Query.RayCluster":
		if e.complexity.Query.RayCluster == nil {
			break
		}

		return e.complexity.Query.RayCluster(childComplexity), true

	case "Query.VersionedDataset":
		if e.complexity.Query.VersionedDataset == nil {
			break
		}

		return e.complexity.Query.VersionedDataset(childComplexity), true

	case "Query.Worker":
		if e.complexity.Query.Worker == nil {
			break
		}

		return e.complexity.Query.Worker(childComplexity), true

	case "RAG.annotations":
		if e.complexity.RAG.Annotations == nil {
			break
		}

		return e.complexity.RAG.Annotations(childComplexity), true

	case "RAG.application":
		if e.complexity.RAG.Application == nil {
			break
		}

		return e.complexity.RAG.Application(childComplexity), true

	case "RAG.completeTimestamp":
		if e.complexity.RAG.CompleteTimestamp == nil {
			break
		}

		return e.complexity.RAG.CompleteTimestamp(childComplexity), true

	case "RAG.creationTimestamp":
		if e.complexity.RAG.CreationTimestamp == nil {
			break
		}

		return e.complexity.RAG.CreationTimestamp(childComplexity), true

	case "RAG.creator":
		if e.complexity.RAG.Creator == nil {
			break
		}

		return e.complexity.RAG.Creator(childComplexity), true

	case "RAG.datasets":
		if e.complexity.RAG.Datasets == nil {
			break
		}

		return e.complexity.RAG.Datasets(childComplexity), true

	case "RAG.description":
		if e.complexity.RAG.Description == nil {
			break
		}

		return e.complexity.RAG.Description(childComplexity), true

	case "RAG.displayName":
		if e.complexity.RAG.DisplayName == nil {
			break
		}

		return e.complexity.RAG.DisplayName(childComplexity), true

	case "RAG.judgeLLM":
		if e.complexity.RAG.JudgeLlm == nil {
			break
		}

		return e.complexity.RAG.JudgeLlm(childComplexity), true

	case "RAG.labels":
		if e.complexity.RAG.Labels == nil {
			break
		}

		return e.complexity.RAG.Labels(childComplexity), true

	case "RAG.metrics":
		if e.complexity.RAG.Metrics == nil {
			break
		}

		return e.complexity.RAG.Metrics(childComplexity), true

	case "RAG.name":
		if e.complexity.RAG.Name == nil {
			break
		}

		return e.complexity.RAG.Name(childComplexity), true

	case "RAG.namespace":
		if e.complexity.RAG.Namespace == nil {
			break
		}

		return e.complexity.RAG.Namespace(childComplexity), true

	case "RAG.phase":
		if e.complexity.RAG.Phase == nil {
			break
		}

		return e.complexity.RAG.Phase(childComplexity), true

	case "RAG.phaseMessage":
		if e.complexity.RAG.PhaseMessage == nil {
			break
		}

		return e.complexity.RAG.PhaseMessage(childComplexity), true

	case "RAG.serviceAccountName":
		if e.complexity.RAG.ServiceAccountName == nil {
			break
		}

		return e.complexity.RAG.ServiceAccountName(childComplexity), true

	case "RAG.status":
		if e.complexity.RAG.Status == nil {
			break
		}

		return e.complexity.RAG.Status(childComplexity), true

	case "RAG.storage":
		if e.complexity.RAG.Storage == nil {
			break
		}

		return e.complexity.RAG.Storage(childComplexity), true

	case "RAG.suspend":
		if e.complexity.RAG.Suspend == nil {
			break
		}

		return e.complexity.RAG.Suspend(childComplexity), true

	case "RAGDataset.files":
		if e.complexity.RAGDataset.Files == nil {
			break
		}

		return e.complexity.RAGDataset.Files(childComplexity), true

	case "RAGDataset.source":
		if e.complexity.RAGDataset.Source == nil {
			break
		}

		return e.complexity.RAGDataset.Source(childComplexity), true

	case "RAGMetric.metricKind":
		if e.complexity.RAGMetric.MetricKind == nil {
			break
		}

		return e.complexity.RAGMetric.MetricKind(childComplexity), true

	case "RAGMetric.parameters":
		if e.complexity.RAGMetric.Parameters == nil {
			break
		}

		return e.complexity.RAGMetric.Parameters(childComplexity), true

	case "RAGMetric.toleranceThreshbold":
		if e.complexity.RAGMetric.ToleranceThreshbold == nil {
			break
		}

		return e.complexity.RAGMetric.ToleranceThreshbold(childComplexity), true

	case "RAGMutation.createRAG":
		if e.complexity.RAGMutation.CreateRag == nil {
			break
		}

		args, err := ec.field_RAGMutation_createRAG_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.RAGMutation.CreateRag(childComplexity, args["input"].(CreateRAGInput)), true

	case "RAGMutation.deleteRAG":
		if e.complexity.RAGMutation.DeleteRag == nil {
			break
		}

		args, err := ec.field_RAGMutation_deleteRAG_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.RAGMutation.DeleteRag(childComplexity, args["input"].(DeleteRAGInput)), true

	case "RAGMutation.duplicateRAG":
		if e.complexity.RAGMutation.DuplicateRag == nil {
			break
		}

		args, err := ec.field_RAGMutation_duplicateRAG_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.RAGMutation.DuplicateRag(childComplexity, args["input"].(DuplicateRAGInput)), true

	case "RAGMutation.updateRAG":
		if e.complexity.RAGMutation.UpdateRag == nil {
			break
		}

		args, err := ec.field_RAGMutation_updateRAG_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.RAGMutation.UpdateRag(childComplexity, args["input"].(UpdateRAGInput)), true

	case "RAGQuery.getRAG":
		if e.complexity.RAGQuery.GetRag == nil {
			break
		}

		args, err := ec.field_RAGQuery_getRAG_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.RAGQuery.GetRag(childComplexity, args["name"].(string), args["namespace"].(string)), true

	case "RAGQuery.listRAG":
		if e.complexity.RAGQuery.ListRag == nil {
			break
		}

		args, err := ec.field_RAGQuery_listRAG_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.RAGQuery.ListRag(childComplexity, args["input"].(ListRAGInput)), true

	case "RayCluster.dashboardHost":
		if e.complexity.RayCluster.DashboardHost == nil {
			break
		}

		return e.complexity.RayCluster.DashboardHost(childComplexity), true

	case "RayCluster.headAddress":
		if e.complexity.RayCluster.HeadAddress == nil {
			break
		}

		return e.complexity.RayCluster.HeadAddress(childComplexity), true

	case "RayCluster.index":
		if e.complexity.RayCluster.Index == nil {
			break
		}

		return e.complexity.RayCluster.Index(childComplexity), true

	case "RayCluster.name":
		if e.complexity.RayCluster.Name == nil {
			break
		}

		return e.complexity.RayCluster.Name(childComplexity), true

	case "RayCluster.pythonVersion":
		if e.complexity.RayCluster.PythonVersion == nil {
			break
		}

		return e.complexity.RayCluster.PythonVersion(childComplexity), true

	case "RayClusterQuery.listRayClusters":
		if e.complexity.RayClusterQuery.ListRayClusters == nil {
			break
		}

		args, err := ec.field_RayClusterQuery_listRayClusters_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.RayClusterQuery.ListRayClusters(childComplexity, args["input"].(ListCommonInput)), true

	case "RemoveDuplicateConfigItem.embedding_model":
		if e.complexity.RemoveDuplicateConfigItem.EmbeddingModel == nil {
			break
		}

		return e.complexity.RemoveDuplicateConfigItem.EmbeddingModel(childComplexity), true

	case "RemoveDuplicateConfigItem.embedding_name":
		if e.complexity.RemoveDuplicateConfigItem.EmbeddingName == nil {
			break
		}

		return e.complexity.RemoveDuplicateConfigItem.EmbeddingName(childComplexity), true

	case "RemoveDuplicateConfigItem.embedding_namespace":
		if e.complexity.RemoveDuplicateConfigItem.EmbeddingNamespace == nil {
			break
		}

		return e.complexity.RemoveDuplicateConfigItem.EmbeddingNamespace(childComplexity), true

	case "RemoveDuplicateConfigItem.embedding_provider":
		if e.complexity.RemoveDuplicateConfigItem.EmbeddingProvider == nil {
			break
		}

		return e.complexity.RemoveDuplicateConfigItem.EmbeddingProvider(childComplexity), true

	case "RemoveDuplicateConfigItem.similarity":
		if e.complexity.RemoveDuplicateConfigItem.Similarity == nil {
			break
		}

		return e.complexity.RemoveDuplicateConfigItem.Similarity(childComplexity), true

	case "Resource.limits":
		if e.complexity.Resource.Limits == nil {
			break
		}

		return e.complexity.Resource.Limits(childComplexity), true

	case "Resource.requests":
		if e.complexity.Resource.Requests == nil {
			break
		}

		return e.complexity.Resource.Requests(childComplexity), true

	case "Resources.cpu":
		if e.complexity.Resources.CPU == nil {
			break
		}

		return e.complexity.Resources.CPU(childComplexity), true

	case "Resources.memory":
		if e.complexity.Resources.Memory == nil {
			break
		}

		return e.complexity.Resources.Memory(childComplexity), true

	case "Resources.nvidiaGPU":
		if e.complexity.Resources.NvidiaGpu == nil {
			break
		}

		return e.complexity.Resources.NvidiaGpu(childComplexity), true

	case "Selector.matchExpressions":
		if e.complexity.Selector.MatchExpressions == nil {
			break
		}

		return e.complexity.Selector.MatchExpressions(childComplexity), true

	case "Selector.matchLabels":
		if e.complexity.Selector.MatchLabels == nil {
			break
		}

		return e.complexity.Selector.MatchLabels(childComplexity), true

	case "Tool.name":
		if e.complexity.Tool.Name == nil {
			break
		}

		return e.complexity.Tool.Name(childComplexity), true

	case "Tool.params":
		if e.complexity.Tool.Params == nil {
			break
		}

		return e.complexity.Tool.Params(childComplexity), true

	case "TypedObjectReference.apiGroup":
		if e.complexity.TypedObjectReference.APIGroup == nil {
			break
		}

		return e.complexity.TypedObjectReference.APIGroup(childComplexity), true

	case "TypedObjectReference.displayName":
		if e.complexity.TypedObjectReference.DisplayName == nil {
			break
		}

		return e.complexity.TypedObjectReference.DisplayName(childComplexity), true

	case "TypedObjectReference.kind":
		if e.complexity.TypedObjectReference.Kind == nil {
			break
		}

		return e.complexity.TypedObjectReference.Kind(childComplexity), true

	case "TypedObjectReference.name":
		if e.complexity.TypedObjectReference.Name == nil {
			break
		}

		return e.complexity.TypedObjectReference.Name(childComplexity), true

	case "TypedObjectReference.namespace":
		if e.complexity.TypedObjectReference.Namespace == nil {
			break
		}

		return e.complexity.TypedObjectReference.Namespace(childComplexity), true

	case "VersionedDataset.annotations":
		if e.complexity.VersionedDataset.Annotations == nil {
			break
		}

		return e.complexity.VersionedDataset.Annotations(childComplexity), true

	case "VersionedDataset.creationTimestamp":
		if e.complexity.VersionedDataset.CreationTimestamp == nil {
			break
		}

		return e.complexity.VersionedDataset.CreationTimestamp(childComplexity), true

	case "VersionedDataset.creator":
		if e.complexity.VersionedDataset.Creator == nil {
			break
		}

		return e.complexity.VersionedDataset.Creator(childComplexity), true

	case "VersionedDataset.dataProcessMsg":
		if e.complexity.VersionedDataset.DataProcessMsg == nil {
			break
		}

		return e.complexity.VersionedDataset.DataProcessMsg(childComplexity), true

	case "VersionedDataset.dataProcessStatus":
		if e.complexity.VersionedDataset.DataProcessStatus == nil {
			break
		}

		return e.complexity.VersionedDataset.DataProcessStatus(childComplexity), true

	case "VersionedDataset.dataset":
		if e.complexity.VersionedDataset.Dataset == nil {
			break
		}

		return e.complexity.VersionedDataset.Dataset(childComplexity), true

	case "VersionedDataset.description":
		if e.complexity.VersionedDataset.Description == nil {
			break
		}

		return e.complexity.VersionedDataset.Description(childComplexity), true

	case "VersionedDataset.displayName":
		if e.complexity.VersionedDataset.DisplayName == nil {
			break
		}

		return e.complexity.VersionedDataset.DisplayName(childComplexity), true

	case "VersionedDataset.files":
		if e.complexity.VersionedDataset.Files == nil {
			break
		}

		args, err := ec.field_VersionedDataset_files_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.VersionedDataset.Files(childComplexity, args["input"].(*FileFilter)), true

	case "VersionedDataset.id":
		if e.complexity.VersionedDataset.ID == nil {
			break
		}

		return e.complexity.VersionedDataset.ID(childComplexity), true

	case "VersionedDataset.labels":
		if e.complexity.VersionedDataset.Labels == nil {
			break
		}

		return e.complexity.VersionedDataset.Labels(childComplexity), true

	case "VersionedDataset.name":
		if e.complexity.VersionedDataset.Name == nil {
			break
		}

		return e.complexity.VersionedDataset.Name(childComplexity), true

	case "VersionedDataset.namespace":
		if e.complexity.VersionedDataset.Namespace == nil {
			break
		}

		return e.complexity.VersionedDataset.Namespace(childComplexity), true

	case "VersionedDataset.released":
		if e.complexity.VersionedDataset.Released == nil {
			break
		}

		return e.complexity.VersionedDataset.Released(childComplexity), true

	case "VersionedDataset.syncMsg":
		if e.complexity.VersionedDataset.SyncMsg == nil {
			break
		}

		return e.complexity.VersionedDataset.SyncMsg(childComplexity), true

	case "VersionedDataset.syncStatus":
		if e.complexity.VersionedDataset.SyncStatus == nil {
			break
		}

		return e.complexity.VersionedDataset.SyncStatus(childComplexity), true

	case "VersionedDataset.updateTimestamp":
		if e.complexity.VersionedDataset.UpdateTimestamp == nil {
			break
		}

		return e.complexity.VersionedDataset.UpdateTimestamp(childComplexity), true

	case "VersionedDataset.version":
		if e.complexity.VersionedDataset.Version == nil {
			break
		}

		return e.complexity.VersionedDataset.Version(childComplexity), true

	case "VersionedDatasetMutation.createVersionedDataset":
		if e.complexity.VersionedDatasetMutation.CreateVersionedDataset == nil {
			break
		}

		args, err := ec.field_VersionedDatasetMutation_createVersionedDataset_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.VersionedDatasetMutation.CreateVersionedDataset(childComplexity, args["input"].(CreateVersionedDatasetInput)), true

	case "VersionedDatasetMutation.deleteVersionedDatasets":
		if e.complexity.VersionedDatasetMutation.DeleteVersionedDatasets == nil {
			break
		}

		args, err := ec.field_VersionedDatasetMutation_deleteVersionedDatasets_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.VersionedDatasetMutation.DeleteVersionedDatasets(childComplexity, args["input"].(DeleteVersionedDatasetInput)), true

	case "VersionedDatasetMutation.updateVersionedDataset":
		if e.complexity.VersionedDatasetMutation.UpdateVersionedDataset == nil {
			break
		}

		args, err := ec.field_VersionedDatasetMutation_updateVersionedDataset_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.VersionedDatasetMutation.UpdateVersionedDataset(childComplexity, args["input"].(UpdateVersionedDatasetInput)), true

	case "VersionedDatasetQuery.getVersionedDataset":
		if e.complexity.VersionedDatasetQuery.GetVersionedDataset == nil {
			break
		}

		args, err := ec.field_VersionedDatasetQuery_getVersionedDataset_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.VersionedDatasetQuery.GetVersionedDataset(childComplexity, args["name"].(string), args["namespace"].(string)), true

	case "VersionedDatasetQuery.listVersionedDatasets":
		if e.complexity.VersionedDatasetQuery.ListVersionedDatasets == nil {
			break
		}

		args, err := ec.field_VersionedDatasetQuery_listVersionedDatasets_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.VersionedDatasetQuery.ListVersionedDatasets(childComplexity, args["input"].(ListVersionedDatasetInput)), true

	case "Web.recommendIntervalTime":
		if e.complexity.Web.RecommendIntervalTime == nil {
			break
		}

		return e.complexity.Web.RecommendIntervalTime(childComplexity), true

	case "Worker.api":
		if e.complexity.Worker.API == nil {
			break
		}

		return e.complexity.Worker.API(childComplexity), true

	case "Worker.additionalEnvs":
		if e.complexity.Worker.AdditionalEnvs == nil {
			break
		}

		return e.complexity.Worker.AdditionalEnvs(childComplexity), true

	case "Worker.annotations":
		if e.complexity.Worker.Annotations == nil {
			break
		}

		return e.complexity.Worker.Annotations(childComplexity), true

	case "Worker.creationTimestamp":
		if e.complexity.Worker.CreationTimestamp == nil {
			break
		}

		return e.complexity.Worker.CreationTimestamp(childComplexity), true

	case "Worker.creator":
		if e.complexity.Worker.Creator == nil {
			break
		}

		return e.complexity.Worker.Creator(childComplexity), true

	case "Worker.description":
		if e.complexity.Worker.Description == nil {
			break
		}

		return e.complexity.Worker.Description(childComplexity), true

	case "Worker.displayName":
		if e.complexity.Worker.DisplayName == nil {
			break
		}

		return e.complexity.Worker.DisplayName(childComplexity), true

	case "Worker.id":
		if e.complexity.Worker.ID == nil {
			break
		}

		return e.complexity.Worker.ID(childComplexity), true

	case "Worker.labels":
		if e.complexity.Worker.Labels == nil {
			break
		}

		return e.complexity.Worker.Labels(childComplexity), true

	case "Worker.matchExpressions":
		if e.complexity.Worker.MatchExpressions == nil {
			break
		}

		return e.complexity.Worker.MatchExpressions(childComplexity), true

	case "Worker.message":
		if e.complexity.Worker.Message == nil {
			break
		}

		return e.complexity.Worker.Message(childComplexity), true

	case "Worker.model":
		if e.complexity.Worker.Model == nil {
			break
		}

		return e.complexity.Worker.Model(childComplexity), true

	case "Worker.modelTypes":
		if e.complexity.Worker.ModelTypes == nil {
			break
		}

		return e.complexity.Worker.ModelTypes(childComplexity), true

	case "Worker.name":
		if e.complexity.Worker.Name == nil {
			break
		}

		return e.complexity.Worker.Name(childComplexity), true

	case "Worker.namespace":
		if e.complexity.Worker.Namespace == nil {
			break
		}

		return e.complexity.Worker.Namespace(childComplexity), true

	case "Worker.replicas":
		if e.complexity.Worker.Replicas == nil {
			break
		}

		return e.complexity.Worker.Replicas(childComplexity), true

	case "Worker.resources":
		if e.complexity.Worker.Resources == nil {
			break
		}

		return e.complexity.Worker.Resources(childComplexity), true

	case "Worker.status":
		if e.complexity.Worker.Status == nil {
			break
		}

		return e.complexity.Worker.Status(childComplexity), true

	case "Worker.type":
		if e.complexity.Worker.Type == nil {
			break
		}

		return e.complexity.Worker.Type(childComplexity), true

	case "Worker.updateTimestamp":
		if e.complexity.Worker.UpdateTimestamp == nil {
			break
		}

		return e.complexity.Worker.UpdateTimestamp(childComplexity), true

	case "WorkerMutation.createWorker":
		if e.complexity.WorkerMutation.CreateWorker == nil {
			break
		}

		args, err := ec.field_WorkerMutation_createWorker_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.WorkerMutation.CreateWorker(childComplexity, args["input"].(CreateWorkerInput)), true

	case "WorkerMutation.deleteWorkers":
		if e.complexity.WorkerMutation.DeleteWorkers == nil {
			break
		}

		args, err := ec.field_WorkerMutation_deleteWorkers_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.WorkerMutation.DeleteWorkers(childComplexity, args["input"].(*DeleteCommonInput)), true

	case "WorkerMutation.updateWorker":
		if e.complexity.WorkerMutation.UpdateWorker == nil {
			break
		}

		args, err := ec.field_WorkerMutation_updateWorker_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.WorkerMutation.UpdateWorker(childComplexity, args["input"].(*UpdateWorkerInput)), true

	case "WorkerQuery.getWorker":
		if e.complexity.WorkerQuery.GetWorker == nil {
			break
		}

		args, err := ec.field_WorkerQuery_getWorker_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.WorkerQuery.GetWorker(childComplexity, args["name"].(string), args["namespace"].(string)), true

	case "WorkerQuery.listWorkers":
		if e.complexity.WorkerQuery.ListWorkers == nil {
			break
		}

		args, err := ec.field_WorkerQuery_listWorkers_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.WorkerQuery.ListWorkers(childComplexity, args["input"].(ListWorkerInput)), true

	case "filedetail.count":
		if e.complexity.Filedetail.Count == nil {
			break
		}

		return e.complexity.Filedetail.Count(childComplexity), true

	case "filedetail.fileType":
		if e.complexity.Filedetail.FileType == nil {
			break
		}

		return e.complexity.Filedetail.FileType(childComplexity), true

	case "filedetail.path":
		if e.complexity.Filedetail.Path == nil {
			break
		}

		return e.complexity.Filedetail.Path(childComplexity), true

	case "filedetail.phase":
		if e.complexity.Filedetail.Phase == nil {
			break
		}

		return e.complexity.Filedetail.Phase(childComplexity), true

	case "filedetail.size":
		if e.complexity.Filedetail.Size == nil {
			break
		}

		return e.complexity.Filedetail.Size(childComplexity), true

	case "filedetail.timeCost":
		if e.complexity.Filedetail.TimeCost == nil {
			break
		}

		return e.complexity.Filedetail.TimeCost(childComplexity), true

	case "filedetail.updateTimestamp":
		if e.complexity.Filedetail.UpdateTimestamp == nil {
			break
		}

		return e.complexity.Filedetail.UpdateTimestamp(childComplexity), true

	case "filegroup.path":
		if e.complexity.Filegroup.Path == nil {
			break
		}

		return e.complexity.Filegroup.Path(childComplexity), true

	case "filegroup.source":
		if e.complexity.Filegroup.Source == nil {
			break
		}

		return e.complexity.Filegroup.Source(childComplexity), true

	case "filegroupdetail.filedetails":
		if e.complexity.Filegroupdetail.Filedetails == nil {
			break
		}

		return e.complexity.Filegroupdetail.Filedetails(childComplexity), true

	case "filegroupdetail.source":
		if e.complexity.Filegroupdetail.Source == nil {
			break
		}

		return e.complexity.Filegroupdetail.Source(childComplexity), true

	}
	return 0, false
}

func (e *executableSchema) Exec(ctx context.Context) graphql.ResponseHandler {
	rc := graphql.GetOperationContext(ctx)
	ec := executionContext{rc, e, 0, 0, make(chan graphql.DeferredResult)}
	inputUnmarshalMap := graphql.BuildUnmarshalerMap(
		ec.unmarshalInputAddDataProcessInput,
		ec.unmarshalInputAllDataProcessListByCountInput,
		ec.unmarshalInputAllDataProcessListByPageInput,
		ec.unmarshalInputCheckDataProcessTaskNameInput,
		ec.unmarshalInputCreateApplicationMetadataInput,
		ec.unmarshalInputCreateDatasetInput,
		ec.unmarshalInputCreateDatasourceInput,
		ec.unmarshalInputCreateEmbedderInput,
		ec.unmarshalInputCreateKnowledgeBaseInput,
		ec.unmarshalInputCreateLLMInput,
		ec.unmarshalInputCreateModelInput,
		ec.unmarshalInputCreateModelServiceInput,
		ec.unmarshalInputCreateRAGInput,
		ec.unmarshalInputCreateVersionedDatasetInput,
		ec.unmarshalInputCreateWorkerInput,
		ec.unmarshalInputDataProcessConfigItem,
		ec.unmarshalInputDataProcessDetailsInput,
		ec.unmarshalInputDataProcessFileLogInput,
		ec.unmarshalInputDataProcessRetryInput,
		ec.unmarshalInputDeleteCommonInput,
		ec.unmarshalInputDeleteDataProcessInput,
		ec.unmarshalInputDeleteRAGInput,
		ec.unmarshalInputDeleteVersionedDatasetInput,
		ec.unmarshalInputDuplicateRAGInput,
		ec.unmarshalInputEndpointInput,
		ec.unmarshalInputFileFilter,
		ec.unmarshalInputFileGroup,
		ec.unmarshalInputFileItem,
		ec.unmarshalInputLLMConfigItem,
		ec.unmarshalInputLabelSelectorRequirementInput,
		ec.unmarshalInputListCommonInput,
		ec.unmarshalInputListDatasetInput,
		ec.unmarshalInputListGPTInput,
		ec.unmarshalInputListKnowledgeBaseInput,
		ec.unmarshalInputListModelInput,
		ec.unmarshalInputListModelServiceInput,
		ec.unmarshalInputListRAGInput,
		ec.unmarshalInputListVersionedDatasetInput,
		ec.unmarshalInputListWorkerInput,
		ec.unmarshalInputNodeSelectorRequirementInput,
		ec.unmarshalInputOssInput,
		ec.unmarshalInputParameterInput,
		ec.unmarshalInputPersistentVolumeClaimSpecInput,
		ec.unmarshalInputRAGDatasetInput,
		ec.unmarshalInputRAGMetricInput,
		ec.unmarshalInputRemoveDuplicateConfig,
		ec.unmarshalInputResourceInput,
		ec.unmarshalInputResourcesInput,
		ec.unmarshalInputSelectorInput,
		ec.unmarshalInputToolInput,
		ec.unmarshalInputTypedObjectReferenceInput,
		ec.unmarshalInputUpdateApplicationConfigInput,
		ec.unmarshalInputUpdateApplicationMetadataInput,
		ec.unmarshalInputUpdateDatasetInput,
		ec.unmarshalInputUpdateDatasourceInput,
		ec.unmarshalInputUpdateEmbedderInput,
		ec.unmarshalInputUpdateKnowledgeBaseInput,
		ec.unmarshalInputUpdateLLMInput,
		ec.unmarshalInputUpdateModelInput,
		ec.unmarshalInputUpdateModelServiceInput,
		ec.unmarshalInputUpdateRAGInput,
		ec.unmarshalInputUpdateVersionedDatasetInput,
		ec.unmarshalInputUpdateWorkerInput,
		ec.unmarshalInputWebInput,
		ec.unmarshalInputfilegroupinput,
	)
	first := true

	switch rc.Operation.Operation {
	case ast.Query:
		return func(ctx context.Context) *graphql.Response {
			var response graphql.Response
			var data graphql.Marshaler
			if first {
				first = false
				ctx = graphql.WithUnmarshalerMap(ctx, inputUnmarshalMap)
				data = ec._Query(ctx, rc.Operation.SelectionSet)
			} else {
				if atomic.LoadInt32(&ec.pendingDeferred) > 0 {
					result := <-ec.deferredResults
					atomic.AddInt32(&ec.pendingDeferred, -1)
					data = result.Result
					response.Path = result.Path
					response.Label = result.Label
					response.Errors = result.Errors
				} else {
					return nil
				}
			}
			var buf bytes.Buffer
			data.MarshalGQL(&buf)
			response.Data = buf.Bytes()
			if atomic.LoadInt32(&ec.deferred) > 0 {
				hasNext := atomic.LoadInt32(&ec.pendingDeferred) > 0
				response.HasNext = &hasNext
			}

			return &response
		}
	case ast.Mutation:
		return func(ctx context.Context) *graphql.Response {
			if !first {
				return nil
			}
			first = false
			ctx = graphql.WithUnmarshalerMap(ctx, inputUnmarshalMap)
			data := ec._Mutation(ctx, rc.Operation.SelectionSet)
			var buf bytes.Buffer
			data.MarshalGQL(&buf)

			return &graphql.Response{
				Data: buf.Bytes(),
			}
		}

	default:
		return graphql.OneShot(graphql.ErrorResponse(ctx, "unsupported GraphQL operation"))
	}
}

type executionContext struct {
	*graphql.OperationContext
	*executableSchema
	deferred        int32
	pendingDeferred int32
	deferredResults chan graphql.DeferredResult
}

func (ec *executionContext) processDeferredGroup(dg graphql.DeferredGroup) {
	atomic.AddInt32(&ec.pendingDeferred, 1)
	go func() {
		ctx := graphql.WithFreshResponseContext(dg.Context)
		dg.FieldSet.Dispatch(ctx)
		ds := graphql.DeferredResult{
			Path:   dg.Path,
			Label:  dg.Label,
			Result: dg.FieldSet,
			Errors: graphql.GetErrors(ctx),
		}
		// null fields should bubble up
		if dg.FieldSet.Invalids > 0 {
			ds.Result = graphql.Null
		}
		ec.deferredResults <- ds
	}()
}

func (ec *executionContext) introspectSchema() (*introspection.Schema, error) {
	if ec.DisableIntrospection {
		return nil, errors.New("introspection disabled")
	}
	return introspection.WrapSchema(ec.Schema()), nil
}

func (ec *executionContext) introspectType(name string) (*introspection.Type, error) {
	if ec.DisableIntrospection {
		return nil, errors.New("introspection disabled")
	}
	return introspection.WrapTypeFromDef(ec.Schema(), ec.Schema().Types[name]), nil
}

var sources = []*ast.Source{
	{Name: "../schema/application.graphqls", Input: `type ApplicationQuery {
    getApplication(name: String!, namespace: String!): Application!
    listApplicationMetadata(input: ListCommonInput!): PaginatedResult!
}

type ApplicationMutation {
    createApplication(input: CreateApplicationMetadataInput!): ApplicationMetadata!
    updateApplication(input: UpdateApplicationMetadataInput!): ApplicationMetadata!
    deleteApplication(input: DeleteCommonInput!): Void
    updateApplicationConfig(input: UpdateApplicationConfigInput!): Application!
}
extend type Mutation {
    Application: ApplicationMutation
}
extend type Query{
    Application: ApplicationQuery
}

"""
Application

"""
type Application {

    metadata: ApplicationMetadata

    """
    
    """
    prologue: String

    """
    model  gpt-3.5-turbo  chatglm_turbo
    """
    model: String

    """
    llm  Kind  LLM  CR 
    """
    llm: String!

    """
    temperature 
    """
    temperature: Float

    """
    maxLength 
    """
    maxLength: Int

    """
    maxTokens token
    """
    maxTokens: Int

    """
    conversionWindowSize 
    """
    conversionWindowSize: Int

    """
    knowledgebase  Kind  KnowledgeBase  CR 01
    """
    knowledgebase: String

    """
    scoreThreshold 
    """
    scoreThreshold: Float

    """
    numDocuments  
    """
    numDocuments: Int

    """
    docNullReturn 
    """
    docNullReturn: String
    """
    userPrompt  Prompt
    """
    userPrompt: String

    """
    showRespInfo chat
    """
    showRespInfo: Boolean
    """
    showRetrievalInfo chat
    """
    showRetrievalInfo: Boolean
    """
    showNextGuide chat
    """
    showNextGuide: Boolean
    """
    tools 
    """
    tools: [Tool]
}

"""
Application
 Metadata
"""
type ApplicationMetadata {
    """
    
    :  k8s 
    """
    name: String!

    """
     namespace
    : 
    """
    namespace: String!

    """
    idCRmetadata.uid
    """
    id: String
    """
    
    """
    labels: Map

    """
    
    """
    annotations: Map

    """
    
    """
    displayName: String

    """
    
    """
    description: String

    """
    Icon base64
    """
    icon: String

    """
    
    : webhook
    """
    creator: String

    """"""
    creationTimestamp: Time

    """"""
    updateTimestamp: Time

    """IsPublic, """
    isPublic: Boolean

    """
    
    """
    status: String

    """
    category
    """
    category: [String]
}

input CreateApplicationMetadataInput {
    """
    
    :  k8s 
    """
    name: String!

    """
    namespace
    : 
    """
    namespace: String!

    """
    
    """
    labels: Map

    """
    
    """
    annotations: Map

    """
    
    """
    displayName: String!

    """
    
    """
    description: String

    """
    Icon base64
    """
    icon: String!

    """
    IsPublic, 
    """
    isPublic: Boolean

    """
    category
    """
    category: [String]
}

input UpdateApplicationMetadataInput {
    """
    , 
    :  k8s 
    """
    name: String!

    """
     namespace, 
    : 
    """
    namespace: String!

    """
    
    """
    labels: Map

    """
    
    """
    annotations: Map

    """
    
    """
    displayName: String!

    """
    
    """
    description: String

    """
    Icon base64
    """
    icon: String!

    """
    IsPublic, 
    """
    isPublic: Boolean

    """
    category
    """
    category: [String]
}

input UpdateApplicationConfigInput {
    """
    , 
    :  k8s 
    """
    name: String!

    """
     namespace, 
    : 
    """
    namespace: String!

    """
    
    """
    prologue: String

    """
    model  gpt-3.5-turbo  chatglm_turbo
    """
    model: String

    """
    llm  Kind  LLM  CR 
    """
    llm: String!

    """
    temperature 
    """
    temperature: Float

    """
    maxLength 
    """
    maxLength: Int

    """
    maxTokens token
    """
    maxTokens: Int

    """
    conversionWindowSize 
    """
    conversionWindowSize: Int

    """
    knowledgebase  Kind  KnowledgeBase  CR 01
    """
    knowledgebase: String

    """
    scoreThreshold 
    """
    scoreThreshold: Float

    """
    numDocuments  
    """
    numDocuments: Int

    """
    docNullReturn 
    """
    docNullReturn: String
    """
    userPrompt  Prompt
    """
    userPrompt: String
    """
    showRespInfo chat
    """
    showRespInfo: Boolean
    """
    showRetrievalInfo chat
    """
    showRetrievalInfo: Boolean
    """
    showNextGuide chat
    """
    showNextGuide: Boolean
    """
    tools 
    """
    tools: [ToolInput]
}
`, BuiltIn: false},
	{Name: "../schema/dataprocessing.graphqls", Input: `#  Mutation
type DataProcessMutation {
  # 
  createDataProcessTask(input: AddDataProcessInput): DataProcessResponse
  # 
  deleteDataProcessTask(input: DeleteDataProcessInput): DataProcessResponse
}


#  Query
type DataProcessQuery {
  #  
  allDataProcessListByPage(input: AllDataProcessListByPageInput): PaginatedDataProcessItem
  #  
  allDataProcessListByCount(input: AllDataProcessListByCountInput): CountDataProcessItem
  # 
  dataProcessSupportType: DataProcessSupportType
  # 
  dataProcessDetails(input: DataProcessDetailsInput): DataProcessDetails
  # 
  checkDataProcessTaskName(input: CheckDataProcessTaskNameInput): DataProcessResponse
  # 
  getLogInfo(input: DataProcessDetailsInput): DataProcessResponse
  # 
  dataProcessLogInfoByFileName(input: DataProcessFileLogInput): DataProcessResponse
  # 
  dataProcessRetry(input: DataProcessRetryInput): DataProcessResponse
}


input AllDataProcessListByPageInput {
  pageIndex: Int!
  pageSize: Int!
  keyword: String!
  namespace: String!
}

input AllDataProcessListByCountInput {
  keyword: String!
  namespace: String!
}

input AddDataProcessInput {
  name: String!
  file_type: String!
  pre_data_set_name: String!
  pre_data_set_version: String!
  file_names: [FileItem!]
  post_data_set_name: String!
  post_data_set_version: String!
  data_process_config_info: [DataProcessConfigItem!]
  version_data_set_name: String!
  namespace: String!
  creator: String!
}

# 
input FileItem {
  name: String!
}

# 
input DataProcessConfigItem {
  type: String!
  chunk_size: Int
  chunk_overlap: Int
  llm_config: LLMConfigItem
  remove_duplicate_config: RemoveDuplicateConfig
}

# LLM for  
input LLMConfigItem {
  name: String
  namespace: String
  model: String
  temperature: String
  top_p: String
  max_tokens: String
  prompt_template: String
  provider: String
}

input RemoveDuplicateConfig {
  embedding_name: String!
  embedding_namespace: String!
  embedding_model: String!
  embedding_provider: String!
  similarity: String!
}

input DeleteDataProcessInput {
  id: String!
}

input DataProcessDetailsInput {
  id: String!
}

input CheckDataProcessTaskNameInput {
  name: String!
  namespace: String!
}

input DataProcessFileLogInput {
  id: String!
  file_name: String!
  type: String!
}

input DataProcessRetryInput {
  id: String!
  creator: String!
}

# 
type PaginatedDataProcessItem {
  status: Int!
  data: [DataProcessItem!]
  message: String!
}

# 
type CountDataProcessItem {
  status: Int!
  data: Int!
  message: String!
}

# 
type DataProcessItem {
  # 
  id: String!
  # 
  name: String!
  # 
  status: String!
  # 
  pre_data_set_name: String!
  # 
  pre_data_set_version: String!
  # 
  post_data_set_name:String!
  # 
  post_data_set_version: String
  # 
  start_datetime: String!
  # 
  error_msg: String
}

# 
type DataProcessSupportType {
  status: Int!
  data: [DataProcessSupportTypeItem!]
  message: String!
}

# 
type DataProcessSupportTypeItem {
  name: String!
  description: String!
  children: [DataProcessSupportTypeChildren!]
}

# 
type DataProcessSupportTypeChildren {
  name: String!
  zh_name: String!
  enable: String!
  description: String!
}

# 
type DataProcessResponse {
  status: Int!
  data: String!
  message: String!
}


# 
type DataProcessDetails {
  status: Int!
  data: DataProcessDetailsItem!
  message: String!
}

# Item
type DataProcessDetailsItem {
  id: String!
  status: String!
  name: String!
  file_type: String!
  pre_dataset_name: String!
  pre_dataset_version: String!
  post_dataset_name: String!
  post_dataset_version: String!
  file_num: Int!
  start_time: String!
  end_time: String!
  creator: String!
  error_msg: String
  data_process_config_info: [DataProcessConfigInfo!]
  config: [DataProcessConfig!]
}

type DataProcessConfigInfo {
  type: String!
  llm_config: LLMConfig
  remove_duplicate_config: RemoveDuplicateConfigItem
}

type RemoveDuplicateConfigItem {
  embedding_name: String!
  embedding_namespace: String!
  embedding_model: String!
  embedding_provider: String!
  similarity: String!
}

# 
type DataProcessConfig {
  name: String!
  description: String!
  file_num: Int!
  status: String!
  children: [DataProcessConfigChildren]
}

# 
type DataProcessConfigChildren {
  name: String
  enable: String
  zh_name: String
  description: String
  chunk_size: Int
  chunk_overlap: Int
  llm_config: LLMConfig
  preview: [DataProcessConfigpreView]
  file_progress: [DataProcessConfigpreFileProgress]
}

type LLMConfig {
  name: String
  namespace: String
  model: String
  temperature: String
  top_p: String
  max_tokens: String
  prompt_template: String
  provider: String
}

# 
type DataProcessConfigpreView {
  file_name: String
  content: [DataProcessConfigpreViewContent]
}

# 
type DataProcessConfigpreFileProgress {
  id: String
  file_name: String
  status: String
  start_time: String
  end_time: String
  progress: String
}

# 
type DataProcessConfigpreViewContent {
  pre: String
  post: String
}


# mutation
extend type Mutation {
  dataProcess: DataProcessMutation
}

# query
extend type Query {
  dataProcess: DataProcessQuery
}`, BuiltIn: false},
	{Name: "../schema/dataset.graphqls", Input: `"""
Dataset

1. 
2. 

:
- 
- 
- 



 
"""
type Dataset {
    """
    
    : k8s
    """
    name: String!

    """
    namespace(bucket)
    : 
    : 
    """
    namespace: String!

    """"""
    labels: Map

    """"""
    annotations: Map

    """
    
    : webhook
    """
    creator: String

    """"""
    displayName: String

    """"""
    description: String

    """"""
    creationTimestamp: Time
    """, """
    updateTimestamp: Time

    """
    
    : enum{ text image video}
    : 
    """
    contentType: String!

    """
    
    : enum{ xx xx } ()
    """
    field: String
    """
    
    : 
    : (somelabel=abc)(metadata.name=abc)
    """
    versions(input: ListVersionedDatasetInput!): PaginatedResult!
}

""""""
input CreateDatasetInput {
    """
    
    : k8s
    : 
    """
    name: String!

    """
    
    : 
    """
    namespace: String!

    """"""
    labels: Map

    """"""
    annotations: Map

    """"""
    displayName: String
    
    """"""
    description: String

    """"""
    contentType: String!

    """
    
    : enum{ xx xx } ()
    """
    filed: String
}

""""""
input UpdateDatasetInput {
    """
    name, namespace
    : 
    """   
    name: String!
    namespace: String!

    """
    
    :     
    label
    : abc:def aa:bb,  abc:def, aa:bb
    """ 
    labels: Map
    annotations: Map
    
    """"""
    displayName: String

    """"""
    description: String
}

""""""
input ListDatasetInput {
    """
    namespace
    : 
    """
    namespace: String!

    """name"""
    name: String

    """"""
    displayName: String

    """"""    
    labelSelector: String
    """"""   
    fieldSelector: String

    """
    
    : 11
    """
    page: Int

    """
    
    : 10
    """
    pageSize: Int

    """
    : 
    : namespace,name,displayName,contentType,annotations
    """
    keyword: String
}

""""""
type DatasetQuery {
    """"""
    getDataset(name: String!, namespace: String!): Dataset!

    """
    
    : :
    labelSelector: aa=bbb
    fieldSelector= metadata.name=somename
    """
    listDatasets(input: ListDatasetInput): PaginatedResult!
}

""""""
type DatasetMutation {
    """"""
    createDataset(input: CreateDatasetInput): Dataset!
    """"""
    updateDataset(input: UpdateDatasetInput): Dataset!

    """
    
    : 
    : dataset
    : 
    """
    deleteDatasets(input: DeleteCommonInput): Void
}

extend type Query {
    Dataset: DatasetQuery
}

extend type Mutation {
    Dataset: DatasetMutation
}
`, BuiltIn: false},
	{Name: "../schema/datasource.graphqls", Input: `""""""
type Endpoint {
    """url"""
    url: String
    """k8s secret"""
    authSecret: TypedObjectReference
    """false"""
    insecure: Boolean
}

""""""
type Oss {
    """bucket"""
    bucket: String
    """object()"""
    object: String
}

type Web {
    recommendIntervalTime: Int
}

"""
: 
"""
type Datasource {
    """
    id,CRmetadata.uid
    """
    id: String

    """
    
    : k8s
    : 
    """
    name: String!
    """
    
    : 
    """
    namespace: String!

    labels: Map
    annotations: Map

    """
    
    : webhook
    """
    creator: String
    """"""
    displayName: String
    """"""
    description: String

    """"""
    endpoint: Endpoint

    """"""
    type: String!

    """
    
    : 
    """
    oss: Oss

    """
    Web
    : web
    """
    web: Web

    """"""
    status: String

    message: String

    """"""
    creationTimestamp: Time
    """, """
    updateTimestamp: Time
}

""""""
input OssInput {
    bucket: String!
    object: String
}

input WebInput {
    recommendIntervalTime: Int!
}

""""""
input CreateDatasourceInput {
    """
    
    : k8s
    : 
    """
    name: String!

    """
    
    : 
    """
    namespace: String!

    """"""
    labels: Map
    """"""
    annotations: Map

    """"""
    displayName: String
    """"""
    description: String

    """"""
    endpointinput: EndpointInput!

    """"""
    ossinput: OssInput

    """Web"""
    webinput: WebInput
}

""""""
input UpdateDatasourceInput {
    """
    name, namespace
    : 
    """
    name: String!
    namespace: String!

    """
    
    :     
    label
    : abc:def aa:bb,  abc:def, aa:bb
    """ 
    labels: Map
    annotations: Map

    """"""
    displayName: String
    """"""
    description: String

    """"""
    endpointinput: EndpointInput

    """"""
    ossinput: OssInput

    """Web"""
    webinput: WebInput
}


type DatasourceQuery {
    getDatasource(name: String!, namespace: String!): Datasource!
    checkDatasource(input: CreateDatasourceInput!): Datasource!
    listDatasources(input: ListCommonInput!): PaginatedResult!
}

type DatasourceMutation {
    createDatasource(input: CreateDatasourceInput!): Datasource!
    updateDatasource(input: UpdateDatasourceInput): Datasource!
    deleteDatasources(input: DeleteCommonInput): Void
}
# mutation
extend type Mutation {
    Datasource: DatasourceMutation
}
# query
extend type Query{
    Datasource: DatasourceQuery
}
`, BuiltIn: false},
	{Name: "../schema/embedder.graphqls", Input: `type Embedder {
    id: String
    name: String!
    namespace: String!
    labels: Map
    annotations: Map
    creator: String
    displayName: String
    description: String

    """
    
    """
    baseUrl: String!

    """
    Embedder
    """
    models: [String!]
    
    """
    Embedder
    : : worker  3rd_party
    """
    provider: String

    type: String
    creationTimestamp: Time
    updateTimestamp: Time
    status: String
    message: String
}

input CreateEmbedderInput {
    """"""
    name: String!
    """"""
    namespace: String!
    """"""
    labels: Map
    """"""
    annotations: Map
    """"""
    displayName: String
    
    """"""
    description: String

    """()"""
    endpointinput: EndpointInput!

    """
    
    :   zhipuai,openai
    """
    type: String

    """
    Embedder
    """
    models: [String!]
}

input UpdateEmbedderInput {
    """()"""
    name: String!
    """()"""
    namespace: String!

    """"""
    labels: Map
    """"""
    annotations: Map

    """"""
    displayName: String
    """"""
    description: String

    """"""
    endpointinput: EndpointInput

    """
    
    :   zhipuai,openai
    """
    type: String

    """
    Embedder
    """
    models: [String!]
}

type EmbedderQuery {
    getEmbedder(name: String!, namespace: String!): Embedder!
    listEmbedders(input: ListCommonInput!): PaginatedResult!
}

type EmbedderMutation {
    createEmbedder(input: CreateEmbedderInput!): Embedder!
    updateEmbedder(input: UpdateEmbedderInput): Embedder!
    deleteEmbedders(input: DeleteCommonInput): Void
}
# mutation
extend type Mutation {
    Embedder: EmbedderMutation
}
# query
extend type Query{
    Embedder: EmbedderQuery
}
`, BuiltIn: false},
	{Name: "../schema/entrypoint.graphqls", Input: `type Query {
    hello(name: String!): String!
}
type Mutation{
    hello(name: String!): String!
}

""""""
input EndpointInput {
    """()"""
    url: String!
    """secret"""
    auth: Map
    """true"""
    insecure: Boolean
}

input ListCommonInput {
    namespace: String!

    """
    : 
    """
    keyword: String

    """"""
    labelSelector: String
    """"""
    fieldSelector: String
    """
    
    : 11
    """
    page: Int

    """
    
    : -1,
    """
    pageSize: Int
}

input DeleteCommonInput {
    name: String
    namespace: String!
    """"""
    labelSelector: String
    """"""
    fieldSelector: String
}

scalar Time
scalar Map
scalar Void

type PaginatedResult {
    hasNextPage: Boolean!
    nodes: [PageNode!]
    page: Int
    pageSize: Int
    totalCount: Int!
}

input TypedObjectReferenceInput {
    apiGroup: String
    kind: String!
    name: String!
    namespace: String
}

type TypedObjectReference {
    apiGroup: String
    kind: String!
    name: String!
    displayName: String
    namespace: String
}

"""
ToolInput Agent
"""
input ToolInput {
    """
    "Bing Search API","calculator","Weather Query API","Web Scraper"
    - "Bing Search API" bing
    - "calculator" 
    - "Weather Query API" 
    - "Web Scraper" 
    """
    name: String!
    """
    params 
    "Bing Search API"
    - apiKey
    - count5
    - scraperPagebingtrue
    "calculator" 
    "Weather Query API"
    - apiKey
    "Web Scraper"
    - delay3
    - asynctrue
    - handleLinksfalse
    - blacklistlogin,signup,signin,register,logout,download,redirect
    """
    params: Map
}

"""
Tool Agent
"""
type Tool {
    """
    "Bing Search API","calculator","Weather Query API","Web Scraper"
    - "Bing Search API" bing
    - "calculator" 
    - "Weather Query API" 
    - "Web Scraper" 
    """
    name: String
    """
    params 
    "Bing Search API"
    - apiKey
    - count5
    - scraperPagebingtrue
    "calculator" 
    "Weather Query API"
    - apiKey
    "Web Scraper"
    - delay3
    - asynctrue
    - handleLinksfalse
    - blacklistlogin,signup,signin,register,logout,download,redirect
    """
    params: Map
}

union PageNode = Datasource | Model | Embedder | KnowledgeBase | Dataset | VersionedDataset | F | Worker | ApplicationMetadata | LLM | ModelService | RayCluster | RAG | GPT
`, BuiltIn: false},
	{Name: "../schema/gpt.graphqls", Input: `type GPTQuery {
    getGPT(name: String!): GPT!
    listGPT(input: ListGPTInput!): PaginatedResult!
}

extend type Query{
    GPT: GPTQuery
}

input ListGPTInput {

    """
    category: gpt
    and
    """
    category: String

    """
    : 
    """
    keyword: String

    """
    
    : 11
    """
    page: Int

    """
    
    : 10-1
    """
    pageSize: Int
}

"""
GPT
GPT
"""
type GPT {

    """
    name: app namespace/name
    """
    name: String

    """
    displayName: 
    """
    displayName: String

    """
    description: 
    """
    description: String

    """
    hot: 
    """
    hot: Int64

    """
    creator: 
    """
    creator: String

    """
    categorygpt
    """
    category: [String]

    """
    icon: base64
    """
    icon: String

    """
    
    """
    prologue: String
}
`, BuiltIn: false},
	{Name: "../schema/k8s.graphqls", Input: `type LabelSelectorRequirement {
    key: String
    values: [String]
    operator: String
}
input LabelSelectorRequirementInput {
    key: String
    values: [String]
    operator: String
}

type Selector {
    matchLabels: Map
    matchExpressions: [LabelSelectorRequirement]
}
input SelectorInput {
    matchLabels: Map
    matchExpressions: [LabelSelectorRequirementInput]
}


type Resource {
    limits: Map
    requests: Map
}

input ResourceInput {
    limits: Map
    requests: Map
}

type PersistentVolumeClaimSpec {
    accessModes: [String!]!
    selector: Selector
    resources:  Resource
    volumeName: String
    storageClassName: String
    volumeMode: String
    datasource: TypedObjectReference
    dataSourceRef: TypedObjectReference
}

input PersistentVolumeClaimSpecInput {
    accessModes: [String!]!
    selector: SelectorInput
    resources:  ResourceInput
    volumeName: String
    storageClassName: String
    volumeMode: String
    datasource: TypedObjectReferenceInput
    dataSourceRef: TypedObjectReferenceInput
}
`, BuiltIn: false},
	{Name: "../schema/knowledgebase.graphqls", Input: `"""

: ()filegroup
: path
"""
type filegroup{
    """
     Kind VersionedDataset
    """
    source: TypedObjectReference
    """
    
    """
    path: [String!]
}

"""

: 
"""
type filedetail{
    """"""
    path: String!

    """
    
    : enum { QA }
    """
    fileType: String!

    """
    
    """
    count: String!
    
    """
    
    """
    size: String!

    """
    
    """
    updateTimestamp: Time

    """"""
    timeCost: Int!

    """
    
    : enum { Pending , Processing , Succeeded, Failed, Skipped}
    """
    phase: String!
}

"""

: 
"""
type filegroupdetail{
    """
     Kind VersionedDataset
    """
    source: TypedObjectReference

    """
    
     filedetail
    """
    filedetails:[filedetail]
}

"""

"""
type KnowledgeBase {
    """
    id,CRmetadata.uid
    """
    id: String

    """
    
    : k8s
    """
    name: String!

    """
    namespace(bucket)
    : 
    : 
    """
    namespace: String!

    """"""
    labels: Map
    """"""
    annotations: Map
    

    """
    
    : webhook
    """
    creator: String

    """"""
    displayName: String

    """"""
    description: String

    """"""
    creationTimestamp: Time
    """"""
    updateTimestamp: Time
    
    """
    embedderembedding Kind  Embedder
    """
    embedder: TypedObjectReference
    embedderType: String
    """
    vectorStore Kind  VectorStore
    """
    vectorStore: TypedObjectReference
    """
    fileGroupDetails
    """
    fileGroupDetails: [filegroupdetail]


    """
    chunkSize
    """
    chunkSize: Int
    """
    chunkOverlap
    """
    chunkOverlap: Int
    """
    batchSize
    """
    batchSize: Int
    
    """
    
    : True  False  
    : Deleting 
    """
    status: String
    """"""
    reason: String
    """"""
    message: String
}

""""""
input filegroupinput {
    """"""
    source: TypedObjectReferenceInput!
    """"""
    path: [String!]
}

""""""
input CreateKnowledgeBaseInput{
    """"""
    name: String!
    """"""
    namespace: String!

    """"""
    labels: Map
    """"""
    annotations: Map

    """"""
    displayName: String
    """"""
    description: String

     """
    embedderembedding
    """
    embedder: String!

    """"()"""
    vectorStore: TypedObjectReferenceInput
    """"""
    fileGroups: [filegroupinput!]


    """
    chunkSize
    """
    chunkSize: Int
    """
    chunkOverlap
    """
    chunkOverlap: Int
    """
    batchSize
    """
    batchSize: Int
}

""""""
input UpdateKnowledgeBaseInput {
    """"""
    name: String!
    """"""
    namespace: String!
    """"""
    labels: Map
    """"""
    annotations: Map

    """"""
    displayName: String

    """"""
    description: String

    """"""
    fileGroups: [filegroupinput!]

    """
    chunkSize
    """
    chunkSize: Int
    """
    chunkOverlap
    """
    chunkOverlap: Int
    """
    batchSize
    """
    batchSize: Int
}

""""""
input ListKnowledgeBaseInput {
    name: String
    namespace: String!

    displayName: String
    """"""
    labelSelector: String
    """"""
    fieldSelector: String

    """
    
    : 11
    """
    page: Int

    """
    
    : 10
    """
    pageSize: Int

    """
    : 
    : name,displayName
    """
    keyword: String
}

type KnowledgeBaseQuery {
    getKnowledgeBase(name: String!, namespace: String!): KnowledgeBase!
    listKnowledgeBases(input: ListKnowledgeBaseInput!): PaginatedResult!
}

type KnowledgeBaseMutation {
    createKnowledgeBase(input: CreateKnowledgeBaseInput!): KnowledgeBase!
    updateKnowledgeBase(input: UpdateKnowledgeBaseInput): KnowledgeBase!
    deleteKnowledgeBase(input: DeleteCommonInput): Void
}

# mutation
extend type Mutation {
    KnowledgeBase: KnowledgeBaseMutation
}
# query
extend type Query{
    KnowledgeBase: KnowledgeBaseQuery
}
`, BuiltIn: false},
	{Name: "../schema/llm.graphqls", Input: `type LLM {
    id: String
    name: String!
    namespace: String!
    labels: Map
    annotations: Map
    creator: String
    displayName: String
    description: String

    """
    
    """
    baseUrl: String!

    """
    LLM
    """
    models: [String!]

    """
    LLM
    : : worker  3rd_party
    """
    provider: String

    type: String
    creationTimestamp: Time
    updateTimestamp: Time
    status: String
    message: String
}

input CreateLLMInput {
     """"""
    name: String!
    """"""
    namespace: String!
    """"""
    labels: Map
    """"""
    annotations: Map
    """"""
    displayName: String
    
    """"""
    description: String

    """()"""
    endpointinput: EndpointInput!

    """
    
    :   zhipuai,openai
    """
    type: String

        """
    LLM
    """
    models: [String!]
}

input UpdateLLMInput {
    """()"""
    name: String!
    """()"""
    namespace: String!
    """"""
    labels: Map
    """"""
    annotations: Map
    """"""
    displayName: String

    """"""
    description: String

    """"""
    endpointinput: EndpointInput

    """
    
    :   zhipuai,openai
    """
    type: String

    """
    LLM
    """
    models: [String!]
}

type LLMQuery {
    getLLM(name: String!, namespace: String!): LLM!
    listLLMs(input: ListCommonInput!): PaginatedResult!
}

# query
extend type Query{
    LLM: LLMQuery
}`, BuiltIn: false},
	{Name: "../schema/model.graphqls", Input: `""""""
type Model {
    """
    id,CRmetadata.uid
    """
    id: String

    """
    
    : k8s
    """
    name: String!

    """
    namespace(bucket)
    : 
    : 
    """
    namespace: String!

    """
    
    : true
    : 
    """
    systemModel: Boolean

    """"""
    labels: Map
    """"""
    annotations: Map

    """
    
    : webhook
    """
    creator: String

    """"""
    displayName: String

    """"""
    description: String

    """"""
    creationTimestamp: Time
    """"""
    updateTimestamp: Time

    """
    
    :  llmembedding
    :  "llm,embedding"
    """
    types: String!

    """
    
    """
    status: String

    """
    
    """
    message: String

    """
    
    """
    files(input: FileFilter): PaginatedResult!

    """
    modelscopehugginface
    """
    huggingFaceRepo: String
    modelScopeRepo: String

    """
    
    """
    revision: String

    """
    local: minio
    modelscope: modelscope
    huggingface: huggingface
    """
    modelSource: String
}

""""""
input CreateModelInput{
    """"""
    name: String!
    """"""
    namespace: String!

    """"""
    displayName: String
    """"""
    description: String

    """
    
    :  llmembedding
    :  "llm,embedding"
    """
    types: String!

    """
    modelscopehugginface
    """
    huggingFaceRepo: String
    modelScopeRepo: String

    """
    
    """
    revision: String

    """
    local: minio
    modelscope: modelscope
    huggingface: huggingface
    """
    modelSource: String
}

""""""
input UpdateModelInput {
    """"""
    name: String!
    """"""
    namespace: String!

    """"""
    labels: Map
    """"""
    annotations: Map
    """"""
    displayName: String
    """"""
    description: String

    """
    
    :  llmembedding
    :  "llm,embedding"
    """
    types: String

    """
    modelscopehugginface
    """
    huggingFaceRepo: String
    modelScopeRepo: String

    """
    
    """
    revision: String

    """
    local: minio
    modelscope: modelscope
    huggingface: huggingface
    """
    modelSource: String
}

type ModelMutation {
    createModel(input: CreateModelInput!): Model!
    updateModel(input: UpdateModelInput): Model!
    deleteModels(input: DeleteCommonInput): Void
}

input ListModelInput {
    namespace: String!

    """
    
    : true
    : false
    """
    systemModel: Boolean

    """
    : 
    """
    keyword: String

    """"""
    labelSelector: String
    """"""
    fieldSelector: String
    """
    
    : 11
    """
    page: Int

    """
    
    : 10
    """
    pageSize: Int
}

type ModelQuery {
    getModel(name: String!, namespace: String!): Model!
    listModels(input: ListModelInput!): PaginatedResult!
}

extend type Mutation {
    Model: ModelMutation
}

extend type Query {
    Model: ModelQuery
}
`, BuiltIn: false},
	{Name: "../schema/modelservice.graphqls", Input: `type ModelService {
    id: String
    name: String!
    namespace: String!

    labels: Map
    annotations: Map
    
    creator: String
    displayName: String
    description: String

    """
    
    """
    creationTimestamp: Time
    updateTimestamp: Time


    """
    
    : 3rd_party 
    : worker 
    """
    providerType: String


    """
     llm  embedding 
    :  "llm,embedding"
    """
    types: String

    """
     API 
     openai, zhipuai 
    """
    apiType: String


    """
    
    API
    """
    llmModels: [String!]

    """
    Embedding
    API
    """
    embeddingModels: [String!]

    """
    : 
    """
    baseUrl: String!

    """
    
    : 
      - True:  ()
      - False:  ()
      - Unknown:  ()
      - Pending: ()
      - Running:  ()
      - Error:  ()
    """
    status: String

    """"""
    message: String
}

input CreateModelServiceInput {
    """"""
    name: String!
    """"""
    namespace: String!

    """"""
    labels: Map
    """"""
    annotations: Map
    """"""
    displayName: String
    """"""
    description: String

    """
     llm  embedding 
    :  "llm,embedding"
    """
    types: String

    """
     API 
     openai, zhipuai 
    """
    apiType: String

    """
    
    """
    endpoint: EndpointInput!


    """
    
    API
    """
    llmModels: [String!]

    """
    Embedding
    API
    """
    embeddingModels: [String!]
}

input UpdateModelServiceInput {
    """"""
    name: String!
    """"""
    namespace: String!

    """"""
    labels: Map
    """"""
    annotations: Map
    """"""
    displayName: String
    """"""
    description: String

    """
     llm  embedding 
    :  "llm,embedding"
    """
    types: String

    """
     API 
     openai, zhipuai 
    """
    apiType: String

    """
    
    """
    endpoint: EndpointInput!

    """
    
    API
    """
    llmModels: [String!]

    """
    Embedding
    API
    """
    embeddingModels: [String!]
}

input ListModelServiceInput {
    """
    
    """
    keyword: String
    namespace: String!
    page: Int
    pageSize: Int

    """
    
    : 
        - 
        - llm LLM
        - embedding Embedding
        - llm,embedding LLMEmbedding
    """
    types: String

    """
    
    : 
        - 
        - worker 
        - 3rd_party 
    """
    providerType: String

    """
    
    : 
        - 
        - openai openai
        - zhipuai zhipuai
    """
    apiType: String
}

type ModelServiceMutation {
    createModelService(input: CreateModelServiceInput!): ModelService!
    updateModelService(input: UpdateModelServiceInput): ModelService!
    deleteModelService(input: DeleteCommonInput): Void
}

extend type Mutation {
    ModelService: ModelServiceMutation
}

type ModelServiceQuery {
    getModelService(name: String!, namespace: String!): ModelService!
    listModelServices(input: ListModelServiceInput): PaginatedResult!
    checkModelService(input: CreateModelServiceInput!): ModelService!
}

extend type Query {
    ModelService: ModelServiceQuery
}
`, BuiltIn: false},
	{Name: "../schema/rag.graphqls", Input: `type Parameter {
    key: String
    value: String
}
input ParameterInput {
    key: String
    value: String
}

type RAGMetric {
    metricKind: String
    parameters: [Parameter!]
    toleranceThreshbold: Int
}

input RAGMetricInput {
    metricKind: String
    parameters: [ParameterInput!]
    toleranceThreshbold: Int
}

type RAGDataset {
    source: TypedObjectReference
    files: [F!]
}

input RAGDatasetInput  {
    source: TypedObjectReferenceInput
    files: [String!]
}

"""RAG"""
type RAG {
    """
    
    : k8s
    """
    name: String!

    """
    : 
    : 
    """
    namespace: String!

    """"""
    labels: Map

    """"""
    annotations: Map

    """
    
    : webhook
    """
    creator: String

    """"""
    displayName: String

    """"""
    description: String

    """"""
    creationTimestamp: Time

    """, """
    completeTimestamp: Time

    """"""
    application: Application!

    """
    
    """
    datasets: [RAGDataset!]!
    """
    judgeLLM
    
    """
    judgeLLM: LLM!

    """
    
    """
    metrics: [RAGMetric!]!

    """
    pvc
    """
    storage: PersistentVolumeClaimSpec!

    """
    serviceAccount, default
    """
    serviceAccountName: String!

    """
    truefals
    """
    suspend: Boolean!
    """
    rag4
    complete() failed(), suspend(,), ing()
    """
    status: String!

    """
    
    "": 
    "init": pvc
    "download": 
    "generated": 
    "judge": 
    "upload": 
    "complete": 
    """
    phase: String
    """"""
    phaseMessage: String
}

input CreateRAGInput {
    name: String
    namespace: String!
    labels: Map
    annotations: Map
    creator: String
    displayName: String
    description: String
    application: TypedObjectReferenceInput!
    datasets: [RAGDatasetInput!]!
    judgeLLM: TypedObjectReferenceInput!
    metrics: [RAGMetricInput!]!
    storage: PersistentVolumeClaimSpecInput
    serviceAccountName: String
    suspend: Boolean
}
input UpdateRAGInput {
    name: String!
    namespace: String!
    labels: Map
    annotations: Map
    displayName: String
    description: String
    application: TypedObjectReferenceInput
    datasets: [RAGDatasetInput!]
    judgeLLM: TypedObjectReferenceInput
    metrics: [RAGMetricInput!]
    storage: PersistentVolumeClaimSpecInput
    serviceAccountName: String
    suspend: Boolean
}

input DuplicateRAGInput {
    name: String!
    namespace: String!
    displayName: String
}

input DeleteRAGInput {
    name: String!
    namespace: String!
    labelSelector: String
}

input ListRAGInput {
    appName: String!
    namespace: String!

    """"""
    status: String

    """displayName"""
    keyword: String

    """
    
    : 11
    """
    page: Int

    """
    
    : 10
    """
    pageSize: Int
}

type RAGMutation {
    createRAG(input: CreateRAGInput!): RAG!
    updateRAG(input: UpdateRAGInput!): RAG!
    deleteRAG(input: DeleteRAGInput!): Void
    duplicateRAG(input: DuplicateRAGInput!): RAG!
}

type RAGQuery {
    getRAG(name: String!, namespace: String!): RAG!
    listRAG(input: ListRAGInput!): PaginatedResult!
}

extend type Mutation {
    RAG: RAGMutation
}

extend type Query {
    RAG: RAGQuery
}
`, BuiltIn: false},
	{Name: "../schema/raycluster.graphqls", Input: `
"""RayCluster"""
type RayCluster {
    """
    Ray
    """
    index: Int!
    """
    
    : k8s
    """
    name: String!
    """
    Rayhead
    : k8s
    """
    headAddress: String
    """
    Raydashboard
    """
    dashboardHost: String
    """
    Raypython
    """
    pythonVersion: String
}


type RayClusterQuery {
    listRayClusters(input: ListCommonInput!): PaginatedResult!
}

extend type Query {
    RayCluster: RayClusterQuery
}`, BuiltIn: false},
	{Name: "../schema/versioned_dataset.graphqls", Input: `scalar Int64
"""
VersionedDataset


"""
type VersionedDataset {
    """
    id,CRmetadata.uid
    """
    id: String

    """, """
    name: String!

    """namespace"""
    namespace: String!

    """"""
    labels: Map

    """"""
    annotations: Map

    """"""
    creator: String

    """ metadat.name"""
    displayName: String

    """"""
    description: String

    """"""
    dataset: TypedObjectReference!

    """, """
    updateTimestamp: Time
    creationTimestamp: Time!

    """"""
    files(input: FileFilter): PaginatedResult!

    
    """"""
    version: String!

    """, 01"""
    released: Int!
    
    """, Processing'' Succeede Failed """
    syncStatus: String
    """"""
    syncMsg: String

    """processing process_failprocess_complete"""
    dataProcessStatus: String
    """"""
    dataProcessMsg: String
}

"""
File

"""
type F {
    "a/b/c.txtd.txt"
    path: String!

    """"""
    fileType: String!

    """"""
    count: String

    """"""
    time: Time

    """"""
    size: String

    """"""
    creationTimestamp: Time    
}

"""

"""
input FileFilter {
    """strings.Container(fileName, keyword)"""
    keyword: String

    """"""
    page: Int

    """"""
    pageSize: Int

    """, file, time"""
    sortBy: String
}

input FileGroup {
    """"""
    source: TypedObjectReferenceInput! 

    """ bucket"""
    paths: [String!]
}


input CreateVersionedDatasetInput {
    """CRk8s"""
    name: String!

    namespace: String!

    """dataset
    ()
    """
    datasetName: String!

    """"""
    labels: Map

    """"""
    annotations: Map

    """"""
    displayName: String
    
    """"""
    description: String

    """"""
    version: String!

    """010"""
    released: Int!

    """"""
    fileGrups: [FileGroup]

    """version"""
    inheritedFrom: String
}

input UpdateVersionedDatasetInput {
    """
    metadat.name, namenamespace
    namenamespac
    """
    name: String!
    namespace: String!

    """
    
    label
    : abc:def aa:bb,  abc:def, aa:bb
    """
    labels: Map

    """label"""
    annotations: Map
    
    displayName: String
    description: String

    """
    label
    
    """
    fileGroups: [FileGroup!]

    """"""
    released: Int
}


input DeleteVersionedDatasetInput {
    name: String
    namespace: String!
    labelSelector: String
    fieldSelector: String
}

input ListVersionedDatasetInput {
    name: String
    namespace: String
    displayName: String
    labelSelector: String
    fieldSelector: String

    """11"""
    page: Int

    """10"""
    pageSize: Int
    keyword: String
}

type VersionedDatasetQuery {
    getVersionedDataset(name: String!, namespace: String!): VersionedDataset!
    listVersionedDatasets(input: ListVersionedDatasetInput!): PaginatedResult! 
}
type VersionedDatasetMutation {
    createVersionedDataset(input: CreateVersionedDatasetInput!): VersionedDataset! 
    updateVersionedDataset(input: UpdateVersionedDatasetInput!): VersionedDataset!
    deleteVersionedDatasets(input: DeleteVersionedDatasetInput!): Void
}

extend type Query {
    VersionedDataset: VersionedDatasetQuery
}

extend type Mutation {
    VersionedDataset: VersionedDatasetMutation
}
`, BuiltIn: false},
	{Name: "../schema/worker.graphqls", Input: `"""worker(limits)"""
type Resources {
    cpu: String
    memory: String
    nvidiaGPU: String
}

""""""
input ResourcesInput {
    """
    cpu
    : 
    """
    cpu: String!
    """
    memory
    : 
    """
    memory: String!
    """
    gpu
    """
    nvidiaGPU: String
}

type NodeSelectorRequirement{
    key: String!
    operator: String!
    values: [String!]!
}

input NodeSelectorRequirementInput {
    key: String!
    operator: String!
    values: [String!]!
}

""""""
type Worker {
    """
    id,CRmetadata.uid
    """
    id: String

    """
    
    : k8s
    """
    name: String!

    """
    namespace(bucket)
    : 
    : 
    """
    namespace: String!

    """"""
    labels: Map
    """"""
    annotations: Map

    """
    
    : webhook
    """
    creator: String

    """"""
    displayName: String

    """"""
    description: String

    """"""
    creationTimestamp: Time
    """"""
    updateTimestamp: Time

    """
    Worker
    : 
    - "fastchat" : fastchat
    - "fastchat-vllm" : fastchatVLLM
    :  "fastchat"
    """
    type: String

    """
    worker
    : namespace
    : 
    """
    model: TypedObjectReference!

    """
    worker
    """
    modelTypes: String!

    """
    workerPod
    : 11
    : 0
    """
    replicas: String

    """
    worker
    : 
    """
    resources: Resources!

    """
    
    : 
      - Unknown: 
      - Pending:
      - Running: 
      - Error: 
    """
    status: String

    """"""
    message: String

    """api"""
    api: String

    """
    
    """
    matchExpressions: [NodeSelectorRequirement]

    """
    worker
    """
    additionalEnvs: Map
}

"""worker"""
input CreateWorkerInput{
    """"""
    name: String!
    """"""
    namespace: String!

    """"""
    displayName: String
    """"""
    description: String

    """
    Worker
    : 
    - "fastchat" : fastchat
    - "fastchat-vllm" : fastchatVLLM
    :  "fastchat"
    """
    type: String

    """
    worker
    : namespace
    : 
    """
    model: TypedObjectReferenceInput!

    """
    worker
    : 
    """
    resources: ResourcesInput!


    """
    
    """
    matchExpressions: [NodeSelectorRequirementInput]

    """
    worker
    """
    additionalEnvs: Map
}

""""""
input UpdateWorkerInput {
    """"""
    name: String!
    """"""
    namespace: String!

    """"""
    labels: Map
    """"""
    annotations: Map
    
    """"""
    displayName: String
    """"""
    description: String

    """
    Worker
    : 
    - "fastchat" : fastchat
    - "fastchat-vllm" : fastchatVLLM
    : type
    """
    type: String

    replicas: String

    """
    worker
    """
    resources: ResourcesInput

    """
    
    """
    matchExpressions: [NodeSelectorRequirementInput]

    """
    worker
    """
    additionalEnvs: Map
}

input ListWorkerInput {
    namespace: String!

    """
    : 
    """
    keyword: String

    """"""
    labelSelector: String
    """"""
    fieldSelector: String
    """
    
    : 11
    """
    page: Int

    """
    
    : 10
    """
    pageSize: Int

    """
    worker
    : embeddingllm: "embedding,llm"
    """
    modelTypes: String
}

type WorkerMutation {
    createWorker(input: CreateWorkerInput!): Worker!
    updateWorker(input: UpdateWorkerInput): Worker!
    deleteWorkers(input: DeleteCommonInput): Void
}

type WorkerQuery {
    getWorker(name: String!, namespace: String!): Worker!
    listWorkers(input: ListWorkerInput!): PaginatedResult!
}

extend type Mutation {
    Worker: WorkerMutation
}

extend type Query {
    Worker: WorkerQuery
}`, BuiltIn: false},
}
var parsedSchema = gqlparser.MustLoadSchema(sources...)

// endregion ************************** generated!.gotpl **************************

// region    ***************************** args.gotpl *****************************

func (ec *executionContext) field_ApplicationMutation_createApplication_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 CreateApplicationMetadataInput
	if tmp, ok := rawArgs["input"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
		arg0, err = ec.unmarshalNCreateApplicationMetadataInput2githubcomkubeagiarcadiaapiservergraphgeneratedCreateApplicationMetadataInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg0
	return args, nil
}

func (ec *executionContext) field_ApplicationMutation_deleteApplication_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 DeleteCommonInput
	if tmp, ok := rawArgs["input"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
		arg0, err = ec.unmarshalNDeleteCommonInput2githubcomkubeagiarcadiaapiservergraphgeneratedDeleteCommonInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg0
	return args, nil
}

func (ec *executionContext) field_ApplicationMutation_updateApplicationConfig_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 UpdateApplicationConfigInput
	if tmp, ok := rawArgs["input"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
		arg0, err = ec.unmarshalNUpdateApplicationConfigInput2githubcomkubeagiarcadiaapiservergraphgeneratedUpdateApplicationConfigInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg0
	return args, nil
}

func (ec *executionContext) field_ApplicationMutation_updateApplication_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 UpdateApplicationMetadataInput
	if tmp, ok := rawArgs["input"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
		arg0, err = ec.unmarshalNUpdateApplicationMetadataInput2githubcomkubeagiarcadiaapiservergraphgeneratedUpdateApplicationMetadataInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg0
	return args, nil
}

func (ec *executionContext) field_ApplicationQuery_getApplication_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["name"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["name"] = arg0
	var arg1 string
	if tmp, ok := rawArgs["namespace"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("namespace"))
		arg1, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["namespace"] = arg1
	return args, nil
}

func (ec *executionContext) field_ApplicationQuery_listApplicationMetadata_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 ListCommonInput
	if tmp, ok := rawArgs["input"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
		arg0, err = ec.unmarshalNListCommonInput2githubcomkubeagiarcadiaapiservergraphgeneratedListCommonInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg0
	return args, nil
}

func (ec *executionContext) field_DataProcessMutation_createDataProcessTask_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *AddDataProcessInput
	if tmp, ok := rawArgs["input"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
		arg0, err = ec.unmarshalOAddDataProcessInput2githubcomkubeagiarcadiaapiservergraphgeneratedAddDataProcessInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg0
	return args, nil
}

func (ec *executionContext) field_DataProcessMutation_deleteDataProcessTask_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *DeleteDataProcessInput
	if tmp, ok := rawArgs["input"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
		arg0, err = ec.unmarshalODeleteDataProcessInput2githubcomkubeagiarcadiaapiservergraphgeneratedDeleteDataProcessInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg0
	return args, nil
}

func (ec *executionContext) field_DataProcessQuery_allDataProcessListByCount_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *AllDataProcessListByCountInput
	if tmp, ok := rawArgs["input"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
		arg0, err = ec.unmarshalOAllDataProcessListByCountInput2githubcomkubeagiarcadiaapiservergraphgeneratedAllDataProcessListByCountInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg0
	return args, nil
}

func (ec *executionContext) field_DataProcessQuery_allDataProcessListByPage_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *AllDataProcessListByPageInput
	if tmp, ok := rawArgs["input"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
		arg0, err = ec.unmarshalOAllDataProcessListByPageInput2githubcomkubeagiarcadiaapiservergraphgeneratedAllDataProcessListByPageInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg0
	return args, nil
}

func (ec *executionContext) field_DataProcessQuery_checkDataProcessTaskName_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *CheckDataProcessTaskNameInput
	if tmp, ok := rawArgs["input"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
		arg0, err = ec.unmarshalOCheckDataProcessTaskNameInput2githubcomkubeagiarcadiaapiservergraphgeneratedCheckDataProcessTaskNameInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg0
	return args, nil
}

func (ec *executionContext) field_DataProcessQuery_dataProcessDetails_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *DataProcessDetailsInput
	if tmp, ok := rawArgs["input"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
		arg0, err = ec.unmarshalODataProcessDetailsInput2githubcomkubeagiarcadiaapiservergraphgeneratedDataProcessDetailsInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg0
	return args, nil
}

func (ec *executionContext) field_DataProcessQuery_dataProcessLogInfoByFileName_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *DataProcessFileLogInput
	if tmp, ok := rawArgs["input"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
		arg0, err = ec.unmarshalODataProcessFileLogInput2githubcomkubeagiarcadiaapiservergraphgeneratedDataProcessFileLogInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg0
	return args, nil
}

func (ec *executionContext) field_DataProcessQuery_dataProcessRetry_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *DataProcessRetryInput
	if tmp, ok := rawArgs["input"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
		arg0, err = ec.unmarshalODataProcessRetryInput2githubcomkubeagiarcadiaapiservergraphgeneratedDataProcessRetryInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg0
	return args, nil
}

func (ec *executionContext) field_DataProcessQuery_getLogInfo_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *DataProcessDetailsInput
	if tmp, ok := rawArgs["input"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
		arg0, err = ec.unmarshalODataProcessDetailsInput2githubcomkubeagiarcadiaapiservergraphgeneratedDataProcessDetailsInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg0
	return args, nil
}

func (ec *executionContext) field_DatasetMutation_createDataset_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *CreateDatasetInput
	if tmp, ok := rawArgs["input"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
		arg0, err = ec.unmarshalOCreateDatasetInput2githubcomkubeagiarcadiaapiservergraphgeneratedCreateDatasetInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg0
	return args, nil
}

func (ec *executionContext) field_DatasetMutation_deleteDatasets_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *DeleteCommonInput
	if tmp, ok := rawArgs["input"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
		arg0, err = ec.unmarshalODeleteCommonInput2githubcomkubeagiarcadiaapiservergraphgeneratedDeleteCommonInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg0
	return args, nil
}

func (ec *executionContext) field_DatasetMutation_updateDataset_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *UpdateDatasetInput
	if tmp, ok := rawArgs["input"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
		arg0, err = ec.unmarshalOUpdateDatasetInput2githubcomkubeagiarcadiaapiservergraphgeneratedUpdateDatasetInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg0
	return args, nil
}

func (ec *executionContext) field_DatasetQuery_getDataset_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["name"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["name"] = arg0
	var arg1 string
	if tmp, ok := rawArgs["namespace"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("namespace"))
		arg1, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["namespace"] = arg1
	return args, nil
}

func (ec *executionContext) field_DatasetQuery_listDatasets_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *ListDatasetInput
	if tmp, ok := rawArgs["input"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
		arg0, err = ec.unmarshalOListDatasetInput2githubcomkubeagiarcadiaapiservergraphgeneratedListDatasetInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg0
	return args, nil
}

func (ec *executionContext) field_Dataset_versions_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 ListVersionedDatasetInput
	if tmp, ok := rawArgs["input"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
		arg0, err = ec.unmarshalNListVersionedDatasetInput2githubcomkubeagiarcadiaapiservergraphgeneratedListVersionedDatasetInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg0
	return args, nil
}

func (ec *executionContext) field_DatasourceMutation_createDatasource_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 CreateDatasourceInput
	if tmp, ok := rawArgs["input"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
		arg0, err = ec.unmarshalNCreateDatasourceInput2githubcomkubeagiarcadiaapiservergraphgeneratedCreateDatasourceInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg0
	return args, nil
}

func (ec *executionContext) field_DatasourceMutation_deleteDatasources_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *DeleteCommonInput
	if tmp, ok := rawArgs["input"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
		arg0, err = ec.unmarshalODeleteCommonInput2githubcomkubeagiarcadiaapiservergraphgeneratedDeleteCommonInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg0
	return args, nil
}

func (ec *executionContext) field_DatasourceMutation_updateDatasource_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *UpdateDatasourceInput
	if tmp, ok := rawArgs["input"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
		arg0, err = ec.unmarshalOUpdateDatasourceInput2githubcomkubeagiarcadiaapiservergraphgeneratedUpdateDatasourceInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg0
	return args, nil
}

func (ec *executionContext) field_DatasourceQuery_checkDatasource_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 CreateDatasourceInput
	if tmp, ok := rawArgs["input"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
		arg0, err = ec.unmarshalNCreateDatasourceInput2githubcomkubeagiarcadiaapiservergraphgeneratedCreateDatasourceInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg0
	return args, nil
}

func (ec *executionContext) field_DatasourceQuery_getDatasource_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["name"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["name"] = arg0
	var arg1 string
	if tmp, ok := rawArgs["namespace"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("namespace"))
		arg1, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["namespace"] = arg1
	return args, nil
}

func (ec *executionContext) field_DatasourceQuery_listDatasources_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 ListCommonInput
	if tmp, ok := rawArgs["input"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
		arg0, err = ec.unmarshalNListCommonInput2githubcomkubeagiarcadiaapiservergraphgeneratedListCommonInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg0
	return args, nil
}

func (ec *executionContext) field_EmbedderMutation_createEmbedder_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 CreateEmbedderInput
	if tmp, ok := rawArgs["input"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
		arg0, err = ec.unmarshalNCreateEmbedderInput2githubcomkubeagiarcadiaapiservergraphgeneratedCreateEmbedderInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg0
	return args, nil
}

func (ec *executionContext) field_EmbedderMutation_deleteEmbedders_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *DeleteCommonInput
	if tmp, ok := rawArgs["input"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
		arg0, err = ec.unmarshalODeleteCommonInput2githubcomkubeagiarcadiaapiservergraphgeneratedDeleteCommonInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg0
	return args, nil
}

func (ec *executionContext) field_EmbedderMutation_updateEmbedder_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *UpdateEmbedderInput
	if tmp, ok := rawArgs["input"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
		arg0, err = ec.unmarshalOUpdateEmbedderInput2githubcomkubeagiarcadiaapiservergraphgeneratedUpdateEmbedderInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg0
	return args, nil
}

func (ec *executionContext) field_EmbedderQuery_getEmbedder_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["name"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["name"] = arg0
	var arg1 string
	if tmp, ok := rawArgs["namespace"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("namespace"))
		arg1, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["namespace"] = arg1
	return args, nil
}

func (ec *executionContext) field_EmbedderQuery_listEmbedders_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 ListCommonInput
	if tmp, ok := rawArgs["input"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
		arg0, err = ec.unmarshalNListCommonInput2githubcomkubeagiarcadiaapiservergraphgeneratedListCommonInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg0
	return args, nil
}

func (ec *executionContext) field_GPTQuery_getGPT_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["name"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["name"] = arg0
	return args, nil
}

func (ec *executionContext) field_GPTQuery_listGPT_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 ListGPTInput
	if tmp, ok := rawArgs["input"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
		arg0, err = ec.unmarshalNListGPTInput2githubcomkubeagiarcadiaapiservergraphgeneratedListGPTInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg0
	return args, nil
}

func (ec *executionContext) field_KnowledgeBaseMutation_createKnowledgeBase_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 CreateKnowledgeBaseInput
	if tmp, ok := rawArgs["input"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
		arg0, err = ec.unmarshalNCreateKnowledgeBaseInput2githubcomkubeagiarcadiaapiservergraphgeneratedCreateKnowledgeBaseInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg0
	return args, nil
}

func (ec *executionContext) field_KnowledgeBaseMutation_deleteKnowledgeBase_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *DeleteCommonInput
	if tmp, ok := rawArgs["input"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
		arg0, err = ec.unmarshalODeleteCommonInput2githubcomkubeagiarcadiaapiservergraphgeneratedDeleteCommonInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg0
	return args, nil
}

func (ec *executionContext) field_KnowledgeBaseMutation_updateKnowledgeBase_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *UpdateKnowledgeBaseInput
	if tmp, ok := rawArgs["input"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
		arg0, err = ec.unmarshalOUpdateKnowledgeBaseInput2githubcomkubeagiarcadiaapiservergraphgeneratedUpdateKnowledgeBaseInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg0
	return args, nil
}

func (ec *executionContext) field_KnowledgeBaseQuery_getKnowledgeBase_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["name"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["name"] = arg0
	var arg1 string
	if tmp, ok := rawArgs["namespace"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("namespace"))
		arg1, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["namespace"] = arg1
	return args, nil
}

func (ec *executionContext) field_KnowledgeBaseQuery_listKnowledgeBases_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 ListKnowledgeBaseInput
	if tmp, ok := rawArgs["input"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
		arg0, err = ec.unmarshalNListKnowledgeBaseInput2githubcomkubeagiarcadiaapiservergraphgeneratedListKnowledgeBaseInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg0
	return args, nil
}

func (ec *executionContext) field_LLMQuery_getLLM_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["name"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["name"] = arg0
	var arg1 string
	if tmp, ok := rawArgs["namespace"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("namespace"))
		arg1, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["namespace"] = arg1
	return args, nil
}

func (ec *executionContext) field_LLMQuery_listLLMs_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 ListCommonInput
	if tmp, ok := rawArgs["input"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
		arg0, err = ec.unmarshalNListCommonInput2githubcomkubeagiarcadiaapiservergraphgeneratedListCommonInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg0
	return args, nil
}

func (ec *executionContext) field_ModelMutation_createModel_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 CreateModelInput
	if tmp, ok := rawArgs["input"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
		arg0, err = ec.unmarshalNCreateModelInput2githubcomkubeagiarcadiaapiservergraphgeneratedCreateModelInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg0
	return args, nil
}

func (ec *executionContext) field_ModelMutation_deleteModels_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *DeleteCommonInput
	if tmp, ok := rawArgs["input"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
		arg0, err = ec.unmarshalODeleteCommonInput2githubcomkubeagiarcadiaapiservergraphgeneratedDeleteCommonInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg0
	return args, nil
}

func (ec *executionContext) field_ModelMutation_updateModel_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *UpdateModelInput
	if tmp, ok := rawArgs["input"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
		arg0, err = ec.unmarshalOUpdateModelInput2githubcomkubeagiarcadiaapiservergraphgeneratedUpdateModelInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg0
	return args, nil
}

func (ec *executionContext) field_ModelQuery_getModel_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["name"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["name"] = arg0
	var arg1 string
	if tmp, ok := rawArgs["namespace"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("namespace"))
		arg1, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["namespace"] = arg1
	return args, nil
}

func (ec *executionContext) field_ModelQuery_listModels_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 ListModelInput
	if tmp, ok := rawArgs["input"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
		arg0, err = ec.unmarshalNListModelInput2githubcomkubeagiarcadiaapiservergraphgeneratedListModelInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg0
	return args, nil
}

func (ec *executionContext) field_ModelServiceMutation_createModelService_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 CreateModelServiceInput
	if tmp, ok := rawArgs["input"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
		arg0, err = ec.unmarshalNCreateModelServiceInput2githubcomkubeagiarcadiaapiservergraphgeneratedCreateModelServiceInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg0
	return args, nil
}

func (ec *executionContext) field_ModelServiceMutation_deleteModelService_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *DeleteCommonInput
	if tmp, ok := rawArgs["input"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
		arg0, err = ec.unmarshalODeleteCommonInput2githubcomkubeagiarcadiaapiservergraphgeneratedDeleteCommonInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg0
	return args, nil
}

func (ec *executionContext) field_ModelServiceMutation_updateModelService_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *UpdateModelServiceInput
	if tmp, ok := rawArgs["input"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
		arg0, err = ec.unmarshalOUpdateModelServiceInput2githubcomkubeagiarcadiaapiservergraphgeneratedUpdateModelServiceInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg0
	return args, nil
}

func (ec *executionContext) field_ModelServiceQuery_checkModelService_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 CreateModelServiceInput
	if tmp, ok := rawArgs["input"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
		arg0, err = ec.unmarshalNCreateModelServiceInput2githubcomkubeagiarcadiaapiservergraphgeneratedCreateModelServiceInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg0
	return args, nil
}

func (ec *executionContext) field_ModelServiceQuery_getModelService_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["name"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["name"] = arg0
	var arg1 string
	if tmp, ok := rawArgs["namespace"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("namespace"))
		arg1, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["namespace"] = arg1
	return args, nil
}

func (ec *executionContext) field_ModelServiceQuery_listModelServices_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *ListModelServiceInput
	if tmp, ok := rawArgs["input"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
		arg0, err = ec.unmarshalOListModelServiceInput2githubcomkubeagiarcadiaapiservergraphgeneratedListModelServiceInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg0
	return args, nil
}

func (ec *executionContext) field_Model_files_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *FileFilter
	if tmp, ok := rawArgs["input"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
		arg0, err = ec.unmarshalOFileFilter2githubcomkubeagiarcadiaapiservergraphgeneratedFileFilter(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_hello_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["name"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["name"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query___type_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["name"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["name"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_hello_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["name"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["name"] = arg0
	return args, nil
}

func (ec *executionContext) field_RAGMutation_createRAG_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 CreateRAGInput
	if tmp, ok := rawArgs["input"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
		arg0, err = ec.unmarshalNCreateRAGInput2githubcomkubeagiarcadiaapiservergraphgeneratedCreateRAGInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg0
	return args, nil
}

func (ec *executionContext) field_RAGMutation_deleteRAG_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 DeleteRAGInput
	if tmp, ok := rawArgs["input"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
		arg0, err = ec.unmarshalNDeleteRAGInput2githubcomkubeagiarcadiaapiservergraphgeneratedDeleteRAGInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg0
	return args, nil
}

func (ec *executionContext) field_RAGMutation_duplicateRAG_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 DuplicateRAGInput
	if tmp, ok := rawArgs["input"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
		arg0, err = ec.unmarshalNDuplicateRAGInput2githubcomkubeagiarcadiaapiservergraphgeneratedDuplicateRAGInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg0
	return args, nil
}

func (ec *executionContext) field_RAGMutation_updateRAG_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 UpdateRAGInput
	if tmp, ok := rawArgs["input"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
		arg0, err = ec.unmarshalNUpdateRAGInput2githubcomkubeagiarcadiaapiservergraphgeneratedUpdateRAGInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg0
	return args, nil
}

func (ec *executionContext) field_RAGQuery_getRAG_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["name"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["name"] = arg0
	var arg1 string
	if tmp, ok := rawArgs["namespace"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("namespace"))
		arg1, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["namespace"] = arg1
	return args, nil
}

func (ec *executionContext) field_RAGQuery_listRAG_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 ListRAGInput
	if tmp, ok := rawArgs["input"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
		arg0, err = ec.unmarshalNListRAGInput2githubcomkubeagiarcadiaapiservergraphgeneratedListRAGInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg0
	return args, nil
}

func (ec *executionContext) field_RayClusterQuery_listRayClusters_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 ListCommonInput
	if tmp, ok := rawArgs["input"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
		arg0, err = ec.unmarshalNListCommonInput2githubcomkubeagiarcadiaapiservergraphgeneratedListCommonInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg0
	return args, nil
}

func (ec *executionContext) field_VersionedDatasetMutation_createVersionedDataset_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 CreateVersionedDatasetInput
	if tmp, ok := rawArgs["input"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
		arg0, err = ec.unmarshalNCreateVersionedDatasetInput2githubcomkubeagiarcadiaapiservergraphgeneratedCreateVersionedDatasetInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg0
	return args, nil
}

func (ec *executionContext) field_VersionedDatasetMutation_deleteVersionedDatasets_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 DeleteVersionedDatasetInput
	if tmp, ok := rawArgs["input"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
		arg0, err = ec.unmarshalNDeleteVersionedDatasetInput2githubcomkubeagiarcadiaapiservergraphgeneratedDeleteVersionedDatasetInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg0
	return args, nil
}

func (ec *executionContext) field_VersionedDatasetMutation_updateVersionedDataset_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 UpdateVersionedDatasetInput
	if tmp, ok := rawArgs["input"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
		arg0, err = ec.unmarshalNUpdateVersionedDatasetInput2githubcomkubeagiarcadiaapiservergraphgeneratedUpdateVersionedDatasetInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg0
	return args, nil
}

func (ec *executionContext) field_VersionedDatasetQuery_getVersionedDataset_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["name"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["name"] = arg0
	var arg1 string
	if tmp, ok := rawArgs["namespace"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("namespace"))
		arg1, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["namespace"] = arg1
	return args, nil
}

func (ec *executionContext) field_VersionedDatasetQuery_listVersionedDatasets_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 ListVersionedDatasetInput
	if tmp, ok := rawArgs["input"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
		arg0, err = ec.unmarshalNListVersionedDatasetInput2githubcomkubeagiarcadiaapiservergraphgeneratedListVersionedDatasetInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg0
	return args, nil
}

func (ec *executionContext) field_VersionedDataset_files_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *FileFilter
	if tmp, ok := rawArgs["input"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
		arg0, err = ec.unmarshalOFileFilter2githubcomkubeagiarcadiaapiservergraphgeneratedFileFilter(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg0
	return args, nil
}

func (ec *executionContext) field_WorkerMutation_createWorker_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 CreateWorkerInput
	if tmp, ok := rawArgs["input"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
		arg0, err = ec.unmarshalNCreateWorkerInput2githubcomkubeagiarcadiaapiservergraphgeneratedCreateWorkerInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg0
	return args, nil
}

func (ec *executionContext) field_WorkerMutation_deleteWorkers_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *DeleteCommonInput
	if tmp, ok := rawArgs["input"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
		arg0, err = ec.unmarshalODeleteCommonInput2githubcomkubeagiarcadiaapiservergraphgeneratedDeleteCommonInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg0
	return args, nil
}

func (ec *executionContext) field_WorkerMutation_updateWorker_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *UpdateWorkerInput
	if tmp, ok := rawArgs["input"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
		arg0, err = ec.unmarshalOUpdateWorkerInput2githubcomkubeagiarcadiaapiservergraphgeneratedUpdateWorkerInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg0
	return args, nil
}

func (ec *executionContext) field_WorkerQuery_getWorker_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["name"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["name"] = arg0
	var arg1 string
	if tmp, ok := rawArgs["namespace"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("namespace"))
		arg1, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["namespace"] = arg1
	return args, nil
}

func (ec *executionContext) field_WorkerQuery_listWorkers_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 ListWorkerInput
	if tmp, ok := rawArgs["input"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
		arg0, err = ec.unmarshalNListWorkerInput2githubcomkubeagiarcadiaapiservergraphgeneratedListWorkerInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg0
	return args, nil
}

func (ec *executionContext) field___Type_enumValues_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 bool
	if tmp, ok := rawArgs["includeDeprecated"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("includeDeprecated"))
		arg0, err = ec.unmarshalOBoolean2bool(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["includeDeprecated"] = arg0
	return args, nil
}

func (ec *executionContext) field___Type_fields_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 bool
	if tmp, ok := rawArgs["includeDeprecated"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("includeDeprecated"))
		arg0, err = ec.unmarshalOBoolean2bool(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["includeDeprecated"] = arg0
	return args, nil
}

// endregion ***************************** args.gotpl *****************************

// region    ************************** directives.gotpl **************************

// endregion ************************** directives.gotpl **************************

// region    **************************** field.gotpl *****************************

func (ec *executionContext) _Application_metadata(ctx context.Context, field graphql.CollectedField, obj *Application) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Application_metadata(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Metadata, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*ApplicationMetadata)
	fc.Result = res
	return ec.marshalOApplicationMetadata2githubcomkubeagiarcadiaapiservergraphgeneratedApplicationMetadata(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Application_metadata(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Application",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext_ApplicationMetadata_name(ctx, field)
			case "namespace":
				return ec.fieldContext_ApplicationMetadata_namespace(ctx, field)
			case "id":
				return ec.fieldContext_ApplicationMetadata_id(ctx, field)
			case "labels":
				return ec.fieldContext_ApplicationMetadata_labels(ctx, field)
			case "annotations":
				return ec.fieldContext_ApplicationMetadata_annotations(ctx, field)
			case "displayName":
				return ec.fieldContext_ApplicationMetadata_displayName(ctx, field)
			case "description":
				return ec.fieldContext_ApplicationMetadata_description(ctx, field)
			case "icon":
				return ec.fieldContext_ApplicationMetadata_icon(ctx, field)
			case "creator":
				return ec.fieldContext_ApplicationMetadata_creator(ctx, field)
			case "creationTimestamp":
				return ec.fieldContext_ApplicationMetadata_creationTimestamp(ctx, field)
			case "updateTimestamp":
				return ec.fieldContext_ApplicationMetadata_updateTimestamp(ctx, field)
			case "isPublic":
				return ec.fieldContext_ApplicationMetadata_isPublic(ctx, field)
			case "status":
				return ec.fieldContext_ApplicationMetadata_status(ctx, field)
			case "category":
				return ec.fieldContext_ApplicationMetadata_category(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ApplicationMetadata", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Application_prologue(ctx context.Context, field graphql.CollectedField, obj *Application) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Application_prologue(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Prologue, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Application_prologue(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Application",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Application_model(ctx context.Context, field graphql.CollectedField, obj *Application) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Application_model(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Model, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Application_model(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Application",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Application_llm(ctx context.Context, field graphql.CollectedField, obj *Application) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Application_llm(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Llm, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Application_llm(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Application",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Application_temperature(ctx context.Context, field graphql.CollectedField, obj *Application) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Application_temperature(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Temperature, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*float64)
	fc.Result = res
	return ec.marshalOFloat2float64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Application_temperature(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Application",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Float does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Application_maxLength(ctx context.Context, field graphql.CollectedField, obj *Application) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Application_maxLength(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MaxLength, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalOInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Application_maxLength(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Application",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Application_maxTokens(ctx context.Context, field graphql.CollectedField, obj *Application) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Application_maxTokens(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MaxTokens, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalOInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Application_maxTokens(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Application",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Application_conversionWindowSize(ctx context.Context, field graphql.CollectedField, obj *Application) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Application_conversionWindowSize(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ConversionWindowSize, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalOInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Application_conversionWindowSize(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Application",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Application_knowledgebase(ctx context.Context, field graphql.CollectedField, obj *Application) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Application_knowledgebase(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Knowledgebase, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Application_knowledgebase(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Application",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Application_scoreThreshold(ctx context.Context, field graphql.CollectedField, obj *Application) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Application_scoreThreshold(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ScoreThreshold, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*float64)
	fc.Result = res
	return ec.marshalOFloat2float64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Application_scoreThreshold(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Application",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Float does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Application_numDocuments(ctx context.Context, field graphql.CollectedField, obj *Application) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Application_numDocuments(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.NumDocuments, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalOInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Application_numDocuments(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Application",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Application_docNullReturn(ctx context.Context, field graphql.CollectedField, obj *Application) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Application_docNullReturn(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DocNullReturn, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Application_docNullReturn(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Application",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Application_userPrompt(ctx context.Context, field graphql.CollectedField, obj *Application) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Application_userPrompt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UserPrompt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Application_userPrompt(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Application",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Application_showRespInfo(ctx context.Context, field graphql.CollectedField, obj *Application) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Application_showRespInfo(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ShowRespInfo, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*bool)
	fc.Result = res
	return ec.marshalOBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Application_showRespInfo(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Application",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Application_showRetrievalInfo(ctx context.Context, field graphql.CollectedField, obj *Application) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Application_showRetrievalInfo(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ShowRetrievalInfo, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*bool)
	fc.Result = res
	return ec.marshalOBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Application_showRetrievalInfo(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Application",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Application_showNextGuide(ctx context.Context, field graphql.CollectedField, obj *Application) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Application_showNextGuide(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ShowNextGuide, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*bool)
	fc.Result = res
	return ec.marshalOBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Application_showNextGuide(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Application",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Application_tools(ctx context.Context, field graphql.CollectedField, obj *Application) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Application_tools(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Tools, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*Tool)
	fc.Result = res
	return ec.marshalOTool2githubcomkubeagiarcadiaapiservergraphgeneratedTool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Application_tools(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Application",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext_Tool_name(ctx, field)
			case "params":
				return ec.fieldContext_Tool_params(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Tool", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ApplicationMetadata_name(ctx context.Context, field graphql.CollectedField, obj *ApplicationMetadata) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ApplicationMetadata_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ApplicationMetadata_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ApplicationMetadata",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ApplicationMetadata_namespace(ctx context.Context, field graphql.CollectedField, obj *ApplicationMetadata) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ApplicationMetadata_namespace(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Namespace, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ApplicationMetadata_namespace(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ApplicationMetadata",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ApplicationMetadata_id(ctx context.Context, field graphql.CollectedField, obj *ApplicationMetadata) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ApplicationMetadata_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ApplicationMetadata_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ApplicationMetadata",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ApplicationMetadata_labels(ctx context.Context, field graphql.CollectedField, obj *ApplicationMetadata) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ApplicationMetadata_labels(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Labels, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(map[string]interface{})
	fc.Result = res
	return ec.marshalOMap2map(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ApplicationMetadata_labels(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ApplicationMetadata",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Map does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ApplicationMetadata_annotations(ctx context.Context, field graphql.CollectedField, obj *ApplicationMetadata) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ApplicationMetadata_annotations(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Annotations, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(map[string]interface{})
	fc.Result = res
	return ec.marshalOMap2map(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ApplicationMetadata_annotations(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ApplicationMetadata",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Map does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ApplicationMetadata_displayName(ctx context.Context, field graphql.CollectedField, obj *ApplicationMetadata) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ApplicationMetadata_displayName(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DisplayName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ApplicationMetadata_displayName(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ApplicationMetadata",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ApplicationMetadata_description(ctx context.Context, field graphql.CollectedField, obj *ApplicationMetadata) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ApplicationMetadata_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ApplicationMetadata_description(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ApplicationMetadata",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ApplicationMetadata_icon(ctx context.Context, field graphql.CollectedField, obj *ApplicationMetadata) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ApplicationMetadata_icon(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Icon, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ApplicationMetadata_icon(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ApplicationMetadata",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ApplicationMetadata_creator(ctx context.Context, field graphql.CollectedField, obj *ApplicationMetadata) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ApplicationMetadata_creator(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Creator, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ApplicationMetadata_creator(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ApplicationMetadata",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ApplicationMetadata_creationTimestamp(ctx context.Context, field graphql.CollectedField, obj *ApplicationMetadata) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ApplicationMetadata_creationTimestamp(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CreationTimestamp, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*time.Time)
	fc.Result = res
	return ec.marshalOTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ApplicationMetadata_creationTimestamp(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ApplicationMetadata",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ApplicationMetadata_updateTimestamp(ctx context.Context, field graphql.CollectedField, obj *ApplicationMetadata) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ApplicationMetadata_updateTimestamp(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UpdateTimestamp, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*time.Time)
	fc.Result = res
	return ec.marshalOTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ApplicationMetadata_updateTimestamp(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ApplicationMetadata",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ApplicationMetadata_isPublic(ctx context.Context, field graphql.CollectedField, obj *ApplicationMetadata) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ApplicationMetadata_isPublic(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsPublic, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*bool)
	fc.Result = res
	return ec.marshalOBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ApplicationMetadata_isPublic(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ApplicationMetadata",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ApplicationMetadata_status(ctx context.Context, field graphql.CollectedField, obj *ApplicationMetadata) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ApplicationMetadata_status(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Status, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ApplicationMetadata_status(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ApplicationMetadata",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ApplicationMetadata_category(ctx context.Context, field graphql.CollectedField, obj *ApplicationMetadata) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ApplicationMetadata_category(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Category, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ApplicationMetadata_category(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ApplicationMetadata",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ApplicationMutation_createApplication(ctx context.Context, field graphql.CollectedField, obj *ApplicationMutation) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ApplicationMutation_createApplication(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.ApplicationMutation().CreateApplication(rctx, obj, fc.Args["input"].(CreateApplicationMetadataInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*ApplicationMetadata)
	fc.Result = res
	return ec.marshalNApplicationMetadata2githubcomkubeagiarcadiaapiservergraphgeneratedApplicationMetadata(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ApplicationMutation_createApplication(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ApplicationMutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext_ApplicationMetadata_name(ctx, field)
			case "namespace":
				return ec.fieldContext_ApplicationMetadata_namespace(ctx, field)
			case "id":
				return ec.fieldContext_ApplicationMetadata_id(ctx, field)
			case "labels":
				return ec.fieldContext_ApplicationMetadata_labels(ctx, field)
			case "annotations":
				return ec.fieldContext_ApplicationMetadata_annotations(ctx, field)
			case "displayName":
				return ec.fieldContext_ApplicationMetadata_displayName(ctx, field)
			case "description":
				return ec.fieldContext_ApplicationMetadata_description(ctx, field)
			case "icon":
				return ec.fieldContext_ApplicationMetadata_icon(ctx, field)
			case "creator":
				return ec.fieldContext_ApplicationMetadata_creator(ctx, field)
			case "creationTimestamp":
				return ec.fieldContext_ApplicationMetadata_creationTimestamp(ctx, field)
			case "updateTimestamp":
				return ec.fieldContext_ApplicationMetadata_updateTimestamp(ctx, field)
			case "isPublic":
				return ec.fieldContext_ApplicationMetadata_isPublic(ctx, field)
			case "status":
				return ec.fieldContext_ApplicationMetadata_status(ctx, field)
			case "category":
				return ec.fieldContext_ApplicationMetadata_category(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ApplicationMetadata", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_ApplicationMutation_createApplication_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _ApplicationMutation_updateApplication(ctx context.Context, field graphql.CollectedField, obj *ApplicationMutation) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ApplicationMutation_updateApplication(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.ApplicationMutation().UpdateApplication(rctx, obj, fc.Args["input"].(UpdateApplicationMetadataInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*ApplicationMetadata)
	fc.Result = res
	return ec.marshalNApplicationMetadata2githubcomkubeagiarcadiaapiservergraphgeneratedApplicationMetadata(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ApplicationMutation_updateApplication(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ApplicationMutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext_ApplicationMetadata_name(ctx, field)
			case "namespace":
				return ec.fieldContext_ApplicationMetadata_namespace(ctx, field)
			case "id":
				return ec.fieldContext_ApplicationMetadata_id(ctx, field)
			case "labels":
				return ec.fieldContext_ApplicationMetadata_labels(ctx, field)
			case "annotations":
				return ec.fieldContext_ApplicationMetadata_annotations(ctx, field)
			case "displayName":
				return ec.fieldContext_ApplicationMetadata_displayName(ctx, field)
			case "description":
				return ec.fieldContext_ApplicationMetadata_description(ctx, field)
			case "icon":
				return ec.fieldContext_ApplicationMetadata_icon(ctx, field)
			case "creator":
				return ec.fieldContext_ApplicationMetadata_creator(ctx, field)
			case "creationTimestamp":
				return ec.fieldContext_ApplicationMetadata_creationTimestamp(ctx, field)
			case "updateTimestamp":
				return ec.fieldContext_ApplicationMetadata_updateTimestamp(ctx, field)
			case "isPublic":
				return ec.fieldContext_ApplicationMetadata_isPublic(ctx, field)
			case "status":
				return ec.fieldContext_ApplicationMetadata_status(ctx, field)
			case "category":
				return ec.fieldContext_ApplicationMetadata_category(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ApplicationMetadata", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_ApplicationMutation_updateApplication_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _ApplicationMutation_deleteApplication(ctx context.Context, field graphql.CollectedField, obj *ApplicationMutation) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ApplicationMutation_deleteApplication(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.ApplicationMutation().DeleteApplication(rctx, obj, fc.Args["input"].(DeleteCommonInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOVoid2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ApplicationMutation_deleteApplication(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ApplicationMutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Void does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_ApplicationMutation_deleteApplication_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _ApplicationMutation_updateApplicationConfig(ctx context.Context, field graphql.CollectedField, obj *ApplicationMutation) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ApplicationMutation_updateApplicationConfig(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.ApplicationMutation().UpdateApplicationConfig(rctx, obj, fc.Args["input"].(UpdateApplicationConfigInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*Application)
	fc.Result = res
	return ec.marshalNApplication2githubcomkubeagiarcadiaapiservergraphgeneratedApplication(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ApplicationMutation_updateApplicationConfig(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ApplicationMutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "metadata":
				return ec.fieldContext_Application_metadata(ctx, field)
			case "prologue":
				return ec.fieldContext_Application_prologue(ctx, field)
			case "model":
				return ec.fieldContext_Application_model(ctx, field)
			case "llm":
				return ec.fieldContext_Application_llm(ctx, field)
			case "temperature":
				return ec.fieldContext_Application_temperature(ctx, field)
			case "maxLength":
				return ec.fieldContext_Application_maxLength(ctx, field)
			case "maxTokens":
				return ec.fieldContext_Application_maxTokens(ctx, field)
			case "conversionWindowSize":
				return ec.fieldContext_Application_conversionWindowSize(ctx, field)
			case "knowledgebase":
				return ec.fieldContext_Application_knowledgebase(ctx, field)
			case "scoreThreshold":
				return ec.fieldContext_Application_scoreThreshold(ctx, field)
			case "numDocuments":
				return ec.fieldContext_Application_numDocuments(ctx, field)
			case "docNullReturn":
				return ec.fieldContext_Application_docNullReturn(ctx, field)
			case "userPrompt":
				return ec.fieldContext_Application_userPrompt(ctx, field)
			case "showRespInfo":
				return ec.fieldContext_Application_showRespInfo(ctx, field)
			case "showRetrievalInfo":
				return ec.fieldContext_Application_showRetrievalInfo(ctx, field)
			case "showNextGuide":
				return ec.fieldContext_Application_showNextGuide(ctx, field)
			case "tools":
				return ec.fieldContext_Application_tools(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Application", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_ApplicationMutation_updateApplicationConfig_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _ApplicationQuery_getApplication(ctx context.Context, field graphql.CollectedField, obj *ApplicationQuery) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ApplicationQuery_getApplication(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.ApplicationQuery().GetApplication(rctx, obj, fc.Args["name"].(string), fc.Args["namespace"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*Application)
	fc.Result = res
	return ec.marshalNApplication2githubcomkubeagiarcadiaapiservergraphgeneratedApplication(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ApplicationQuery_getApplication(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ApplicationQuery",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "metadata":
				return ec.fieldContext_Application_metadata(ctx, field)
			case "prologue":
				return ec.fieldContext_Application_prologue(ctx, field)
			case "model":
				return ec.fieldContext_Application_model(ctx, field)
			case "llm":
				return ec.fieldContext_Application_llm(ctx, field)
			case "temperature":
				return ec.fieldContext_Application_temperature(ctx, field)
			case "maxLength":
				return ec.fieldContext_Application_maxLength(ctx, field)
			case "maxTokens":
				return ec.fieldContext_Application_maxTokens(ctx, field)
			case "conversionWindowSize":
				return ec.fieldContext_Application_conversionWindowSize(ctx, field)
			case "knowledgebase":
				return ec.fieldContext_Application_knowledgebase(ctx, field)
			case "scoreThreshold":
				return ec.fieldContext_Application_scoreThreshold(ctx, field)
			case "numDocuments":
				return ec.fieldContext_Application_numDocuments(ctx, field)
			case "docNullReturn":
				return ec.fieldContext_Application_docNullReturn(ctx, field)
			case "userPrompt":
				return ec.fieldContext_Application_userPrompt(ctx, field)
			case "showRespInfo":
				return ec.fieldContext_Application_showRespInfo(ctx, field)
			case "showRetrievalInfo":
				return ec.fieldContext_Application_showRetrievalInfo(ctx, field)
			case "showNextGuide":
				return ec.fieldContext_Application_showNextGuide(ctx, field)
			case "tools":
				return ec.fieldContext_Application_tools(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Application", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_ApplicationQuery_getApplication_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _ApplicationQuery_listApplicationMetadata(ctx context.Context, field graphql.CollectedField, obj *ApplicationQuery) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ApplicationQuery_listApplicationMetadata(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.ApplicationQuery().ListApplicationMetadata(rctx, obj, fc.Args["input"].(ListCommonInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*PaginatedResult)
	fc.Result = res
	return ec.marshalNPaginatedResult2githubcomkubeagiarcadiaapiservergraphgeneratedPaginatedResult(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ApplicationQuery_listApplicationMetadata(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ApplicationQuery",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "hasNextPage":
				return ec.fieldContext_PaginatedResult_hasNextPage(ctx, field)
			case "nodes":
				return ec.fieldContext_PaginatedResult_nodes(ctx, field)
			case "page":
				return ec.fieldContext_PaginatedResult_page(ctx, field)
			case "pageSize":
				return ec.fieldContext_PaginatedResult_pageSize(ctx, field)
			case "totalCount":
				return ec.fieldContext_PaginatedResult_totalCount(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type PaginatedResult", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_ApplicationQuery_listApplicationMetadata_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _CountDataProcessItem_status(ctx context.Context, field graphql.CollectedField, obj *CountDataProcessItem) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CountDataProcessItem_status(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Status, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CountDataProcessItem_status(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CountDataProcessItem",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _CountDataProcessItem_data(ctx context.Context, field graphql.CollectedField, obj *CountDataProcessItem) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CountDataProcessItem_data(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Data, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CountDataProcessItem_data(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CountDataProcessItem",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _CountDataProcessItem_message(ctx context.Context, field graphql.CollectedField, obj *CountDataProcessItem) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CountDataProcessItem_message(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Message, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CountDataProcessItem_message(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CountDataProcessItem",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _DataProcessConfig_name(ctx context.Context, field graphql.CollectedField, obj *DataProcessConfig) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DataProcessConfig_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DataProcessConfig_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DataProcessConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _DataProcessConfig_description(ctx context.Context, field graphql.CollectedField, obj *DataProcessConfig) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DataProcessConfig_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DataProcessConfig_description(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DataProcessConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _DataProcessConfig_file_num(ctx context.Context, field graphql.CollectedField, obj *DataProcessConfig) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DataProcessConfig_file_num(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.FileNum, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DataProcessConfig_file_num(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DataProcessConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _DataProcessConfig_status(ctx context.Context, field graphql.CollectedField, obj *DataProcessConfig) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DataProcessConfig_status(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Status, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DataProcessConfig_status(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DataProcessConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _DataProcessConfig_children(ctx context.Context, field graphql.CollectedField, obj *DataProcessConfig) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DataProcessConfig_children(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Children, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*DataProcessConfigChildren)
	fc.Result = res
	return ec.marshalODataProcessConfigChildren2githubcomkubeagiarcadiaapiservergraphgeneratedDataProcessConfigChildren(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DataProcessConfig_children(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DataProcessConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext_DataProcessConfigChildren_name(ctx, field)
			case "enable":
				return ec.fieldContext_DataProcessConfigChildren_enable(ctx, field)
			case "zh_name":
				return ec.fieldContext_DataProcessConfigChildren_zh_name(ctx, field)
			case "description":
				return ec.fieldContext_DataProcessConfigChildren_description(ctx, field)
			case "chunk_size":
				return ec.fieldContext_DataProcessConfigChildren_chunk_size(ctx, field)
			case "chunk_overlap":
				return ec.fieldContext_DataProcessConfigChildren_chunk_overlap(ctx, field)
			case "llm_config":
				return ec.fieldContext_DataProcessConfigChildren_llm_config(ctx, field)
			case "preview":
				return ec.fieldContext_DataProcessConfigChildren_preview(ctx, field)
			case "file_progress":
				return ec.fieldContext_DataProcessConfigChildren_file_progress(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type DataProcessConfigChildren", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _DataProcessConfigChildren_name(ctx context.Context, field graphql.CollectedField, obj *DataProcessConfigChildren) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DataProcessConfigChildren_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DataProcessConfigChildren_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DataProcessConfigChildren",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _DataProcessConfigChildren_enable(ctx context.Context, field graphql.CollectedField, obj *DataProcessConfigChildren) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DataProcessConfigChildren_enable(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Enable, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DataProcessConfigChildren_enable(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DataProcessConfigChildren",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _DataProcessConfigChildren_zh_name(ctx context.Context, field graphql.CollectedField, obj *DataProcessConfigChildren) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DataProcessConfigChildren_zh_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ZhName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DataProcessConfigChildren_zh_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DataProcessConfigChildren",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _DataProcessConfigChildren_description(ctx context.Context, field graphql.CollectedField, obj *DataProcessConfigChildren) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DataProcessConfigChildren_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DataProcessConfigChildren_description(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DataProcessConfigChildren",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _DataProcessConfigChildren_chunk_size(ctx context.Context, field graphql.CollectedField, obj *DataProcessConfigChildren) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DataProcessConfigChildren_chunk_size(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ChunkSize, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalOInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DataProcessConfigChildren_chunk_size(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DataProcessConfigChildren",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _DataProcessConfigChildren_chunk_overlap(ctx context.Context, field graphql.CollectedField, obj *DataProcessConfigChildren) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DataProcessConfigChildren_chunk_overlap(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ChunkOverlap, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalOInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DataProcessConfigChildren_chunk_overlap(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DataProcessConfigChildren",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _DataProcessConfigChildren_llm_config(ctx context.Context, field graphql.CollectedField, obj *DataProcessConfigChildren) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DataProcessConfigChildren_llm_config(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.LlmConfig, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*LLMConfig)
	fc.Result = res
	return ec.marshalOLLMConfig2githubcomkubeagiarcadiaapiservergraphgeneratedLLMConfig(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DataProcessConfigChildren_llm_config(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DataProcessConfigChildren",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext_LLMConfig_name(ctx, field)
			case "namespace":
				return ec.fieldContext_LLMConfig_namespace(ctx, field)
			case "model":
				return ec.fieldContext_LLMConfig_model(ctx, field)
			case "temperature":
				return ec.fieldContext_LLMConfig_temperature(ctx, field)
			case "top_p":
				return ec.fieldContext_LLMConfig_top_p(ctx, field)
			case "max_tokens":
				return ec.fieldContext_LLMConfig_max_tokens(ctx, field)
			case "prompt_template":
				return ec.fieldContext_LLMConfig_prompt_template(ctx, field)
			case "provider":
				return ec.fieldContext_LLMConfig_provider(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type LLMConfig", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _DataProcessConfigChildren_preview(ctx context.Context, field graphql.CollectedField, obj *DataProcessConfigChildren) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DataProcessConfigChildren_preview(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Preview, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*DataProcessConfigpreView)
	fc.Result = res
	return ec.marshalODataProcessConfigpreView2githubcomkubeagiarcadiaapiservergraphgeneratedDataProcessConfigpreView(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DataProcessConfigChildren_preview(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DataProcessConfigChildren",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "file_name":
				return ec.fieldContext_DataProcessConfigpreView_file_name(ctx, field)
			case "content":
				return ec.fieldContext_DataProcessConfigpreView_content(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type DataProcessConfigpreView", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _DataProcessConfigChildren_file_progress(ctx context.Context, field graphql.CollectedField, obj *DataProcessConfigChildren) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DataProcessConfigChildren_file_progress(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.FileProgress, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*DataProcessConfigpreFileProgress)
	fc.Result = res
	return ec.marshalODataProcessConfigpreFileProgress2githubcomkubeagiarcadiaapiservergraphgeneratedDataProcessConfigpreFileProgress(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DataProcessConfigChildren_file_progress(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DataProcessConfigChildren",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_DataProcessConfigpreFileProgress_id(ctx, field)
			case "file_name":
				return ec.fieldContext_DataProcessConfigpreFileProgress_file_name(ctx, field)
			case "status":
				return ec.fieldContext_DataProcessConfigpreFileProgress_status(ctx, field)
			case "start_time":
				return ec.fieldContext_DataProcessConfigpreFileProgress_start_time(ctx, field)
			case "end_time":
				return ec.fieldContext_DataProcessConfigpreFileProgress_end_time(ctx, field)
			case "progress":
				return ec.fieldContext_DataProcessConfigpreFileProgress_progress(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type DataProcessConfigpreFileProgress", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _DataProcessConfigInfo_type(ctx context.Context, field graphql.CollectedField, obj *DataProcessConfigInfo) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DataProcessConfigInfo_type(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Type, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DataProcessConfigInfo_type(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DataProcessConfigInfo",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _DataProcessConfigInfo_llm_config(ctx context.Context, field graphql.CollectedField, obj *DataProcessConfigInfo) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DataProcessConfigInfo_llm_config(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.LlmConfig, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*LLMConfig)
	fc.Result = res
	return ec.marshalOLLMConfig2githubcomkubeagiarcadiaapiservergraphgeneratedLLMConfig(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DataProcessConfigInfo_llm_config(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DataProcessConfigInfo",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext_LLMConfig_name(ctx, field)
			case "namespace":
				return ec.fieldContext_LLMConfig_namespace(ctx, field)
			case "model":
				return ec.fieldContext_LLMConfig_model(ctx, field)
			case "temperature":
				return ec.fieldContext_LLMConfig_temperature(ctx, field)
			case "top_p":
				return ec.fieldContext_LLMConfig_top_p(ctx, field)
			case "max_tokens":
				return ec.fieldContext_LLMConfig_max_tokens(ctx, field)
			case "prompt_template":
				return ec.fieldContext_LLMConfig_prompt_template(ctx, field)
			case "provider":
				return ec.fieldContext_LLMConfig_provider(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type LLMConfig", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _DataProcessConfigInfo_remove_duplicate_config(ctx context.Context, field graphql.CollectedField, obj *DataProcessConfigInfo) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DataProcessConfigInfo_remove_duplicate_config(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.RemoveDuplicateConfig, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*RemoveDuplicateConfigItem)
	fc.Result = res
	return ec.marshalORemoveDuplicateConfigItem2githubcomkubeagiarcadiaapiservergraphgeneratedRemoveDuplicateConfigItem(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DataProcessConfigInfo_remove_duplicate_config(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DataProcessConfigInfo",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "embedding_name":
				return ec.fieldContext_RemoveDuplicateConfigItem_embedding_name(ctx, field)
			case "embedding_namespace":
				return ec.fieldContext_RemoveDuplicateConfigItem_embedding_namespace(ctx, field)
			case "embedding_model":
				return ec.fieldContext_RemoveDuplicateConfigItem_embedding_model(ctx, field)
			case "embedding_provider":
				return ec.fieldContext_RemoveDuplicateConfigItem_embedding_provider(ctx, field)
			case "similarity":
				return ec.fieldContext_RemoveDuplicateConfigItem_similarity(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type RemoveDuplicateConfigItem", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _DataProcessConfigpreFileProgress_id(ctx context.Context, field graphql.CollectedField, obj *DataProcessConfigpreFileProgress) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DataProcessConfigpreFileProgress_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DataProcessConfigpreFileProgress_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DataProcessConfigpreFileProgress",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _DataProcessConfigpreFileProgress_file_name(ctx context.Context, field graphql.CollectedField, obj *DataProcessConfigpreFileProgress) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DataProcessConfigpreFileProgress_file_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.FileName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DataProcessConfigpreFileProgress_file_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DataProcessConfigpreFileProgress",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _DataProcessConfigpreFileProgress_status(ctx context.Context, field graphql.CollectedField, obj *DataProcessConfigpreFileProgress) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DataProcessConfigpreFileProgress_status(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Status, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DataProcessConfigpreFileProgress_status(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DataProcessConfigpreFileProgress",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _DataProcessConfigpreFileProgress_start_time(ctx context.Context, field graphql.CollectedField, obj *DataProcessConfigpreFileProgress) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DataProcessConfigpreFileProgress_start_time(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.StartTime, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DataProcessConfigpreFileProgress_start_time(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DataProcessConfigpreFileProgress",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _DataProcessConfigpreFileProgress_end_time(ctx context.Context, field graphql.CollectedField, obj *DataProcessConfigpreFileProgress) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DataProcessConfigpreFileProgress_end_time(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.EndTime, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DataProcessConfigpreFileProgress_end_time(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DataProcessConfigpreFileProgress",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _DataProcessConfigpreFileProgress_progress(ctx context.Context, field graphql.CollectedField, obj *DataProcessConfigpreFileProgress) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DataProcessConfigpreFileProgress_progress(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Progress, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DataProcessConfigpreFileProgress_progress(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DataProcessConfigpreFileProgress",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _DataProcessConfigpreView_file_name(ctx context.Context, field graphql.CollectedField, obj *DataProcessConfigpreView) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DataProcessConfigpreView_file_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.FileName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DataProcessConfigpreView_file_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DataProcessConfigpreView",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _DataProcessConfigpreView_content(ctx context.Context, field graphql.CollectedField, obj *DataProcessConfigpreView) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DataProcessConfigpreView_content(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Content, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*DataProcessConfigpreViewContent)
	fc.Result = res
	return ec.marshalODataProcessConfigpreViewContent2githubcomkubeagiarcadiaapiservergraphgeneratedDataProcessConfigpreViewContent(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DataProcessConfigpreView_content(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DataProcessConfigpreView",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "pre":
				return ec.fieldContext_DataProcessConfigpreViewContent_pre(ctx, field)
			case "post":
				return ec.fieldContext_DataProcessConfigpreViewContent_post(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type DataProcessConfigpreViewContent", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _DataProcessConfigpreViewContent_pre(ctx context.Context, field graphql.CollectedField, obj *DataProcessConfigpreViewContent) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DataProcessConfigpreViewContent_pre(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Pre, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DataProcessConfigpreViewContent_pre(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DataProcessConfigpreViewContent",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _DataProcessConfigpreViewContent_post(ctx context.Context, field graphql.CollectedField, obj *DataProcessConfigpreViewContent) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DataProcessConfigpreViewContent_post(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Post, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DataProcessConfigpreViewContent_post(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DataProcessConfigpreViewContent",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _DataProcessDetails_status(ctx context.Context, field graphql.CollectedField, obj *DataProcessDetails) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DataProcessDetails_status(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Status, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DataProcessDetails_status(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DataProcessDetails",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _DataProcessDetails_data(ctx context.Context, field graphql.CollectedField, obj *DataProcessDetails) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DataProcessDetails_data(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Data, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(DataProcessDetailsItem)
	fc.Result = res
	return ec.marshalNDataProcessDetailsItem2githubcomkubeagiarcadiaapiservergraphgeneratedDataProcessDetailsItem(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DataProcessDetails_data(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DataProcessDetails",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_DataProcessDetailsItem_id(ctx, field)
			case "status":
				return ec.fieldContext_DataProcessDetailsItem_status(ctx, field)
			case "name":
				return ec.fieldContext_DataProcessDetailsItem_name(ctx, field)
			case "file_type":
				return ec.fieldContext_DataProcessDetailsItem_file_type(ctx, field)
			case "pre_dataset_name":
				return ec.fieldContext_DataProcessDetailsItem_pre_dataset_name(ctx, field)
			case "pre_dataset_version":
				return ec.fieldContext_DataProcessDetailsItem_pre_dataset_version(ctx, field)
			case "post_dataset_name":
				return ec.fieldContext_DataProcessDetailsItem_post_dataset_name(ctx, field)
			case "post_dataset_version":
				return ec.fieldContext_DataProcessDetailsItem_post_dataset_version(ctx, field)
			case "file_num":
				return ec.fieldContext_DataProcessDetailsItem_file_num(ctx, field)
			case "start_time":
				return ec.fieldContext_DataProcessDetailsItem_start_time(ctx, field)
			case "end_time":
				return ec.fieldContext_DataProcessDetailsItem_end_time(ctx, field)
			case "creator":
				return ec.fieldContext_DataProcessDetailsItem_creator(ctx, field)
			case "error_msg":
				return ec.fieldContext_DataProcessDetailsItem_error_msg(ctx, field)
			case "data_process_config_info":
				return ec.fieldContext_DataProcessDetailsItem_data_process_config_info(ctx, field)
			case "config":
				return ec.fieldContext_DataProcessDetailsItem_config(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type DataProcessDetailsItem", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _DataProcessDetails_message(ctx context.Context, field graphql.CollectedField, obj *DataProcessDetails) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DataProcessDetails_message(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Message, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DataProcessDetails_message(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DataProcessDetails",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _DataProcessDetailsItem_id(ctx context.Context, field graphql.CollectedField, obj *DataProcessDetailsItem) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DataProcessDetailsItem_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DataProcessDetailsItem_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DataProcessDetailsItem",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _DataProcessDetailsItem_status(ctx context.Context, field graphql.CollectedField, obj *DataProcessDetailsItem) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DataProcessDetailsItem_status(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Status, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DataProcessDetailsItem_status(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DataProcessDetailsItem",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _DataProcessDetailsItem_name(ctx context.Context, field graphql.CollectedField, obj *DataProcessDetailsItem) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DataProcessDetailsItem_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DataProcessDetailsItem_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DataProcessDetailsItem",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _DataProcessDetailsItem_file_type(ctx context.Context, field graphql.CollectedField, obj *DataProcessDetailsItem) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DataProcessDetailsItem_file_type(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.FileType, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DataProcessDetailsItem_file_type(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DataProcessDetailsItem",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _DataProcessDetailsItem_pre_dataset_name(ctx context.Context, field graphql.CollectedField, obj *DataProcessDetailsItem) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DataProcessDetailsItem_pre_dataset_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PreDatasetName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DataProcessDetailsItem_pre_dataset_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DataProcessDetailsItem",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _DataProcessDetailsItem_pre_dataset_version(ctx context.Context, field graphql.CollectedField, obj *DataProcessDetailsItem) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DataProcessDetailsItem_pre_dataset_version(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PreDatasetVersion, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DataProcessDetailsItem_pre_dataset_version(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DataProcessDetailsItem",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _DataProcessDetailsItem_post_dataset_name(ctx context.Context, field graphql.CollectedField, obj *DataProcessDetailsItem) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DataProcessDetailsItem_post_dataset_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PostDatasetName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DataProcessDetailsItem_post_dataset_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DataProcessDetailsItem",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _DataProcessDetailsItem_post_dataset_version(ctx context.Context, field graphql.CollectedField, obj *DataProcessDetailsItem) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DataProcessDetailsItem_post_dataset_version(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PostDatasetVersion, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DataProcessDetailsItem_post_dataset_version(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DataProcessDetailsItem",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _DataProcessDetailsItem_file_num(ctx context.Context, field graphql.CollectedField, obj *DataProcessDetailsItem) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DataProcessDetailsItem_file_num(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.FileNum, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DataProcessDetailsItem_file_num(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DataProcessDetailsItem",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _DataProcessDetailsItem_start_time(ctx context.Context, field graphql.CollectedField, obj *DataProcessDetailsItem) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DataProcessDetailsItem_start_time(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.StartTime, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DataProcessDetailsItem_start_time(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DataProcessDetailsItem",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _DataProcessDetailsItem_end_time(ctx context.Context, field graphql.CollectedField, obj *DataProcessDetailsItem) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DataProcessDetailsItem_end_time(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.EndTime, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DataProcessDetailsItem_end_time(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DataProcessDetailsItem",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _DataProcessDetailsItem_creator(ctx context.Context, field graphql.CollectedField, obj *DataProcessDetailsItem) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DataProcessDetailsItem_creator(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Creator, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DataProcessDetailsItem_creator(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DataProcessDetailsItem",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _DataProcessDetailsItem_error_msg(ctx context.Context, field graphql.CollectedField, obj *DataProcessDetailsItem) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DataProcessDetailsItem_error_msg(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ErrorMsg, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DataProcessDetailsItem_error_msg(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DataProcessDetailsItem",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _DataProcessDetailsItem_data_process_config_info(ctx context.Context, field graphql.CollectedField, obj *DataProcessDetailsItem) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DataProcessDetailsItem_data_process_config_info(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DataProcessConfigInfo, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*DataProcessConfigInfo)
	fc.Result = res
	return ec.marshalODataProcessConfigInfo2githubcomkubeagiarcadiaapiservergraphgeneratedDataProcessConfigInfo(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DataProcessDetailsItem_data_process_config_info(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DataProcessDetailsItem",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "type":
				return ec.fieldContext_DataProcessConfigInfo_type(ctx, field)
			case "llm_config":
				return ec.fieldContext_DataProcessConfigInfo_llm_config(ctx, field)
			case "remove_duplicate_config":
				return ec.fieldContext_DataProcessConfigInfo_remove_duplicate_config(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type DataProcessConfigInfo", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _DataProcessDetailsItem_config(ctx context.Context, field graphql.CollectedField, obj *DataProcessDetailsItem) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DataProcessDetailsItem_config(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Config, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*DataProcessConfig)
	fc.Result = res
	return ec.marshalODataProcessConfig2githubcomkubeagiarcadiaapiservergraphgeneratedDataProcessConfig(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DataProcessDetailsItem_config(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DataProcessDetailsItem",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext_DataProcessConfig_name(ctx, field)
			case "description":
				return ec.fieldContext_DataProcessConfig_description(ctx, field)
			case "file_num":
				return ec.fieldContext_DataProcessConfig_file_num(ctx, field)
			case "status":
				return ec.fieldContext_DataProcessConfig_status(ctx, field)
			case "children":
				return ec.fieldContext_DataProcessConfig_children(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type DataProcessConfig", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _DataProcessItem_id(ctx context.Context, field graphql.CollectedField, obj *DataProcessItem) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DataProcessItem_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DataProcessItem_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DataProcessItem",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _DataProcessItem_name(ctx context.Context, field graphql.CollectedField, obj *DataProcessItem) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DataProcessItem_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DataProcessItem_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DataProcessItem",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _DataProcessItem_status(ctx context.Context, field graphql.CollectedField, obj *DataProcessItem) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DataProcessItem_status(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Status, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DataProcessItem_status(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DataProcessItem",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _DataProcessItem_pre_data_set_name(ctx context.Context, field graphql.CollectedField, obj *DataProcessItem) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DataProcessItem_pre_data_set_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PreDataSetName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DataProcessItem_pre_data_set_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DataProcessItem",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _DataProcessItem_pre_data_set_version(ctx context.Context, field graphql.CollectedField, obj *DataProcessItem) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DataProcessItem_pre_data_set_version(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PreDataSetVersion, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DataProcessItem_pre_data_set_version(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DataProcessItem",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _DataProcessItem_post_data_set_name(ctx context.Context, field graphql.CollectedField, obj *DataProcessItem) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DataProcessItem_post_data_set_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PostDataSetName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DataProcessItem_post_data_set_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DataProcessItem",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _DataProcessItem_post_data_set_version(ctx context.Context, field graphql.CollectedField, obj *DataProcessItem) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DataProcessItem_post_data_set_version(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PostDataSetVersion, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DataProcessItem_post_data_set_version(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DataProcessItem",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _DataProcessItem_start_datetime(ctx context.Context, field graphql.CollectedField, obj *DataProcessItem) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DataProcessItem_start_datetime(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.StartDatetime, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DataProcessItem_start_datetime(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DataProcessItem",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _DataProcessItem_error_msg(ctx context.Context, field graphql.CollectedField, obj *DataProcessItem) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DataProcessItem_error_msg(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ErrorMsg, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DataProcessItem_error_msg(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DataProcessItem",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _DataProcessMutation_createDataProcessTask(ctx context.Context, field graphql.CollectedField, obj *DataProcessMutation) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DataProcessMutation_createDataProcessTask(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.DataProcessMutation().CreateDataProcessTask(rctx, obj, fc.Args["input"].(*AddDataProcessInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*DataProcessResponse)
	fc.Result = res
	return ec.marshalODataProcessResponse2githubcomkubeagiarcadiaapiservergraphgeneratedDataProcessResponse(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DataProcessMutation_createDataProcessTask(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DataProcessMutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "status":
				return ec.fieldContext_DataProcessResponse_status(ctx, field)
			case "data":
				return ec.fieldContext_DataProcessResponse_data(ctx, field)
			case "message":
				return ec.fieldContext_DataProcessResponse_message(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type DataProcessResponse", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_DataProcessMutation_createDataProcessTask_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _DataProcessMutation_deleteDataProcessTask(ctx context.Context, field graphql.CollectedField, obj *DataProcessMutation) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DataProcessMutation_deleteDataProcessTask(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.DataProcessMutation().DeleteDataProcessTask(rctx, obj, fc.Args["input"].(*DeleteDataProcessInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*DataProcessResponse)
	fc.Result = res
	return ec.marshalODataProcessResponse2githubcomkubeagiarcadiaapiservergraphgeneratedDataProcessResponse(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DataProcessMutation_deleteDataProcessTask(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DataProcessMutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "status":
				return ec.fieldContext_DataProcessResponse_status(ctx, field)
			case "data":
				return ec.fieldContext_DataProcessResponse_data(ctx, field)
			case "message":
				return ec.fieldContext_DataProcessResponse_message(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type DataProcessResponse", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_DataProcessMutation_deleteDataProcessTask_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _DataProcessQuery_allDataProcessListByPage(ctx context.Context, field graphql.CollectedField, obj *DataProcessQuery) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DataProcessQuery_allDataProcessListByPage(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.DataProcessQuery().AllDataProcessListByPage(rctx, obj, fc.Args["input"].(*AllDataProcessListByPageInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*PaginatedDataProcessItem)
	fc.Result = res
	return ec.marshalOPaginatedDataProcessItem2githubcomkubeagiarcadiaapiservergraphgeneratedPaginatedDataProcessItem(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DataProcessQuery_allDataProcessListByPage(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DataProcessQuery",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "status":
				return ec.fieldContext_PaginatedDataProcessItem_status(ctx, field)
			case "data":
				return ec.fieldContext_PaginatedDataProcessItem_data(ctx, field)
			case "message":
				return ec.fieldContext_PaginatedDataProcessItem_message(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type PaginatedDataProcessItem", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_DataProcessQuery_allDataProcessListByPage_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _DataProcessQuery_allDataProcessListByCount(ctx context.Context, field graphql.CollectedField, obj *DataProcessQuery) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DataProcessQuery_allDataProcessListByCount(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.DataProcessQuery().AllDataProcessListByCount(rctx, obj, fc.Args["input"].(*AllDataProcessListByCountInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*CountDataProcessItem)
	fc.Result = res
	return ec.marshalOCountDataProcessItem2githubcomkubeagiarcadiaapiservergraphgeneratedCountDataProcessItem(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DataProcessQuery_allDataProcessListByCount(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DataProcessQuery",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "status":
				return ec.fieldContext_CountDataProcessItem_status(ctx, field)
			case "data":
				return ec.fieldContext_CountDataProcessItem_data(ctx, field)
			case "message":
				return ec.fieldContext_CountDataProcessItem_message(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type CountDataProcessItem", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_DataProcessQuery_allDataProcessListByCount_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _DataProcessQuery_dataProcessSupportType(ctx context.Context, field graphql.CollectedField, obj *DataProcessQuery) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DataProcessQuery_dataProcessSupportType(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.DataProcessQuery().DataProcessSupportType(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*DataProcessSupportType)
	fc.Result = res
	return ec.marshalODataProcessSupportType2githubcomkubeagiarcadiaapiservergraphgeneratedDataProcessSupportType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DataProcessQuery_dataProcessSupportType(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DataProcessQuery",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "status":
				return ec.fieldContext_DataProcessSupportType_status(ctx, field)
			case "data":
				return ec.fieldContext_DataProcessSupportType_data(ctx, field)
			case "message":
				return ec.fieldContext_DataProcessSupportType_message(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type DataProcessSupportType", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _DataProcessQuery_dataProcessDetails(ctx context.Context, field graphql.CollectedField, obj *DataProcessQuery) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DataProcessQuery_dataProcessDetails(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.DataProcessQuery().DataProcessDetails(rctx, obj, fc.Args["input"].(*DataProcessDetailsInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*DataProcessDetails)
	fc.Result = res
	return ec.marshalODataProcessDetails2githubcomkubeagiarcadiaapiservergraphgeneratedDataProcessDetails(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DataProcessQuery_dataProcessDetails(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DataProcessQuery",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "status":
				return ec.fieldContext_DataProcessDetails_status(ctx, field)
			case "data":
				return ec.fieldContext_DataProcessDetails_data(ctx, field)
			case "message":
				return ec.fieldContext_DataProcessDetails_message(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type DataProcessDetails", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_DataProcessQuery_dataProcessDetails_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _DataProcessQuery_checkDataProcessTaskName(ctx context.Context, field graphql.CollectedField, obj *DataProcessQuery) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DataProcessQuery_checkDataProcessTaskName(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.DataProcessQuery().CheckDataProcessTaskName(rctx, obj, fc.Args["input"].(*CheckDataProcessTaskNameInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*DataProcessResponse)
	fc.Result = res
	return ec.marshalODataProcessResponse2githubcomkubeagiarcadiaapiservergraphgeneratedDataProcessResponse(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DataProcessQuery_checkDataProcessTaskName(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DataProcessQuery",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "status":
				return ec.fieldContext_DataProcessResponse_status(ctx, field)
			case "data":
				return ec.fieldContext_DataProcessResponse_data(ctx, field)
			case "message":
				return ec.fieldContext_DataProcessResponse_message(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type DataProcessResponse", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_DataProcessQuery_checkDataProcessTaskName_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _DataProcessQuery_getLogInfo(ctx context.Context, field graphql.CollectedField, obj *DataProcessQuery) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DataProcessQuery_getLogInfo(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.DataProcessQuery().GetLogInfo(rctx, obj, fc.Args["input"].(*DataProcessDetailsInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*DataProcessResponse)
	fc.Result = res
	return ec.marshalODataProcessResponse2githubcomkubeagiarcadiaapiservergraphgeneratedDataProcessResponse(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DataProcessQuery_getLogInfo(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DataProcessQuery",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "status":
				return ec.fieldContext_DataProcessResponse_status(ctx, field)
			case "data":
				return ec.fieldContext_DataProcessResponse_data(ctx, field)
			case "message":
				return ec.fieldContext_DataProcessResponse_message(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type DataProcessResponse", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_DataProcessQuery_getLogInfo_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _DataProcessQuery_dataProcessLogInfoByFileName(ctx context.Context, field graphql.CollectedField, obj *DataProcessQuery) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DataProcessQuery_dataProcessLogInfoByFileName(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.DataProcessQuery().DataProcessLogInfoByFileName(rctx, obj, fc.Args["input"].(*DataProcessFileLogInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*DataProcessResponse)
	fc.Result = res
	return ec.marshalODataProcessResponse2githubcomkubeagiarcadiaapiservergraphgeneratedDataProcessResponse(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DataProcessQuery_dataProcessLogInfoByFileName(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DataProcessQuery",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "status":
				return ec.fieldContext_DataProcessResponse_status(ctx, field)
			case "data":
				return ec.fieldContext_DataProcessResponse_data(ctx, field)
			case "message":
				return ec.fieldContext_DataProcessResponse_message(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type DataProcessResponse", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_DataProcessQuery_dataProcessLogInfoByFileName_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _DataProcessQuery_dataProcessRetry(ctx context.Context, field graphql.CollectedField, obj *DataProcessQuery) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DataProcessQuery_dataProcessRetry(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.DataProcessQuery().DataProcessRetry(rctx, obj, fc.Args["input"].(*DataProcessRetryInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*DataProcessResponse)
	fc.Result = res
	return ec.marshalODataProcessResponse2githubcomkubeagiarcadiaapiservergraphgeneratedDataProcessResponse(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DataProcessQuery_dataProcessRetry(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DataProcessQuery",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "status":
				return ec.fieldContext_DataProcessResponse_status(ctx, field)
			case "data":
				return ec.fieldContext_DataProcessResponse_data(ctx, field)
			case "message":
				return ec.fieldContext_DataProcessResponse_message(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type DataProcessResponse", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_DataProcessQuery_dataProcessRetry_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _DataProcessResponse_status(ctx context.Context, field graphql.CollectedField, obj *DataProcessResponse) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DataProcessResponse_status(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Status, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DataProcessResponse_status(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DataProcessResponse",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _DataProcessResponse_data(ctx context.Context, field graphql.CollectedField, obj *DataProcessResponse) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DataProcessResponse_data(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Data, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DataProcessResponse_data(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DataProcessResponse",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _DataProcessResponse_message(ctx context.Context, field graphql.CollectedField, obj *DataProcessResponse) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DataProcessResponse_message(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Message, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DataProcessResponse_message(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DataProcessResponse",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _DataProcessSupportType_status(ctx context.Context, field graphql.CollectedField, obj *DataProcessSupportType) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DataProcessSupportType_status(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Status, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DataProcessSupportType_status(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DataProcessSupportType",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _DataProcessSupportType_data(ctx context.Context, field graphql.CollectedField, obj *DataProcessSupportType) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DataProcessSupportType_data(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Data, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*DataProcessSupportTypeItem)
	fc.Result = res
	return ec.marshalODataProcessSupportTypeItem2githubcomkubeagiarcadiaapiservergraphgeneratedDataProcessSupportTypeItem(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DataProcessSupportType_data(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DataProcessSupportType",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext_DataProcessSupportTypeItem_name(ctx, field)
			case "description":
				return ec.fieldContext_DataProcessSupportTypeItem_description(ctx, field)
			case "children":
				return ec.fieldContext_DataProcessSupportTypeItem_children(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type DataProcessSupportTypeItem", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _DataProcessSupportType_message(ctx context.Context, field graphql.CollectedField, obj *DataProcessSupportType) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DataProcessSupportType_message(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Message, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DataProcessSupportType_message(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DataProcessSupportType",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _DataProcessSupportTypeChildren_name(ctx context.Context, field graphql.CollectedField, obj *DataProcessSupportTypeChildren) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DataProcessSupportTypeChildren_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DataProcessSupportTypeChildren_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DataProcessSupportTypeChildren",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _DataProcessSupportTypeChildren_zh_name(ctx context.Context, field graphql.CollectedField, obj *DataProcessSupportTypeChildren) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DataProcessSupportTypeChildren_zh_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ZhName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DataProcessSupportTypeChildren_zh_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DataProcessSupportTypeChildren",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _DataProcessSupportTypeChildren_enable(ctx context.Context, field graphql.CollectedField, obj *DataProcessSupportTypeChildren) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DataProcessSupportTypeChildren_enable(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Enable, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DataProcessSupportTypeChildren_enable(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DataProcessSupportTypeChildren",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _DataProcessSupportTypeChildren_description(ctx context.Context, field graphql.CollectedField, obj *DataProcessSupportTypeChildren) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DataProcessSupportTypeChildren_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DataProcessSupportTypeChildren_description(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DataProcessSupportTypeChildren",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _DataProcessSupportTypeItem_name(ctx context.Context, field graphql.CollectedField, obj *DataProcessSupportTypeItem) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DataProcessSupportTypeItem_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DataProcessSupportTypeItem_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DataProcessSupportTypeItem",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _DataProcessSupportTypeItem_description(ctx context.Context, field graphql.CollectedField, obj *DataProcessSupportTypeItem) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DataProcessSupportTypeItem_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DataProcessSupportTypeItem_description(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DataProcessSupportTypeItem",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _DataProcessSupportTypeItem_children(ctx context.Context, field graphql.CollectedField, obj *DataProcessSupportTypeItem) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DataProcessSupportTypeItem_children(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Children, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*DataProcessSupportTypeChildren)
	fc.Result = res
	return ec.marshalODataProcessSupportTypeChildren2githubcomkubeagiarcadiaapiservergraphgeneratedDataProcessSupportTypeChildren(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DataProcessSupportTypeItem_children(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DataProcessSupportTypeItem",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext_DataProcessSupportTypeChildren_name(ctx, field)
			case "zh_name":
				return ec.fieldContext_DataProcessSupportTypeChildren_zh_name(ctx, field)
			case "enable":
				return ec.fieldContext_DataProcessSupportTypeChildren_enable(ctx, field)
			case "description":
				return ec.fieldContext_DataProcessSupportTypeChildren_description(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type DataProcessSupportTypeChildren", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Dataset_name(ctx context.Context, field graphql.CollectedField, obj *Dataset) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Dataset_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Dataset_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Dataset",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Dataset_namespace(ctx context.Context, field graphql.CollectedField, obj *Dataset) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Dataset_namespace(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Namespace, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Dataset_namespace(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Dataset",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Dataset_labels(ctx context.Context, field graphql.CollectedField, obj *Dataset) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Dataset_labels(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Labels, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(map[string]interface{})
	fc.Result = res
	return ec.marshalOMap2map(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Dataset_labels(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Dataset",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Map does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Dataset_annotations(ctx context.Context, field graphql.CollectedField, obj *Dataset) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Dataset_annotations(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Annotations, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(map[string]interface{})
	fc.Result = res
	return ec.marshalOMap2map(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Dataset_annotations(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Dataset",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Map does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Dataset_creator(ctx context.Context, field graphql.CollectedField, obj *Dataset) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Dataset_creator(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Creator, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Dataset_creator(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Dataset",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Dataset_displayName(ctx context.Context, field graphql.CollectedField, obj *Dataset) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Dataset_displayName(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DisplayName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Dataset_displayName(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Dataset",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Dataset_description(ctx context.Context, field graphql.CollectedField, obj *Dataset) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Dataset_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Dataset_description(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Dataset",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Dataset_creationTimestamp(ctx context.Context, field graphql.CollectedField, obj *Dataset) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Dataset_creationTimestamp(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CreationTimestamp, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*time.Time)
	fc.Result = res
	return ec.marshalOTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Dataset_creationTimestamp(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Dataset",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Dataset_updateTimestamp(ctx context.Context, field graphql.CollectedField, obj *Dataset) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Dataset_updateTimestamp(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UpdateTimestamp, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*time.Time)
	fc.Result = res
	return ec.marshalOTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Dataset_updateTimestamp(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Dataset",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Dataset_contentType(ctx context.Context, field graphql.CollectedField, obj *Dataset) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Dataset_contentType(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ContentType, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Dataset_contentType(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Dataset",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Dataset_field(ctx context.Context, field graphql.CollectedField, obj *Dataset) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Dataset_field(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Field, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Dataset_field(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Dataset",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Dataset_versions(ctx context.Context, field graphql.CollectedField, obj *Dataset) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Dataset_versions(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Dataset().Versions(rctx, obj, fc.Args["input"].(ListVersionedDatasetInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*PaginatedResult)
	fc.Result = res
	return ec.marshalNPaginatedResult2githubcomkubeagiarcadiaapiservergraphgeneratedPaginatedResult(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Dataset_versions(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Dataset",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "hasNextPage":
				return ec.fieldContext_PaginatedResult_hasNextPage(ctx, field)
			case "nodes":
				return ec.fieldContext_PaginatedResult_nodes(ctx, field)
			case "page":
				return ec.fieldContext_PaginatedResult_page(ctx, field)
			case "pageSize":
				return ec.fieldContext_PaginatedResult_pageSize(ctx, field)
			case "totalCount":
				return ec.fieldContext_PaginatedResult_totalCount(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type PaginatedResult", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Dataset_versions_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _DatasetMutation_createDataset(ctx context.Context, field graphql.CollectedField, obj *DatasetMutation) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DatasetMutation_createDataset(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.DatasetMutation().CreateDataset(rctx, obj, fc.Args["input"].(*CreateDatasetInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*Dataset)
	fc.Result = res
	return ec.marshalNDataset2githubcomkubeagiarcadiaapiservergraphgeneratedDataset(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DatasetMutation_createDataset(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DatasetMutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext_Dataset_name(ctx, field)
			case "namespace":
				return ec.fieldContext_Dataset_namespace(ctx, field)
			case "labels":
				return ec.fieldContext_Dataset_labels(ctx, field)
			case "annotations":
				return ec.fieldContext_Dataset_annotations(ctx, field)
			case "creator":
				return ec.fieldContext_Dataset_creator(ctx, field)
			case "displayName":
				return ec.fieldContext_Dataset_displayName(ctx, field)
			case "description":
				return ec.fieldContext_Dataset_description(ctx, field)
			case "creationTimestamp":
				return ec.fieldContext_Dataset_creationTimestamp(ctx, field)
			case "updateTimestamp":
				return ec.fieldContext_Dataset_updateTimestamp(ctx, field)
			case "contentType":
				return ec.fieldContext_Dataset_contentType(ctx, field)
			case "field":
				return ec.fieldContext_Dataset_field(ctx, field)
			case "versions":
				return ec.fieldContext_Dataset_versions(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Dataset", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_DatasetMutation_createDataset_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _DatasetMutation_updateDataset(ctx context.Context, field graphql.CollectedField, obj *DatasetMutation) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DatasetMutation_updateDataset(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.DatasetMutation().UpdateDataset(rctx, obj, fc.Args["input"].(*UpdateDatasetInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*Dataset)
	fc.Result = res
	return ec.marshalNDataset2githubcomkubeagiarcadiaapiservergraphgeneratedDataset(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DatasetMutation_updateDataset(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DatasetMutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext_Dataset_name(ctx, field)
			case "namespace":
				return ec.fieldContext_Dataset_namespace(ctx, field)
			case "labels":
				return ec.fieldContext_Dataset_labels(ctx, field)
			case "annotations":
				return ec.fieldContext_Dataset_annotations(ctx, field)
			case "creator":
				return ec.fieldContext_Dataset_creator(ctx, field)
			case "displayName":
				return ec.fieldContext_Dataset_displayName(ctx, field)
			case "description":
				return ec.fieldContext_Dataset_description(ctx, field)
			case "creationTimestamp":
				return ec.fieldContext_Dataset_creationTimestamp(ctx, field)
			case "updateTimestamp":
				return ec.fieldContext_Dataset_updateTimestamp(ctx, field)
			case "contentType":
				return ec.fieldContext_Dataset_contentType(ctx, field)
			case "field":
				return ec.fieldContext_Dataset_field(ctx, field)
			case "versions":
				return ec.fieldContext_Dataset_versions(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Dataset", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_DatasetMutation_updateDataset_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _DatasetMutation_deleteDatasets(ctx context.Context, field graphql.CollectedField, obj *DatasetMutation) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DatasetMutation_deleteDatasets(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.DatasetMutation().DeleteDatasets(rctx, obj, fc.Args["input"].(*DeleteCommonInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOVoid2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DatasetMutation_deleteDatasets(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DatasetMutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Void does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_DatasetMutation_deleteDatasets_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _DatasetQuery_getDataset(ctx context.Context, field graphql.CollectedField, obj *DatasetQuery) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DatasetQuery_getDataset(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.DatasetQuery().GetDataset(rctx, obj, fc.Args["name"].(string), fc.Args["namespace"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*Dataset)
	fc.Result = res
	return ec.marshalNDataset2githubcomkubeagiarcadiaapiservergraphgeneratedDataset(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DatasetQuery_getDataset(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DatasetQuery",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext_Dataset_name(ctx, field)
			case "namespace":
				return ec.fieldContext_Dataset_namespace(ctx, field)
			case "labels":
				return ec.fieldContext_Dataset_labels(ctx, field)
			case "annotations":
				return ec.fieldContext_Dataset_annotations(ctx, field)
			case "creator":
				return ec.fieldContext_Dataset_creator(ctx, field)
			case "displayName":
				return ec.fieldContext_Dataset_displayName(ctx, field)
			case "description":
				return ec.fieldContext_Dataset_description(ctx, field)
			case "creationTimestamp":
				return ec.fieldContext_Dataset_creationTimestamp(ctx, field)
			case "updateTimestamp":
				return ec.fieldContext_Dataset_updateTimestamp(ctx, field)
			case "contentType":
				return ec.fieldContext_Dataset_contentType(ctx, field)
			case "field":
				return ec.fieldContext_Dataset_field(ctx, field)
			case "versions":
				return ec.fieldContext_Dataset_versions(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Dataset", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_DatasetQuery_getDataset_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _DatasetQuery_listDatasets(ctx context.Context, field graphql.CollectedField, obj *DatasetQuery) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DatasetQuery_listDatasets(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.DatasetQuery().ListDatasets(rctx, obj, fc.Args["input"].(*ListDatasetInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*PaginatedResult)
	fc.Result = res
	return ec.marshalNPaginatedResult2githubcomkubeagiarcadiaapiservergraphgeneratedPaginatedResult(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DatasetQuery_listDatasets(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DatasetQuery",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "hasNextPage":
				return ec.fieldContext_PaginatedResult_hasNextPage(ctx, field)
			case "nodes":
				return ec.fieldContext_PaginatedResult_nodes(ctx, field)
			case "page":
				return ec.fieldContext_PaginatedResult_page(ctx, field)
			case "pageSize":
				return ec.fieldContext_PaginatedResult_pageSize(ctx, field)
			case "totalCount":
				return ec.fieldContext_PaginatedResult_totalCount(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type PaginatedResult", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_DatasetQuery_listDatasets_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Datasource_id(ctx context.Context, field graphql.CollectedField, obj *Datasource) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Datasource_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Datasource_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Datasource",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Datasource_name(ctx context.Context, field graphql.CollectedField, obj *Datasource) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Datasource_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Datasource_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Datasource",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Datasource_namespace(ctx context.Context, field graphql.CollectedField, obj *Datasource) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Datasource_namespace(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Namespace, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Datasource_namespace(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Datasource",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Datasource_labels(ctx context.Context, field graphql.CollectedField, obj *Datasource) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Datasource_labels(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Labels, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(map[string]interface{})
	fc.Result = res
	return ec.marshalOMap2map(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Datasource_labels(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Datasource",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Map does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Datasource_annotations(ctx context.Context, field graphql.CollectedField, obj *Datasource) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Datasource_annotations(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Annotations, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(map[string]interface{})
	fc.Result = res
	return ec.marshalOMap2map(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Datasource_annotations(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Datasource",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Map does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Datasource_creator(ctx context.Context, field graphql.CollectedField, obj *Datasource) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Datasource_creator(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Creator, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Datasource_creator(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Datasource",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Datasource_displayName(ctx context.Context, field graphql.CollectedField, obj *Datasource) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Datasource_displayName(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DisplayName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Datasource_displayName(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Datasource",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Datasource_description(ctx context.Context, field graphql.CollectedField, obj *Datasource) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Datasource_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Datasource_description(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Datasource",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Datasource_endpoint(ctx context.Context, field graphql.CollectedField, obj *Datasource) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Datasource_endpoint(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Endpoint, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*Endpoint)
	fc.Result = res
	return ec.marshalOEndpoint2githubcomkubeagiarcadiaapiservergraphgeneratedEndpoint(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Datasource_endpoint(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Datasource",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "url":
				return ec.fieldContext_Endpoint_url(ctx, field)
			case "authSecret":
				return ec.fieldContext_Endpoint_authSecret(ctx, field)
			case "insecure":
				return ec.fieldContext_Endpoint_insecure(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Endpoint", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Datasource_type(ctx context.Context, field graphql.CollectedField, obj *Datasource) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Datasource_type(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Type, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Datasource_type(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Datasource",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Datasource_oss(ctx context.Context, field graphql.CollectedField, obj *Datasource) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Datasource_oss(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Oss, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*Oss)
	fc.Result = res
	return ec.marshalOOss2githubcomkubeagiarcadiaapiservergraphgeneratedOss(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Datasource_oss(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Datasource",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "bucket":
				return ec.fieldContext_Oss_bucket(ctx, field)
			case "object":
				return ec.fieldContext_Oss_object(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Oss", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Datasource_web(ctx context.Context, field graphql.CollectedField, obj *Datasource) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Datasource_web(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Web, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*Web)
	fc.Result = res
	return ec.marshalOWeb2githubcomkubeagiarcadiaapiservergraphgeneratedWeb(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Datasource_web(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Datasource",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "recommendIntervalTime":
				return ec.fieldContext_Web_recommendIntervalTime(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Web", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Datasource_status(ctx context.Context, field graphql.CollectedField, obj *Datasource) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Datasource_status(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Status, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Datasource_status(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Datasource",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Datasource_message(ctx context.Context, field graphql.CollectedField, obj *Datasource) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Datasource_message(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Message, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Datasource_message(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Datasource",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Datasource_creationTimestamp(ctx context.Context, field graphql.CollectedField, obj *Datasource) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Datasource_creationTimestamp(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CreationTimestamp, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*time.Time)
	fc.Result = res
	return ec.marshalOTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Datasource_creationTimestamp(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Datasource",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Datasource_updateTimestamp(ctx context.Context, field graphql.CollectedField, obj *Datasource) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Datasource_updateTimestamp(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UpdateTimestamp, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*time.Time)
	fc.Result = res
	return ec.marshalOTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Datasource_updateTimestamp(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Datasource",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _DatasourceMutation_createDatasource(ctx context.Context, field graphql.CollectedField, obj *DatasourceMutation) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DatasourceMutation_createDatasource(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.DatasourceMutation().CreateDatasource(rctx, obj, fc.Args["input"].(CreateDatasourceInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*Datasource)
	fc.Result = res
	return ec.marshalNDatasource2githubcomkubeagiarcadiaapiservergraphgeneratedDatasource(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DatasourceMutation_createDatasource(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DatasourceMutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Datasource_id(ctx, field)
			case "name":
				return ec.fieldContext_Datasource_name(ctx, field)
			case "namespace":
				return ec.fieldContext_Datasource_namespace(ctx, field)
			case "labels":
				return ec.fieldContext_Datasource_labels(ctx, field)
			case "annotations":
				return ec.fieldContext_Datasource_annotations(ctx, field)
			case "creator":
				return ec.fieldContext_Datasource_creator(ctx, field)
			case "displayName":
				return ec.fieldContext_Datasource_displayName(ctx, field)
			case "description":
				return ec.fieldContext_Datasource_description(ctx, field)
			case "endpoint":
				return ec.fieldContext_Datasource_endpoint(ctx, field)
			case "type":
				return ec.fieldContext_Datasource_type(ctx, field)
			case "oss":
				return ec.fieldContext_Datasource_oss(ctx, field)
			case "web":
				return ec.fieldContext_Datasource_web(ctx, field)
			case "status":
				return ec.fieldContext_Datasource_status(ctx, field)
			case "message":
				return ec.fieldContext_Datasource_message(ctx, field)
			case "creationTimestamp":
				return ec.fieldContext_Datasource_creationTimestamp(ctx, field)
			case "updateTimestamp":
				return ec.fieldContext_Datasource_updateTimestamp(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Datasource", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_DatasourceMutation_createDatasource_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _DatasourceMutation_updateDatasource(ctx context.Context, field graphql.CollectedField, obj *DatasourceMutation) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DatasourceMutation_updateDatasource(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.DatasourceMutation().UpdateDatasource(rctx, obj, fc.Args["input"].(*UpdateDatasourceInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*Datasource)
	fc.Result = res
	return ec.marshalNDatasource2githubcomkubeagiarcadiaapiservergraphgeneratedDatasource(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DatasourceMutation_updateDatasource(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DatasourceMutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Datasource_id(ctx, field)
			case "name":
				return ec.fieldContext_Datasource_name(ctx, field)
			case "namespace":
				return ec.fieldContext_Datasource_namespace(ctx, field)
			case "labels":
				return ec.fieldContext_Datasource_labels(ctx, field)
			case "annotations":
				return ec.fieldContext_Datasource_annotations(ctx, field)
			case "creator":
				return ec.fieldContext_Datasource_creator(ctx, field)
			case "displayName":
				return ec.fieldContext_Datasource_displayName(ctx, field)
			case "description":
				return ec.fieldContext_Datasource_description(ctx, field)
			case "endpoint":
				return ec.fieldContext_Datasource_endpoint(ctx, field)
			case "type":
				return ec.fieldContext_Datasource_type(ctx, field)
			case "oss":
				return ec.fieldContext_Datasource_oss(ctx, field)
			case "web":
				return ec.fieldContext_Datasource_web(ctx, field)
			case "status":
				return ec.fieldContext_Datasource_status(ctx, field)
			case "message":
				return ec.fieldContext_Datasource_message(ctx, field)
			case "creationTimestamp":
				return ec.fieldContext_Datasource_creationTimestamp(ctx, field)
			case "updateTimestamp":
				return ec.fieldContext_Datasource_updateTimestamp(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Datasource", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_DatasourceMutation_updateDatasource_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _DatasourceMutation_deleteDatasources(ctx context.Context, field graphql.CollectedField, obj *DatasourceMutation) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DatasourceMutation_deleteDatasources(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.DatasourceMutation().DeleteDatasources(rctx, obj, fc.Args["input"].(*DeleteCommonInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOVoid2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DatasourceMutation_deleteDatasources(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DatasourceMutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Void does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_DatasourceMutation_deleteDatasources_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _DatasourceQuery_getDatasource(ctx context.Context, field graphql.CollectedField, obj *DatasourceQuery) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DatasourceQuery_getDatasource(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.DatasourceQuery().GetDatasource(rctx, obj, fc.Args["name"].(string), fc.Args["namespace"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*Datasource)
	fc.Result = res
	return ec.marshalNDatasource2githubcomkubeagiarcadiaapiservergraphgeneratedDatasource(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DatasourceQuery_getDatasource(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DatasourceQuery",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Datasource_id(ctx, field)
			case "name":
				return ec.fieldContext_Datasource_name(ctx, field)
			case "namespace":
				return ec.fieldContext_Datasource_namespace(ctx, field)
			case "labels":
				return ec.fieldContext_Datasource_labels(ctx, field)
			case "annotations":
				return ec.fieldContext_Datasource_annotations(ctx, field)
			case "creator":
				return ec.fieldContext_Datasource_creator(ctx, field)
			case "displayName":
				return ec.fieldContext_Datasource_displayName(ctx, field)
			case "description":
				return ec.fieldContext_Datasource_description(ctx, field)
			case "endpoint":
				return ec.fieldContext_Datasource_endpoint(ctx, field)
			case "type":
				return ec.fieldContext_Datasource_type(ctx, field)
			case "oss":
				return ec.fieldContext_Datasource_oss(ctx, field)
			case "web":
				return ec.fieldContext_Datasource_web(ctx, field)
			case "status":
				return ec.fieldContext_Datasource_status(ctx, field)
			case "message":
				return ec.fieldContext_Datasource_message(ctx, field)
			case "creationTimestamp":
				return ec.fieldContext_Datasource_creationTimestamp(ctx, field)
			case "updateTimestamp":
				return ec.fieldContext_Datasource_updateTimestamp(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Datasource", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_DatasourceQuery_getDatasource_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _DatasourceQuery_checkDatasource(ctx context.Context, field graphql.CollectedField, obj *DatasourceQuery) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DatasourceQuery_checkDatasource(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.DatasourceQuery().CheckDatasource(rctx, obj, fc.Args["input"].(CreateDatasourceInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*Datasource)
	fc.Result = res
	return ec.marshalNDatasource2githubcomkubeagiarcadiaapiservergraphgeneratedDatasource(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DatasourceQuery_checkDatasource(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DatasourceQuery",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Datasource_id(ctx, field)
			case "name":
				return ec.fieldContext_Datasource_name(ctx, field)
			case "namespace":
				return ec.fieldContext_Datasource_namespace(ctx, field)
			case "labels":
				return ec.fieldContext_Datasource_labels(ctx, field)
			case "annotations":
				return ec.fieldContext_Datasource_annotations(ctx, field)
			case "creator":
				return ec.fieldContext_Datasource_creator(ctx, field)
			case "displayName":
				return ec.fieldContext_Datasource_displayName(ctx, field)
			case "description":
				return ec.fieldContext_Datasource_description(ctx, field)
			case "endpoint":
				return ec.fieldContext_Datasource_endpoint(ctx, field)
			case "type":
				return ec.fieldContext_Datasource_type(ctx, field)
			case "oss":
				return ec.fieldContext_Datasource_oss(ctx, field)
			case "web":
				return ec.fieldContext_Datasource_web(ctx, field)
			case "status":
				return ec.fieldContext_Datasource_status(ctx, field)
			case "message":
				return ec.fieldContext_Datasource_message(ctx, field)
			case "creationTimestamp":
				return ec.fieldContext_Datasource_creationTimestamp(ctx, field)
			case "updateTimestamp":
				return ec.fieldContext_Datasource_updateTimestamp(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Datasource", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_DatasourceQuery_checkDatasource_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _DatasourceQuery_listDatasources(ctx context.Context, field graphql.CollectedField, obj *DatasourceQuery) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DatasourceQuery_listDatasources(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.DatasourceQuery().ListDatasources(rctx, obj, fc.Args["input"].(ListCommonInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*PaginatedResult)
	fc.Result = res
	return ec.marshalNPaginatedResult2githubcomkubeagiarcadiaapiservergraphgeneratedPaginatedResult(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DatasourceQuery_listDatasources(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DatasourceQuery",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "hasNextPage":
				return ec.fieldContext_PaginatedResult_hasNextPage(ctx, field)
			case "nodes":
				return ec.fieldContext_PaginatedResult_nodes(ctx, field)
			case "page":
				return ec.fieldContext_PaginatedResult_page(ctx, field)
			case "pageSize":
				return ec.fieldContext_PaginatedResult_pageSize(ctx, field)
			case "totalCount":
				return ec.fieldContext_PaginatedResult_totalCount(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type PaginatedResult", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_DatasourceQuery_listDatasources_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Embedder_id(ctx context.Context, field graphql.CollectedField, obj *Embedder) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Embedder_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Embedder_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Embedder",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Embedder_name(ctx context.Context, field graphql.CollectedField, obj *Embedder) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Embedder_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Embedder_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Embedder",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Embedder_namespace(ctx context.Context, field graphql.CollectedField, obj *Embedder) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Embedder_namespace(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Namespace, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Embedder_namespace(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Embedder",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Embedder_labels(ctx context.Context, field graphql.CollectedField, obj *Embedder) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Embedder_labels(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Labels, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(map[string]interface{})
	fc.Result = res
	return ec.marshalOMap2map(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Embedder_labels(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Embedder",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Map does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Embedder_annotations(ctx context.Context, field graphql.CollectedField, obj *Embedder) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Embedder_annotations(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Annotations, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(map[string]interface{})
	fc.Result = res
	return ec.marshalOMap2map(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Embedder_annotations(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Embedder",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Map does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Embedder_creator(ctx context.Context, field graphql.CollectedField, obj *Embedder) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Embedder_creator(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Creator, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Embedder_creator(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Embedder",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Embedder_displayName(ctx context.Context, field graphql.CollectedField, obj *Embedder) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Embedder_displayName(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DisplayName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Embedder_displayName(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Embedder",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Embedder_description(ctx context.Context, field graphql.CollectedField, obj *Embedder) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Embedder_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Embedder_description(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Embedder",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Embedder_baseUrl(ctx context.Context, field graphql.CollectedField, obj *Embedder) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Embedder_baseUrl(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.BaseURL, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Embedder_baseUrl(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Embedder",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Embedder_models(ctx context.Context, field graphql.CollectedField, obj *Embedder) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Embedder_models(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Models, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Embedder_models(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Embedder",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Embedder_provider(ctx context.Context, field graphql.CollectedField, obj *Embedder) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Embedder_provider(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Provider, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Embedder_provider(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Embedder",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Embedder_type(ctx context.Context, field graphql.CollectedField, obj *Embedder) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Embedder_type(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Type, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Embedder_type(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Embedder",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Embedder_creationTimestamp(ctx context.Context, field graphql.CollectedField, obj *Embedder) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Embedder_creationTimestamp(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CreationTimestamp, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*time.Time)
	fc.Result = res
	return ec.marshalOTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Embedder_creationTimestamp(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Embedder",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Embedder_updateTimestamp(ctx context.Context, field graphql.CollectedField, obj *Embedder) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Embedder_updateTimestamp(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UpdateTimestamp, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*time.Time)
	fc.Result = res
	return ec.marshalOTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Embedder_updateTimestamp(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Embedder",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Embedder_status(ctx context.Context, field graphql.CollectedField, obj *Embedder) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Embedder_status(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Status, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Embedder_status(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Embedder",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Embedder_message(ctx context.Context, field graphql.CollectedField, obj *Embedder) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Embedder_message(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Message, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Embedder_message(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Embedder",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _EmbedderMutation_createEmbedder(ctx context.Context, field graphql.CollectedField, obj *EmbedderMutation) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_EmbedderMutation_createEmbedder(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.EmbedderMutation().CreateEmbedder(rctx, obj, fc.Args["input"].(CreateEmbedderInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*Embedder)
	fc.Result = res
	return ec.marshalNEmbedder2githubcomkubeagiarcadiaapiservergraphgeneratedEmbedder(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_EmbedderMutation_createEmbedder(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "EmbedderMutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Embedder_id(ctx, field)
			case "name":
				return ec.fieldContext_Embedder_name(ctx, field)
			case "namespace":
				return ec.fieldContext_Embedder_namespace(ctx, field)
			case "labels":
				return ec.fieldContext_Embedder_labels(ctx, field)
			case "annotations":
				return ec.fieldContext_Embedder_annotations(ctx, field)
			case "creator":
				return ec.fieldContext_Embedder_creator(ctx, field)
			case "displayName":
				return ec.fieldContext_Embedder_displayName(ctx, field)
			case "description":
				return ec.fieldContext_Embedder_description(ctx, field)
			case "baseUrl":
				return ec.fieldContext_Embedder_baseUrl(ctx, field)
			case "models":
				return ec.fieldContext_Embedder_models(ctx, field)
			case "provider":
				return ec.fieldContext_Embedder_provider(ctx, field)
			case "type":
				return ec.fieldContext_Embedder_type(ctx, field)
			case "creationTimestamp":
				return ec.fieldContext_Embedder_creationTimestamp(ctx, field)
			case "updateTimestamp":
				return ec.fieldContext_Embedder_updateTimestamp(ctx, field)
			case "status":
				return ec.fieldContext_Embedder_status(ctx, field)
			case "message":
				return ec.fieldContext_Embedder_message(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Embedder", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_EmbedderMutation_createEmbedder_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _EmbedderMutation_updateEmbedder(ctx context.Context, field graphql.CollectedField, obj *EmbedderMutation) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_EmbedderMutation_updateEmbedder(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.EmbedderMutation().UpdateEmbedder(rctx, obj, fc.Args["input"].(*UpdateEmbedderInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*Embedder)
	fc.Result = res
	return ec.marshalNEmbedder2githubcomkubeagiarcadiaapiservergraphgeneratedEmbedder(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_EmbedderMutation_updateEmbedder(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "EmbedderMutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Embedder_id(ctx, field)
			case "name":
				return ec.fieldContext_Embedder_name(ctx, field)
			case "namespace":
				return ec.fieldContext_Embedder_namespace(ctx, field)
			case "labels":
				return ec.fieldContext_Embedder_labels(ctx, field)
			case "annotations":
				return ec.fieldContext_Embedder_annotations(ctx, field)
			case "creator":
				return ec.fieldContext_Embedder_creator(ctx, field)
			case "displayName":
				return ec.fieldContext_Embedder_displayName(ctx, field)
			case "description":
				return ec.fieldContext_Embedder_description(ctx, field)
			case "baseUrl":
				return ec.fieldContext_Embedder_baseUrl(ctx, field)
			case "models":
				return ec.fieldContext_Embedder_models(ctx, field)
			case "provider":
				return ec.fieldContext_Embedder_provider(ctx, field)
			case "type":
				return ec.fieldContext_Embedder_type(ctx, field)
			case "creationTimestamp":
				return ec.fieldContext_Embedder_creationTimestamp(ctx, field)
			case "updateTimestamp":
				return ec.fieldContext_Embedder_updateTimestamp(ctx, field)
			case "status":
				return ec.fieldContext_Embedder_status(ctx, field)
			case "message":
				return ec.fieldContext_Embedder_message(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Embedder", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_EmbedderMutation_updateEmbedder_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _EmbedderMutation_deleteEmbedders(ctx context.Context, field graphql.CollectedField, obj *EmbedderMutation) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_EmbedderMutation_deleteEmbedders(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.EmbedderMutation().DeleteEmbedders(rctx, obj, fc.Args["input"].(*DeleteCommonInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOVoid2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_EmbedderMutation_deleteEmbedders(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "EmbedderMutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Void does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_EmbedderMutation_deleteEmbedders_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _EmbedderQuery_getEmbedder(ctx context.Context, field graphql.CollectedField, obj *EmbedderQuery) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_EmbedderQuery_getEmbedder(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.EmbedderQuery().GetEmbedder(rctx, obj, fc.Args["name"].(string), fc.Args["namespace"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*Embedder)
	fc.Result = res
	return ec.marshalNEmbedder2githubcomkubeagiarcadiaapiservergraphgeneratedEmbedder(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_EmbedderQuery_getEmbedder(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "EmbedderQuery",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Embedder_id(ctx, field)
			case "name":
				return ec.fieldContext_Embedder_name(ctx, field)
			case "namespace":
				return ec.fieldContext_Embedder_namespace(ctx, field)
			case "labels":
				return ec.fieldContext_Embedder_labels(ctx, field)
			case "annotations":
				return ec.fieldContext_Embedder_annotations(ctx, field)
			case "creator":
				return ec.fieldContext_Embedder_creator(ctx, field)
			case "displayName":
				return ec.fieldContext_Embedder_displayName(ctx, field)
			case "description":
				return ec.fieldContext_Embedder_description(ctx, field)
			case "baseUrl":
				return ec.fieldContext_Embedder_baseUrl(ctx, field)
			case "models":
				return ec.fieldContext_Embedder_models(ctx, field)
			case "provider":
				return ec.fieldContext_Embedder_provider(ctx, field)
			case "type":
				return ec.fieldContext_Embedder_type(ctx, field)
			case "creationTimestamp":
				return ec.fieldContext_Embedder_creationTimestamp(ctx, field)
			case "updateTimestamp":
				return ec.fieldContext_Embedder_updateTimestamp(ctx, field)
			case "status":
				return ec.fieldContext_Embedder_status(ctx, field)
			case "message":
				return ec.fieldContext_Embedder_message(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Embedder", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_EmbedderQuery_getEmbedder_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _EmbedderQuery_listEmbedders(ctx context.Context, field graphql.CollectedField, obj *EmbedderQuery) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_EmbedderQuery_listEmbedders(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.EmbedderQuery().ListEmbedders(rctx, obj, fc.Args["input"].(ListCommonInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*PaginatedResult)
	fc.Result = res
	return ec.marshalNPaginatedResult2githubcomkubeagiarcadiaapiservergraphgeneratedPaginatedResult(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_EmbedderQuery_listEmbedders(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "EmbedderQuery",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "hasNextPage":
				return ec.fieldContext_PaginatedResult_hasNextPage(ctx, field)
			case "nodes":
				return ec.fieldContext_PaginatedResult_nodes(ctx, field)
			case "page":
				return ec.fieldContext_PaginatedResult_page(ctx, field)
			case "pageSize":
				return ec.fieldContext_PaginatedResult_pageSize(ctx, field)
			case "totalCount":
				return ec.fieldContext_PaginatedResult_totalCount(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type PaginatedResult", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_EmbedderQuery_listEmbedders_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Endpoint_url(ctx context.Context, field graphql.CollectedField, obj *Endpoint) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Endpoint_url(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.URL, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Endpoint_url(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Endpoint",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Endpoint_authSecret(ctx context.Context, field graphql.CollectedField, obj *Endpoint) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Endpoint_authSecret(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AuthSecret, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*TypedObjectReference)
	fc.Result = res
	return ec.marshalOTypedObjectReference2githubcomkubeagiarcadiaapiservergraphgeneratedTypedObjectReference(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Endpoint_authSecret(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Endpoint",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "apiGroup":
				return ec.fieldContext_TypedObjectReference_apiGroup(ctx, field)
			case "kind":
				return ec.fieldContext_TypedObjectReference_kind(ctx, field)
			case "name":
				return ec.fieldContext_TypedObjectReference_name(ctx, field)
			case "displayName":
				return ec.fieldContext_TypedObjectReference_displayName(ctx, field)
			case "namespace":
				return ec.fieldContext_TypedObjectReference_namespace(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type TypedObjectReference", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Endpoint_insecure(ctx context.Context, field graphql.CollectedField, obj *Endpoint) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Endpoint_insecure(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Insecure, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*bool)
	fc.Result = res
	return ec.marshalOBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Endpoint_insecure(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Endpoint",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _F_path(ctx context.Context, field graphql.CollectedField, obj *F) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_F_path(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Path, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_F_path(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "F",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _F_fileType(ctx context.Context, field graphql.CollectedField, obj *F) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_F_fileType(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.FileType, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_F_fileType(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "F",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _F_count(ctx context.Context, field graphql.CollectedField, obj *F) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_F_count(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Count, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_F_count(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "F",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _F_time(ctx context.Context, field graphql.CollectedField, obj *F) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_F_time(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Time, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*time.Time)
	fc.Result = res
	return ec.marshalOTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_F_time(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "F",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _F_size(ctx context.Context, field graphql.CollectedField, obj *F) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_F_size(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Size, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_F_size(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "F",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _F_creationTimestamp(ctx context.Context, field graphql.CollectedField, obj *F) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_F_creationTimestamp(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CreationTimestamp, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*time.Time)
	fc.Result = res
	return ec.marshalOTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_F_creationTimestamp(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "F",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GPT_name(ctx context.Context, field graphql.CollectedField, obj *Gpt) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GPT_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GPT_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GPT",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GPT_displayName(ctx context.Context, field graphql.CollectedField, obj *Gpt) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GPT_displayName(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DisplayName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GPT_displayName(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GPT",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GPT_description(ctx context.Context, field graphql.CollectedField, obj *Gpt) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GPT_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GPT_description(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GPT",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GPT_hot(ctx context.Context, field graphql.CollectedField, obj *Gpt) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GPT_hot(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Hot, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int64)
	fc.Result = res
	return ec.marshalOInt642int64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GPT_hot(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GPT",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int64 does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GPT_creator(ctx context.Context, field graphql.CollectedField, obj *Gpt) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GPT_creator(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Creator, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GPT_creator(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GPT",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GPT_category(ctx context.Context, field graphql.CollectedField, obj *Gpt) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GPT_category(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Category, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GPT_category(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GPT",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GPT_icon(ctx context.Context, field graphql.CollectedField, obj *Gpt) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GPT_icon(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Icon, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GPT_icon(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GPT",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GPT_prologue(ctx context.Context, field graphql.CollectedField, obj *Gpt) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GPT_prologue(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Prologue, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GPT_prologue(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GPT",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GPTQuery_getGPT(ctx context.Context, field graphql.CollectedField, obj *GPTQuery) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GPTQuery_getGPT(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.GPTQuery().GetGpt(rctx, obj, fc.Args["name"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*Gpt)
	fc.Result = res
	return ec.marshalNGPT2githubcomkubeagiarcadiaapiservergraphgeneratedGpt(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GPTQuery_getGPT(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GPTQuery",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext_GPT_name(ctx, field)
			case "displayName":
				return ec.fieldContext_GPT_displayName(ctx, field)
			case "description":
				return ec.fieldContext_GPT_description(ctx, field)
			case "hot":
				return ec.fieldContext_GPT_hot(ctx, field)
			case "creator":
				return ec.fieldContext_GPT_creator(ctx, field)
			case "category":
				return ec.fieldContext_GPT_category(ctx, field)
			case "icon":
				return ec.fieldContext_GPT_icon(ctx, field)
			case "prologue":
				return ec.fieldContext_GPT_prologue(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type GPT", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_GPTQuery_getGPT_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _GPTQuery_listGPT(ctx context.Context, field graphql.CollectedField, obj *GPTQuery) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GPTQuery_listGPT(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.GPTQuery().ListGpt(rctx, obj, fc.Args["input"].(ListGPTInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*PaginatedResult)
	fc.Result = res
	return ec.marshalNPaginatedResult2githubcomkubeagiarcadiaapiservergraphgeneratedPaginatedResult(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GPTQuery_listGPT(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GPTQuery",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "hasNextPage":
				return ec.fieldContext_PaginatedResult_hasNextPage(ctx, field)
			case "nodes":
				return ec.fieldContext_PaginatedResult_nodes(ctx, field)
			case "page":
				return ec.fieldContext_PaginatedResult_page(ctx, field)
			case "pageSize":
				return ec.fieldContext_PaginatedResult_pageSize(ctx, field)
			case "totalCount":
				return ec.fieldContext_PaginatedResult_totalCount(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type PaginatedResult", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_GPTQuery_listGPT_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _KnowledgeBase_id(ctx context.Context, field graphql.CollectedField, obj *KnowledgeBase) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_KnowledgeBase_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_KnowledgeBase_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "KnowledgeBase",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _KnowledgeBase_name(ctx context.Context, field graphql.CollectedField, obj *KnowledgeBase) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_KnowledgeBase_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_KnowledgeBase_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "KnowledgeBase",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _KnowledgeBase_namespace(ctx context.Context, field graphql.CollectedField, obj *KnowledgeBase) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_KnowledgeBase_namespace(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Namespace, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_KnowledgeBase_namespace(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "KnowledgeBase",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _KnowledgeBase_labels(ctx context.Context, field graphql.CollectedField, obj *KnowledgeBase) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_KnowledgeBase_labels(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Labels, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(map[string]interface{})
	fc.Result = res
	return ec.marshalOMap2map(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_KnowledgeBase_labels(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "KnowledgeBase",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Map does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _KnowledgeBase_annotations(ctx context.Context, field graphql.CollectedField, obj *KnowledgeBase) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_KnowledgeBase_annotations(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Annotations, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(map[string]interface{})
	fc.Result = res
	return ec.marshalOMap2map(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_KnowledgeBase_annotations(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "KnowledgeBase",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Map does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _KnowledgeBase_creator(ctx context.Context, field graphql.CollectedField, obj *KnowledgeBase) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_KnowledgeBase_creator(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Creator, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_KnowledgeBase_creator(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "KnowledgeBase",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _KnowledgeBase_displayName(ctx context.Context, field graphql.CollectedField, obj *KnowledgeBase) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_KnowledgeBase_displayName(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DisplayName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_KnowledgeBase_displayName(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "KnowledgeBase",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _KnowledgeBase_description(ctx context.Context, field graphql.CollectedField, obj *KnowledgeBase) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_KnowledgeBase_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_KnowledgeBase_description(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "KnowledgeBase",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _KnowledgeBase_creationTimestamp(ctx context.Context, field graphql.CollectedField, obj *KnowledgeBase) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_KnowledgeBase_creationTimestamp(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CreationTimestamp, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*time.Time)
	fc.Result = res
	return ec.marshalOTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_KnowledgeBase_creationTimestamp(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "KnowledgeBase",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _KnowledgeBase_updateTimestamp(ctx context.Context, field graphql.CollectedField, obj *KnowledgeBase) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_KnowledgeBase_updateTimestamp(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UpdateTimestamp, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*time.Time)
	fc.Result = res
	return ec.marshalOTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_KnowledgeBase_updateTimestamp(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "KnowledgeBase",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _KnowledgeBase_embedder(ctx context.Context, field graphql.CollectedField, obj *KnowledgeBase) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_KnowledgeBase_embedder(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Embedder, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*TypedObjectReference)
	fc.Result = res
	return ec.marshalOTypedObjectReference2githubcomkubeagiarcadiaapiservergraphgeneratedTypedObjectReference(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_KnowledgeBase_embedder(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "KnowledgeBase",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "apiGroup":
				return ec.fieldContext_TypedObjectReference_apiGroup(ctx, field)
			case "kind":
				return ec.fieldContext_TypedObjectReference_kind(ctx, field)
			case "name":
				return ec.fieldContext_TypedObjectReference_name(ctx, field)
			case "displayName":
				return ec.fieldContext_TypedObjectReference_displayName(ctx, field)
			case "namespace":
				return ec.fieldContext_TypedObjectReference_namespace(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type TypedObjectReference", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _KnowledgeBase_embedderType(ctx context.Context, field graphql.CollectedField, obj *KnowledgeBase) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_KnowledgeBase_embedderType(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.EmbedderType, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_KnowledgeBase_embedderType(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "KnowledgeBase",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _KnowledgeBase_vectorStore(ctx context.Context, field graphql.CollectedField, obj *KnowledgeBase) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_KnowledgeBase_vectorStore(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.VectorStore, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*TypedObjectReference)
	fc.Result = res
	return ec.marshalOTypedObjectReference2githubcomkubeagiarcadiaapiservergraphgeneratedTypedObjectReference(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_KnowledgeBase_vectorStore(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "KnowledgeBase",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "apiGroup":
				return ec.fieldContext_TypedObjectReference_apiGroup(ctx, field)
			case "kind":
				return ec.fieldContext_TypedObjectReference_kind(ctx, field)
			case "name":
				return ec.fieldContext_TypedObjectReference_name(ctx, field)
			case "displayName":
				return ec.fieldContext_TypedObjectReference_displayName(ctx, field)
			case "namespace":
				return ec.fieldContext_TypedObjectReference_namespace(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type TypedObjectReference", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _KnowledgeBase_fileGroupDetails(ctx context.Context, field graphql.CollectedField, obj *KnowledgeBase) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_KnowledgeBase_fileGroupDetails(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.FileGroupDetails, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*Filegroupdetail)
	fc.Result = res
	return ec.marshalOfilegroupdetail2githubcomkubeagiarcadiaapiservergraphgeneratedFilegroupdetail(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_KnowledgeBase_fileGroupDetails(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "KnowledgeBase",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "source":
				return ec.fieldContext_filegroupdetail_source(ctx, field)
			case "filedetails":
				return ec.fieldContext_filegroupdetail_filedetails(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type filegroupdetail", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _KnowledgeBase_chunkSize(ctx context.Context, field graphql.CollectedField, obj *KnowledgeBase) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_KnowledgeBase_chunkSize(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ChunkSize, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalOInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_KnowledgeBase_chunkSize(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "KnowledgeBase",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _KnowledgeBase_chunkOverlap(ctx context.Context, field graphql.CollectedField, obj *KnowledgeBase) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_KnowledgeBase_chunkOverlap(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ChunkOverlap, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalOInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_KnowledgeBase_chunkOverlap(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "KnowledgeBase",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _KnowledgeBase_batchSize(ctx context.Context, field graphql.CollectedField, obj *KnowledgeBase) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_KnowledgeBase_batchSize(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.BatchSize, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalOInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_KnowledgeBase_batchSize(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "KnowledgeBase",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _KnowledgeBase_status(ctx context.Context, field graphql.CollectedField, obj *KnowledgeBase) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_KnowledgeBase_status(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Status, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_KnowledgeBase_status(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "KnowledgeBase",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _KnowledgeBase_reason(ctx context.Context, field graphql.CollectedField, obj *KnowledgeBase) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_KnowledgeBase_reason(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Reason, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_KnowledgeBase_reason(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "KnowledgeBase",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _KnowledgeBase_message(ctx context.Context, field graphql.CollectedField, obj *KnowledgeBase) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_KnowledgeBase_message(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Message, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_KnowledgeBase_message(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "KnowledgeBase",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _KnowledgeBaseMutation_createKnowledgeBase(ctx context.Context, field graphql.CollectedField, obj *KnowledgeBaseMutation) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_KnowledgeBaseMutation_createKnowledgeBase(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.KnowledgeBaseMutation().CreateKnowledgeBase(rctx, obj, fc.Args["input"].(CreateKnowledgeBaseInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*KnowledgeBase)
	fc.Result = res
	return ec.marshalNKnowledgeBase2githubcomkubeagiarcadiaapiservergraphgeneratedKnowledgeBase(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_KnowledgeBaseMutation_createKnowledgeBase(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "KnowledgeBaseMutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_KnowledgeBase_id(ctx, field)
			case "name":
				return ec.fieldContext_KnowledgeBase_name(ctx, field)
			case "namespace":
				return ec.fieldContext_KnowledgeBase_namespace(ctx, field)
			case "labels":
				return ec.fieldContext_KnowledgeBase_labels(ctx, field)
			case "annotations":
				return ec.fieldContext_KnowledgeBase_annotations(ctx, field)
			case "creator":
				return ec.fieldContext_KnowledgeBase_creator(ctx, field)
			case "displayName":
				return ec.fieldContext_KnowledgeBase_displayName(ctx, field)
			case "description":
				return ec.fieldContext_KnowledgeBase_description(ctx, field)
			case "creationTimestamp":
				return ec.fieldContext_KnowledgeBase_creationTimestamp(ctx, field)
			case "updateTimestamp":
				return ec.fieldContext_KnowledgeBase_updateTimestamp(ctx, field)
			case "embedder":
				return ec.fieldContext_KnowledgeBase_embedder(ctx, field)
			case "embedderType":
				return ec.fieldContext_KnowledgeBase_embedderType(ctx, field)
			case "vectorStore":
				return ec.fieldContext_KnowledgeBase_vectorStore(ctx, field)
			case "fileGroupDetails":
				return ec.fieldContext_KnowledgeBase_fileGroupDetails(ctx, field)
			case "chunkSize":
				return ec.fieldContext_KnowledgeBase_chunkSize(ctx, field)
			case "chunkOverlap":
				return ec.fieldContext_KnowledgeBase_chunkOverlap(ctx, field)
			case "batchSize":
				return ec.fieldContext_KnowledgeBase_batchSize(ctx, field)
			case "status":
				return ec.fieldContext_KnowledgeBase_status(ctx, field)
			case "reason":
				return ec.fieldContext_KnowledgeBase_reason(ctx, field)
			case "message":
				return ec.fieldContext_KnowledgeBase_message(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type KnowledgeBase", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_KnowledgeBaseMutation_createKnowledgeBase_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _KnowledgeBaseMutation_updateKnowledgeBase(ctx context.Context, field graphql.CollectedField, obj *KnowledgeBaseMutation) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_KnowledgeBaseMutation_updateKnowledgeBase(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.KnowledgeBaseMutation().UpdateKnowledgeBase(rctx, obj, fc.Args["input"].(*UpdateKnowledgeBaseInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*KnowledgeBase)
	fc.Result = res
	return ec.marshalNKnowledgeBase2githubcomkubeagiarcadiaapiservergraphgeneratedKnowledgeBase(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_KnowledgeBaseMutation_updateKnowledgeBase(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "KnowledgeBaseMutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_KnowledgeBase_id(ctx, field)
			case "name":
				return ec.fieldContext_KnowledgeBase_name(ctx, field)
			case "namespace":
				return ec.fieldContext_KnowledgeBase_namespace(ctx, field)
			case "labels":
				return ec.fieldContext_KnowledgeBase_labels(ctx, field)
			case "annotations":
				return ec.fieldContext_KnowledgeBase_annotations(ctx, field)
			case "creator":
				return ec.fieldContext_KnowledgeBase_creator(ctx, field)
			case "displayName":
				return ec.fieldContext_KnowledgeBase_displayName(ctx, field)
			case "description":
				return ec.fieldContext_KnowledgeBase_description(ctx, field)
			case "creationTimestamp":
				return ec.fieldContext_KnowledgeBase_creationTimestamp(ctx, field)
			case "updateTimestamp":
				return ec.fieldContext_KnowledgeBase_updateTimestamp(ctx, field)
			case "embedder":
				return ec.fieldContext_KnowledgeBase_embedder(ctx, field)
			case "embedderType":
				return ec.fieldContext_KnowledgeBase_embedderType(ctx, field)
			case "vectorStore":
				return ec.fieldContext_KnowledgeBase_vectorStore(ctx, field)
			case "fileGroupDetails":
				return ec.fieldContext_KnowledgeBase_fileGroupDetails(ctx, field)
			case "chunkSize":
				return ec.fieldContext_KnowledgeBase_chunkSize(ctx, field)
			case "chunkOverlap":
				return ec.fieldContext_KnowledgeBase_chunkOverlap(ctx, field)
			case "batchSize":
				return ec.fieldContext_KnowledgeBase_batchSize(ctx, field)
			case "status":
				return ec.fieldContext_KnowledgeBase_status(ctx, field)
			case "reason":
				return ec.fieldContext_KnowledgeBase_reason(ctx, field)
			case "message":
				return ec.fieldContext_KnowledgeBase_message(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type KnowledgeBase", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_KnowledgeBaseMutation_updateKnowledgeBase_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _KnowledgeBaseMutation_deleteKnowledgeBase(ctx context.Context, field graphql.CollectedField, obj *KnowledgeBaseMutation) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_KnowledgeBaseMutation_deleteKnowledgeBase(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.KnowledgeBaseMutation().DeleteKnowledgeBase(rctx, obj, fc.Args["input"].(*DeleteCommonInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOVoid2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_KnowledgeBaseMutation_deleteKnowledgeBase(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "KnowledgeBaseMutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Void does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_KnowledgeBaseMutation_deleteKnowledgeBase_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _KnowledgeBaseQuery_getKnowledgeBase(ctx context.Context, field graphql.CollectedField, obj *KnowledgeBaseQuery) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_KnowledgeBaseQuery_getKnowledgeBase(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.KnowledgeBaseQuery().GetKnowledgeBase(rctx, obj, fc.Args["name"].(string), fc.Args["namespace"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*KnowledgeBase)
	fc.Result = res
	return ec.marshalNKnowledgeBase2githubcomkubeagiarcadiaapiservergraphgeneratedKnowledgeBase(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_KnowledgeBaseQuery_getKnowledgeBase(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "KnowledgeBaseQuery",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_KnowledgeBase_id(ctx, field)
			case "name":
				return ec.fieldContext_KnowledgeBase_name(ctx, field)
			case "namespace":
				return ec.fieldContext_KnowledgeBase_namespace(ctx, field)
			case "labels":
				return ec.fieldContext_KnowledgeBase_labels(ctx, field)
			case "annotations":
				return ec.fieldContext_KnowledgeBase_annotations(ctx, field)
			case "creator":
				return ec.fieldContext_KnowledgeBase_creator(ctx, field)
			case "displayName":
				return ec.fieldContext_KnowledgeBase_displayName(ctx, field)
			case "description":
				return ec.fieldContext_KnowledgeBase_description(ctx, field)
			case "creationTimestamp":
				return ec.fieldContext_KnowledgeBase_creationTimestamp(ctx, field)
			case "updateTimestamp":
				return ec.fieldContext_KnowledgeBase_updateTimestamp(ctx, field)
			case "embedder":
				return ec.fieldContext_KnowledgeBase_embedder(ctx, field)
			case "embedderType":
				return ec.fieldContext_KnowledgeBase_embedderType(ctx, field)
			case "vectorStore":
				return ec.fieldContext_KnowledgeBase_vectorStore(ctx, field)
			case "fileGroupDetails":
				return ec.fieldContext_KnowledgeBase_fileGroupDetails(ctx, field)
			case "chunkSize":
				return ec.fieldContext_KnowledgeBase_chunkSize(ctx, field)
			case "chunkOverlap":
				return ec.fieldContext_KnowledgeBase_chunkOverlap(ctx, field)
			case "batchSize":
				return ec.fieldContext_KnowledgeBase_batchSize(ctx, field)
			case "status":
				return ec.fieldContext_KnowledgeBase_status(ctx, field)
			case "reason":
				return ec.fieldContext_KnowledgeBase_reason(ctx, field)
			case "message":
				return ec.fieldContext_KnowledgeBase_message(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type KnowledgeBase", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_KnowledgeBaseQuery_getKnowledgeBase_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _KnowledgeBaseQuery_listKnowledgeBases(ctx context.Context, field graphql.CollectedField, obj *KnowledgeBaseQuery) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_KnowledgeBaseQuery_listKnowledgeBases(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.KnowledgeBaseQuery().ListKnowledgeBases(rctx, obj, fc.Args["input"].(ListKnowledgeBaseInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*PaginatedResult)
	fc.Result = res
	return ec.marshalNPaginatedResult2githubcomkubeagiarcadiaapiservergraphgeneratedPaginatedResult(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_KnowledgeBaseQuery_listKnowledgeBases(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "KnowledgeBaseQuery",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "hasNextPage":
				return ec.fieldContext_PaginatedResult_hasNextPage(ctx, field)
			case "nodes":
				return ec.fieldContext_PaginatedResult_nodes(ctx, field)
			case "page":
				return ec.fieldContext_PaginatedResult_page(ctx, field)
			case "pageSize":
				return ec.fieldContext_PaginatedResult_pageSize(ctx, field)
			case "totalCount":
				return ec.fieldContext_PaginatedResult_totalCount(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type PaginatedResult", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_KnowledgeBaseQuery_listKnowledgeBases_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _LLM_id(ctx context.Context, field graphql.CollectedField, obj *Llm) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_LLM_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_LLM_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "LLM",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _LLM_name(ctx context.Context, field graphql.CollectedField, obj *Llm) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_LLM_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_LLM_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "LLM",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _LLM_namespace(ctx context.Context, field graphql.CollectedField, obj *Llm) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_LLM_namespace(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Namespace, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_LLM_namespace(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "LLM",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _LLM_labels(ctx context.Context, field graphql.CollectedField, obj *Llm) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_LLM_labels(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Labels, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(map[string]interface{})
	fc.Result = res
	return ec.marshalOMap2map(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_LLM_labels(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "LLM",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Map does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _LLM_annotations(ctx context.Context, field graphql.CollectedField, obj *Llm) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_LLM_annotations(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Annotations, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(map[string]interface{})
	fc.Result = res
	return ec.marshalOMap2map(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_LLM_annotations(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "LLM",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Map does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _LLM_creator(ctx context.Context, field graphql.CollectedField, obj *Llm) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_LLM_creator(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Creator, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_LLM_creator(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "LLM",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _LLM_displayName(ctx context.Context, field graphql.CollectedField, obj *Llm) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_LLM_displayName(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DisplayName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_LLM_displayName(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "LLM",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _LLM_description(ctx context.Context, field graphql.CollectedField, obj *Llm) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_LLM_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_LLM_description(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "LLM",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _LLM_baseUrl(ctx context.Context, field graphql.CollectedField, obj *Llm) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_LLM_baseUrl(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.BaseURL, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_LLM_baseUrl(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "LLM",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _LLM_models(ctx context.Context, field graphql.CollectedField, obj *Llm) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_LLM_models(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Models, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_LLM_models(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "LLM",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _LLM_provider(ctx context.Context, field graphql.CollectedField, obj *Llm) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_LLM_provider(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Provider, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_LLM_provider(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "LLM",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _LLM_type(ctx context.Context, field graphql.CollectedField, obj *Llm) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_LLM_type(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Type, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_LLM_type(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "LLM",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _LLM_creationTimestamp(ctx context.Context, field graphql.CollectedField, obj *Llm) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_LLM_creationTimestamp(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CreationTimestamp, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*time.Time)
	fc.Result = res
	return ec.marshalOTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_LLM_creationTimestamp(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "LLM",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _LLM_updateTimestamp(ctx context.Context, field graphql.CollectedField, obj *Llm) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_LLM_updateTimestamp(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UpdateTimestamp, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*time.Time)
	fc.Result = res
	return ec.marshalOTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_LLM_updateTimestamp(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "LLM",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _LLM_status(ctx context.Context, field graphql.CollectedField, obj *Llm) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_LLM_status(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Status, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_LLM_status(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "LLM",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _LLM_message(ctx context.Context, field graphql.CollectedField, obj *Llm) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_LLM_message(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Message, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_LLM_message(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "LLM",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _LLMConfig_name(ctx context.Context, field graphql.CollectedField, obj *LLMConfig) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_LLMConfig_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_LLMConfig_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "LLMConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _LLMConfig_namespace(ctx context.Context, field graphql.CollectedField, obj *LLMConfig) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_LLMConfig_namespace(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Namespace, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_LLMConfig_namespace(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "LLMConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _LLMConfig_model(ctx context.Context, field graphql.CollectedField, obj *LLMConfig) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_LLMConfig_model(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Model, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_LLMConfig_model(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "LLMConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _LLMConfig_temperature(ctx context.Context, field graphql.CollectedField, obj *LLMConfig) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_LLMConfig_temperature(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Temperature, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_LLMConfig_temperature(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "LLMConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _LLMConfig_top_p(ctx context.Context, field graphql.CollectedField, obj *LLMConfig) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_LLMConfig_top_p(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TopP, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_LLMConfig_top_p(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "LLMConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _LLMConfig_max_tokens(ctx context.Context, field graphql.CollectedField, obj *LLMConfig) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_LLMConfig_max_tokens(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MaxTokens, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_LLMConfig_max_tokens(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "LLMConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _LLMConfig_prompt_template(ctx context.Context, field graphql.CollectedField, obj *LLMConfig) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_LLMConfig_prompt_template(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PromptTemplate, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_LLMConfig_prompt_template(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "LLMConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _LLMConfig_provider(ctx context.Context, field graphql.CollectedField, obj *LLMConfig) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_LLMConfig_provider(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Provider, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_LLMConfig_provider(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "LLMConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _LLMQuery_getLLM(ctx context.Context, field graphql.CollectedField, obj *LLMQuery) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_LLMQuery_getLLM(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.LLMQuery().GetLlm(rctx, obj, fc.Args["name"].(string), fc.Args["namespace"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*Llm)
	fc.Result = res
	return ec.marshalNLLM2githubcomkubeagiarcadiaapiservergraphgeneratedLlm(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_LLMQuery_getLLM(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "LLMQuery",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_LLM_id(ctx, field)
			case "name":
				return ec.fieldContext_LLM_name(ctx, field)
			case "namespace":
				return ec.fieldContext_LLM_namespace(ctx, field)
			case "labels":
				return ec.fieldContext_LLM_labels(ctx, field)
			case "annotations":
				return ec.fieldContext_LLM_annotations(ctx, field)
			case "creator":
				return ec.fieldContext_LLM_creator(ctx, field)
			case "displayName":
				return ec.fieldContext_LLM_displayName(ctx, field)
			case "description":
				return ec.fieldContext_LLM_description(ctx, field)
			case "baseUrl":
				return ec.fieldContext_LLM_baseUrl(ctx, field)
			case "models":
				return ec.fieldContext_LLM_models(ctx, field)
			case "provider":
				return ec.fieldContext_LLM_provider(ctx, field)
			case "type":
				return ec.fieldContext_LLM_type(ctx, field)
			case "creationTimestamp":
				return ec.fieldContext_LLM_creationTimestamp(ctx, field)
			case "updateTimestamp":
				return ec.fieldContext_LLM_updateTimestamp(ctx, field)
			case "status":
				return ec.fieldContext_LLM_status(ctx, field)
			case "message":
				return ec.fieldContext_LLM_message(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type LLM", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_LLMQuery_getLLM_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _LLMQuery_listLLMs(ctx context.Context, field graphql.CollectedField, obj *LLMQuery) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_LLMQuery_listLLMs(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.LLMQuery().ListLLMs(rctx, obj, fc.Args["input"].(ListCommonInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*PaginatedResult)
	fc.Result = res
	return ec.marshalNPaginatedResult2githubcomkubeagiarcadiaapiservergraphgeneratedPaginatedResult(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_LLMQuery_listLLMs(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "LLMQuery",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "hasNextPage":
				return ec.fieldContext_PaginatedResult_hasNextPage(ctx, field)
			case "nodes":
				return ec.fieldContext_PaginatedResult_nodes(ctx, field)
			case "page":
				return ec.fieldContext_PaginatedResult_page(ctx, field)
			case "pageSize":
				return ec.fieldContext_PaginatedResult_pageSize(ctx, field)
			case "totalCount":
				return ec.fieldContext_PaginatedResult_totalCount(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type PaginatedResult", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_LLMQuery_listLLMs_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _LabelSelectorRequirement_key(ctx context.Context, field graphql.CollectedField, obj *LabelSelectorRequirement) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_LabelSelectorRequirement_key(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Key, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_LabelSelectorRequirement_key(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "LabelSelectorRequirement",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _LabelSelectorRequirement_values(ctx context.Context, field graphql.CollectedField, obj *LabelSelectorRequirement) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_LabelSelectorRequirement_values(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Values, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_LabelSelectorRequirement_values(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "LabelSelectorRequirement",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _LabelSelectorRequirement_operator(ctx context.Context, field graphql.CollectedField, obj *LabelSelectorRequirement) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_LabelSelectorRequirement_operator(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Operator, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_LabelSelectorRequirement_operator(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "LabelSelectorRequirement",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Model_id(ctx context.Context, field graphql.CollectedField, obj *Model) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Model_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Model_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Model",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Model_name(ctx context.Context, field graphql.CollectedField, obj *Model) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Model_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Model_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Model",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Model_namespace(ctx context.Context, field graphql.CollectedField, obj *Model) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Model_namespace(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Namespace, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Model_namespace(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Model",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Model_systemModel(ctx context.Context, field graphql.CollectedField, obj *Model) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Model_systemModel(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SystemModel, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*bool)
	fc.Result = res
	return ec.marshalOBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Model_systemModel(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Model",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Model_labels(ctx context.Context, field graphql.CollectedField, obj *Model) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Model_labels(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Labels, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(map[string]interface{})
	fc.Result = res
	return ec.marshalOMap2map(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Model_labels(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Model",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Map does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Model_annotations(ctx context.Context, field graphql.CollectedField, obj *Model) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Model_annotations(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Annotations, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(map[string]interface{})
	fc.Result = res
	return ec.marshalOMap2map(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Model_annotations(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Model",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Map does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Model_creator(ctx context.Context, field graphql.CollectedField, obj *Model) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Model_creator(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Creator, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Model_creator(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Model",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Model_displayName(ctx context.Context, field graphql.CollectedField, obj *Model) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Model_displayName(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DisplayName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Model_displayName(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Model",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Model_description(ctx context.Context, field graphql.CollectedField, obj *Model) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Model_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Model_description(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Model",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Model_creationTimestamp(ctx context.Context, field graphql.CollectedField, obj *Model) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Model_creationTimestamp(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CreationTimestamp, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*time.Time)
	fc.Result = res
	return ec.marshalOTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Model_creationTimestamp(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Model",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Model_updateTimestamp(ctx context.Context, field graphql.CollectedField, obj *Model) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Model_updateTimestamp(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UpdateTimestamp, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*time.Time)
	fc.Result = res
	return ec.marshalOTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Model_updateTimestamp(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Model",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Model_types(ctx context.Context, field graphql.CollectedField, obj *Model) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Model_types(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Types, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Model_types(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Model",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Model_status(ctx context.Context, field graphql.CollectedField, obj *Model) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Model_status(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Status, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Model_status(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Model",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Model_message(ctx context.Context, field graphql.CollectedField, obj *Model) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Model_message(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Message, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Model_message(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Model",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Model_files(ctx context.Context, field graphql.CollectedField, obj *Model) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Model_files(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Model().Files(rctx, obj, fc.Args["input"].(*FileFilter))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*PaginatedResult)
	fc.Result = res
	return ec.marshalNPaginatedResult2githubcomkubeagiarcadiaapiservergraphgeneratedPaginatedResult(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Model_files(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Model",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "hasNextPage":
				return ec.fieldContext_PaginatedResult_hasNextPage(ctx, field)
			case "nodes":
				return ec.fieldContext_PaginatedResult_nodes(ctx, field)
			case "page":
				return ec.fieldContext_PaginatedResult_page(ctx, field)
			case "pageSize":
				return ec.fieldContext_PaginatedResult_pageSize(ctx, field)
			case "totalCount":
				return ec.fieldContext_PaginatedResult_totalCount(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type PaginatedResult", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Model_files_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Model_huggingFaceRepo(ctx context.Context, field graphql.CollectedField, obj *Model) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Model_huggingFaceRepo(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.HuggingFaceRepo, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Model_huggingFaceRepo(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Model",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Model_modelScopeRepo(ctx context.Context, field graphql.CollectedField, obj *Model) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Model_modelScopeRepo(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ModelScopeRepo, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Model_modelScopeRepo(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Model",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Model_revision(ctx context.Context, field graphql.CollectedField, obj *Model) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Model_revision(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Revision, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Model_revision(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Model",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Model_modelSource(ctx context.Context, field graphql.CollectedField, obj *Model) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Model_modelSource(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ModelSource, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Model_modelSource(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Model",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ModelMutation_createModel(ctx context.Context, field graphql.CollectedField, obj *ModelMutation) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ModelMutation_createModel(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.ModelMutation().CreateModel(rctx, obj, fc.Args["input"].(CreateModelInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*Model)
	fc.Result = res
	return ec.marshalNModel2githubcomkubeagiarcadiaapiservergraphgeneratedModel(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ModelMutation_createModel(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ModelMutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Model_id(ctx, field)
			case "name":
				return ec.fieldContext_Model_name(ctx, field)
			case "namespace":
				return ec.fieldContext_Model_namespace(ctx, field)
			case "systemModel":
				return ec.fieldContext_Model_systemModel(ctx, field)
			case "labels":
				return ec.fieldContext_Model_labels(ctx, field)
			case "annotations":
				return ec.fieldContext_Model_annotations(ctx, field)
			case "creator":
				return ec.fieldContext_Model_creator(ctx, field)
			case "displayName":
				return ec.fieldContext_Model_displayName(ctx, field)
			case "description":
				return ec.fieldContext_Model_description(ctx, field)
			case "creationTimestamp":
				return ec.fieldContext_Model_creationTimestamp(ctx, field)
			case "updateTimestamp":
				return ec.fieldContext_Model_updateTimestamp(ctx, field)
			case "types":
				return ec.fieldContext_Model_types(ctx, field)
			case "status":
				return ec.fieldContext_Model_status(ctx, field)
			case "message":
				return ec.fieldContext_Model_message(ctx, field)
			case "files":
				return ec.fieldContext_Model_files(ctx, field)
			case "huggingFaceRepo":
				return ec.fieldContext_Model_huggingFaceRepo(ctx, field)
			case "modelScopeRepo":
				return ec.fieldContext_Model_modelScopeRepo(ctx, field)
			case "revision":
				return ec.fieldContext_Model_revision(ctx, field)
			case "modelSource":
				return ec.fieldContext_Model_modelSource(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Model", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_ModelMutation_createModel_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _ModelMutation_updateModel(ctx context.Context, field graphql.CollectedField, obj *ModelMutation) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ModelMutation_updateModel(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.ModelMutation().UpdateModel(rctx, obj, fc.Args["input"].(*UpdateModelInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*Model)
	fc.Result = res
	return ec.marshalNModel2githubcomkubeagiarcadiaapiservergraphgeneratedModel(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ModelMutation_updateModel(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ModelMutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Model_id(ctx, field)
			case "name":
				return ec.fieldContext_Model_name(ctx, field)
			case "namespace":
				return ec.fieldContext_Model_namespace(ctx, field)
			case "systemModel":
				return ec.fieldContext_Model_systemModel(ctx, field)
			case "labels":
				return ec.fieldContext_Model_labels(ctx, field)
			case "annotations":
				return ec.fieldContext_Model_annotations(ctx, field)
			case "creator":
				return ec.fieldContext_Model_creator(ctx, field)
			case "displayName":
				return ec.fieldContext_Model_displayName(ctx, field)
			case "description":
				return ec.fieldContext_Model_description(ctx, field)
			case "creationTimestamp":
				return ec.fieldContext_Model_creationTimestamp(ctx, field)
			case "updateTimestamp":
				return ec.fieldContext_Model_updateTimestamp(ctx, field)
			case "types":
				return ec.fieldContext_Model_types(ctx, field)
			case "status":
				return ec.fieldContext_Model_status(ctx, field)
			case "message":
				return ec.fieldContext_Model_message(ctx, field)
			case "files":
				return ec.fieldContext_Model_files(ctx, field)
			case "huggingFaceRepo":
				return ec.fieldContext_Model_huggingFaceRepo(ctx, field)
			case "modelScopeRepo":
				return ec.fieldContext_Model_modelScopeRepo(ctx, field)
			case "revision":
				return ec.fieldContext_Model_revision(ctx, field)
			case "modelSource":
				return ec.fieldContext_Model_modelSource(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Model", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_ModelMutation_updateModel_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _ModelMutation_deleteModels(ctx context.Context, field graphql.CollectedField, obj *ModelMutation) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ModelMutation_deleteModels(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.ModelMutation().DeleteModels(rctx, obj, fc.Args["input"].(*DeleteCommonInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOVoid2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ModelMutation_deleteModels(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ModelMutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Void does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_ModelMutation_deleteModels_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _ModelQuery_getModel(ctx context.Context, field graphql.CollectedField, obj *ModelQuery) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ModelQuery_getModel(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.ModelQuery().GetModel(rctx, obj, fc.Args["name"].(string), fc.Args["namespace"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*Model)
	fc.Result = res
	return ec.marshalNModel2githubcomkubeagiarcadiaapiservergraphgeneratedModel(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ModelQuery_getModel(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ModelQuery",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Model_id(ctx, field)
			case "name":
				return ec.fieldContext_Model_name(ctx, field)
			case "namespace":
				return ec.fieldContext_Model_namespace(ctx, field)
			case "systemModel":
				return ec.fieldContext_Model_systemModel(ctx, field)
			case "labels":
				return ec.fieldContext_Model_labels(ctx, field)
			case "annotations":
				return ec.fieldContext_Model_annotations(ctx, field)
			case "creator":
				return ec.fieldContext_Model_creator(ctx, field)
			case "displayName":
				return ec.fieldContext_Model_displayName(ctx, field)
			case "description":
				return ec.fieldContext_Model_description(ctx, field)
			case "creationTimestamp":
				return ec.fieldContext_Model_creationTimestamp(ctx, field)
			case "updateTimestamp":
				return ec.fieldContext_Model_updateTimestamp(ctx, field)
			case "types":
				return ec.fieldContext_Model_types(ctx, field)
			case "status":
				return ec.fieldContext_Model_status(ctx, field)
			case "message":
				return ec.fieldContext_Model_message(ctx, field)
			case "files":
				return ec.fieldContext_Model_files(ctx, field)
			case "huggingFaceRepo":
				return ec.fieldContext_Model_huggingFaceRepo(ctx, field)
			case "modelScopeRepo":
				return ec.fieldContext_Model_modelScopeRepo(ctx, field)
			case "revision":
				return ec.fieldContext_Model_revision(ctx, field)
			case "modelSource":
				return ec.fieldContext_Model_modelSource(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Model", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_ModelQuery_getModel_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _ModelQuery_listModels(ctx context.Context, field graphql.CollectedField, obj *ModelQuery) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ModelQuery_listModels(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.ModelQuery().ListModels(rctx, obj, fc.Args["input"].(ListModelInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*PaginatedResult)
	fc.Result = res
	return ec.marshalNPaginatedResult2githubcomkubeagiarcadiaapiservergraphgeneratedPaginatedResult(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ModelQuery_listModels(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ModelQuery",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "hasNextPage":
				return ec.fieldContext_PaginatedResult_hasNextPage(ctx, field)
			case "nodes":
				return ec.fieldContext_PaginatedResult_nodes(ctx, field)
			case "page":
				return ec.fieldContext_PaginatedResult_page(ctx, field)
			case "pageSize":
				return ec.fieldContext_PaginatedResult_pageSize(ctx, field)
			case "totalCount":
				return ec.fieldContext_PaginatedResult_totalCount(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type PaginatedResult", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_ModelQuery_listModels_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _ModelService_id(ctx context.Context, field graphql.CollectedField, obj *ModelService) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ModelService_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ModelService_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ModelService",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ModelService_name(ctx context.Context, field graphql.CollectedField, obj *ModelService) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ModelService_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ModelService_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ModelService",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ModelService_namespace(ctx context.Context, field graphql.CollectedField, obj *ModelService) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ModelService_namespace(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Namespace, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ModelService_namespace(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ModelService",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ModelService_labels(ctx context.Context, field graphql.CollectedField, obj *ModelService) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ModelService_labels(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Labels, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(map[string]interface{})
	fc.Result = res
	return ec.marshalOMap2map(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ModelService_labels(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ModelService",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Map does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ModelService_annotations(ctx context.Context, field graphql.CollectedField, obj *ModelService) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ModelService_annotations(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Annotations, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(map[string]interface{})
	fc.Result = res
	return ec.marshalOMap2map(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ModelService_annotations(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ModelService",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Map does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ModelService_creator(ctx context.Context, field graphql.CollectedField, obj *ModelService) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ModelService_creator(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Creator, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ModelService_creator(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ModelService",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ModelService_displayName(ctx context.Context, field graphql.CollectedField, obj *ModelService) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ModelService_displayName(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DisplayName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ModelService_displayName(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ModelService",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ModelService_description(ctx context.Context, field graphql.CollectedField, obj *ModelService) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ModelService_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ModelService_description(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ModelService",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ModelService_creationTimestamp(ctx context.Context, field graphql.CollectedField, obj *ModelService) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ModelService_creationTimestamp(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CreationTimestamp, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*time.Time)
	fc.Result = res
	return ec.marshalOTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ModelService_creationTimestamp(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ModelService",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ModelService_updateTimestamp(ctx context.Context, field graphql.CollectedField, obj *ModelService) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ModelService_updateTimestamp(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UpdateTimestamp, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*time.Time)
	fc.Result = res
	return ec.marshalOTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ModelService_updateTimestamp(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ModelService",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ModelService_providerType(ctx context.Context, field graphql.CollectedField, obj *ModelService) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ModelService_providerType(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ProviderType, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ModelService_providerType(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ModelService",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ModelService_types(ctx context.Context, field graphql.CollectedField, obj *ModelService) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ModelService_types(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Types, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ModelService_types(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ModelService",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ModelService_apiType(ctx context.Context, field graphql.CollectedField, obj *ModelService) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ModelService_apiType(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.APIType, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ModelService_apiType(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ModelService",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ModelService_llmModels(ctx context.Context, field graphql.CollectedField, obj *ModelService) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ModelService_llmModels(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.LlmModels, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ModelService_llmModels(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ModelService",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ModelService_embeddingModels(ctx context.Context, field graphql.CollectedField, obj *ModelService) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ModelService_embeddingModels(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.EmbeddingModels, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ModelService_embeddingModels(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ModelService",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ModelService_baseUrl(ctx context.Context, field graphql.CollectedField, obj *ModelService) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ModelService_baseUrl(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.BaseURL, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ModelService_baseUrl(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ModelService",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ModelService_status(ctx context.Context, field graphql.CollectedField, obj *ModelService) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ModelService_status(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Status, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ModelService_status(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ModelService",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ModelService_message(ctx context.Context, field graphql.CollectedField, obj *ModelService) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ModelService_message(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Message, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ModelService_message(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ModelService",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ModelServiceMutation_createModelService(ctx context.Context, field graphql.CollectedField, obj *ModelServiceMutation) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ModelServiceMutation_createModelService(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.ModelServiceMutation().CreateModelService(rctx, obj, fc.Args["input"].(CreateModelServiceInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*ModelService)
	fc.Result = res
	return ec.marshalNModelService2githubcomkubeagiarcadiaapiservergraphgeneratedModelService(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ModelServiceMutation_createModelService(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ModelServiceMutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_ModelService_id(ctx, field)
			case "name":
				return ec.fieldContext_ModelService_name(ctx, field)
			case "namespace":
				return ec.fieldContext_ModelService_namespace(ctx, field)
			case "labels":
				return ec.fieldContext_ModelService_labels(ctx, field)
			case "annotations":
				return ec.fieldContext_ModelService_annotations(ctx, field)
			case "creator":
				return ec.fieldContext_ModelService_creator(ctx, field)
			case "displayName":
				return ec.fieldContext_ModelService_displayName(ctx, field)
			case "description":
				return ec.fieldContext_ModelService_description(ctx, field)
			case "creationTimestamp":
				return ec.fieldContext_ModelService_creationTimestamp(ctx, field)
			case "updateTimestamp":
				return ec.fieldContext_ModelService_updateTimestamp(ctx, field)
			case "providerType":
				return ec.fieldContext_ModelService_providerType(ctx, field)
			case "types":
				return ec.fieldContext_ModelService_types(ctx, field)
			case "apiType":
				return ec.fieldContext_ModelService_apiType(ctx, field)
			case "llmModels":
				return ec.fieldContext_ModelService_llmModels(ctx, field)
			case "embeddingModels":
				return ec.fieldContext_ModelService_embeddingModels(ctx, field)
			case "baseUrl":
				return ec.fieldContext_ModelService_baseUrl(ctx, field)
			case "status":
				return ec.fieldContext_ModelService_status(ctx, field)
			case "message":
				return ec.fieldContext_ModelService_message(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ModelService", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_ModelServiceMutation_createModelService_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _ModelServiceMutation_updateModelService(ctx context.Context, field graphql.CollectedField, obj *ModelServiceMutation) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ModelServiceMutation_updateModelService(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.ModelServiceMutation().UpdateModelService(rctx, obj, fc.Args["input"].(*UpdateModelServiceInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*ModelService)
	fc.Result = res
	return ec.marshalNModelService2githubcomkubeagiarcadiaapiservergraphgeneratedModelService(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ModelServiceMutation_updateModelService(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ModelServiceMutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_ModelService_id(ctx, field)
			case "name":
				return ec.fieldContext_ModelService_name(ctx, field)
			case "namespace":
				return ec.fieldContext_ModelService_namespace(ctx, field)
			case "labels":
				return ec.fieldContext_ModelService_labels(ctx, field)
			case "annotations":
				return ec.fieldContext_ModelService_annotations(ctx, field)
			case "creator":
				return ec.fieldContext_ModelService_creator(ctx, field)
			case "displayName":
				return ec.fieldContext_ModelService_displayName(ctx, field)
			case "description":
				return ec.fieldContext_ModelService_description(ctx, field)
			case "creationTimestamp":
				return ec.fieldContext_ModelService_creationTimestamp(ctx, field)
			case "updateTimestamp":
				return ec.fieldContext_ModelService_updateTimestamp(ctx, field)
			case "providerType":
				return ec.fieldContext_ModelService_providerType(ctx, field)
			case "types":
				return ec.fieldContext_ModelService_types(ctx, field)
			case "apiType":
				return ec.fieldContext_ModelService_apiType(ctx, field)
			case "llmModels":
				return ec.fieldContext_ModelService_llmModels(ctx, field)
			case "embeddingModels":
				return ec.fieldContext_ModelService_embeddingModels(ctx, field)
			case "baseUrl":
				return ec.fieldContext_ModelService_baseUrl(ctx, field)
			case "status":
				return ec.fieldContext_ModelService_status(ctx, field)
			case "message":
				return ec.fieldContext_ModelService_message(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ModelService", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_ModelServiceMutation_updateModelService_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _ModelServiceMutation_deleteModelService(ctx context.Context, field graphql.CollectedField, obj *ModelServiceMutation) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ModelServiceMutation_deleteModelService(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.ModelServiceMutation().DeleteModelService(rctx, obj, fc.Args["input"].(*DeleteCommonInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOVoid2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ModelServiceMutation_deleteModelService(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ModelServiceMutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Void does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_ModelServiceMutation_deleteModelService_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _ModelServiceQuery_getModelService(ctx context.Context, field graphql.CollectedField, obj *ModelServiceQuery) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ModelServiceQuery_getModelService(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.ModelServiceQuery().GetModelService(rctx, obj, fc.Args["name"].(string), fc.Args["namespace"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*ModelService)
	fc.Result = res
	return ec.marshalNModelService2githubcomkubeagiarcadiaapiservergraphgeneratedModelService(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ModelServiceQuery_getModelService(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ModelServiceQuery",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_ModelService_id(ctx, field)
			case "name":
				return ec.fieldContext_ModelService_name(ctx, field)
			case "namespace":
				return ec.fieldContext_ModelService_namespace(ctx, field)
			case "labels":
				return ec.fieldContext_ModelService_labels(ctx, field)
			case "annotations":
				return ec.fieldContext_ModelService_annotations(ctx, field)
			case "creator":
				return ec.fieldContext_ModelService_creator(ctx, field)
			case "displayName":
				return ec.fieldContext_ModelService_displayName(ctx, field)
			case "description":
				return ec.fieldContext_ModelService_description(ctx, field)
			case "creationTimestamp":
				return ec.fieldContext_ModelService_creationTimestamp(ctx, field)
			case "updateTimestamp":
				return ec.fieldContext_ModelService_updateTimestamp(ctx, field)
			case "providerType":
				return ec.fieldContext_ModelService_providerType(ctx, field)
			case "types":
				return ec.fieldContext_ModelService_types(ctx, field)
			case "apiType":
				return ec.fieldContext_ModelService_apiType(ctx, field)
			case "llmModels":
				return ec.fieldContext_ModelService_llmModels(ctx, field)
			case "embeddingModels":
				return ec.fieldContext_ModelService_embeddingModels(ctx, field)
			case "baseUrl":
				return ec.fieldContext_ModelService_baseUrl(ctx, field)
			case "status":
				return ec.fieldContext_ModelService_status(ctx, field)
			case "message":
				return ec.fieldContext_ModelService_message(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ModelService", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_ModelServiceQuery_getModelService_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _ModelServiceQuery_listModelServices(ctx context.Context, field graphql.CollectedField, obj *ModelServiceQuery) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ModelServiceQuery_listModelServices(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.ModelServiceQuery().ListModelServices(rctx, obj, fc.Args["input"].(*ListModelServiceInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*PaginatedResult)
	fc.Result = res
	return ec.marshalNPaginatedResult2githubcomkubeagiarcadiaapiservergraphgeneratedPaginatedResult(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ModelServiceQuery_listModelServices(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ModelServiceQuery",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "hasNextPage":
				return ec.fieldContext_PaginatedResult_hasNextPage(ctx, field)
			case "nodes":
				return ec.fieldContext_PaginatedResult_nodes(ctx, field)
			case "page":
				return ec.fieldContext_PaginatedResult_page(ctx, field)
			case "pageSize":
				return ec.fieldContext_PaginatedResult_pageSize(ctx, field)
			case "totalCount":
				return ec.fieldContext_PaginatedResult_totalCount(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type PaginatedResult", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_ModelServiceQuery_listModelServices_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _ModelServiceQuery_checkModelService(ctx context.Context, field graphql.CollectedField, obj *ModelServiceQuery) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ModelServiceQuery_checkModelService(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.ModelServiceQuery().CheckModelService(rctx, obj, fc.Args["input"].(CreateModelServiceInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*ModelService)
	fc.Result = res
	return ec.marshalNModelService2githubcomkubeagiarcadiaapiservergraphgeneratedModelService(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ModelServiceQuery_checkModelService(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ModelServiceQuery",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_ModelService_id(ctx, field)
			case "name":
				return ec.fieldContext_ModelService_name(ctx, field)
			case "namespace":
				return ec.fieldContext_ModelService_namespace(ctx, field)
			case "labels":
				return ec.fieldContext_ModelService_labels(ctx, field)
			case "annotations":
				return ec.fieldContext_ModelService_annotations(ctx, field)
			case "creator":
				return ec.fieldContext_ModelService_creator(ctx, field)
			case "displayName":
				return ec.fieldContext_ModelService_displayName(ctx, field)
			case "description":
				return ec.fieldContext_ModelService_description(ctx, field)
			case "creationTimestamp":
				return ec.fieldContext_ModelService_creationTimestamp(ctx, field)
			case "updateTimestamp":
				return ec.fieldContext_ModelService_updateTimestamp(ctx, field)
			case "providerType":
				return ec.fieldContext_ModelService_providerType(ctx, field)
			case "types":
				return ec.fieldContext_ModelService_types(ctx, field)
			case "apiType":
				return ec.fieldContext_ModelService_apiType(ctx, field)
			case "llmModels":
				return ec.fieldContext_ModelService_llmModels(ctx, field)
			case "embeddingModels":
				return ec.fieldContext_ModelService_embeddingModels(ctx, field)
			case "baseUrl":
				return ec.fieldContext_ModelService_baseUrl(ctx, field)
			case "status":
				return ec.fieldContext_ModelService_status(ctx, field)
			case "message":
				return ec.fieldContext_ModelService_message(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ModelService", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_ModelServiceQuery_checkModelService_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_hello(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_hello(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().Hello(rctx, fc.Args["name"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_hello(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_hello_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_Application(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_Application(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().Application(rctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*ApplicationMutation)
	fc.Result = res
	return ec.marshalOApplicationMutation2githubcomkubeagiarcadiaapiservergraphgeneratedApplicationMutation(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_Application(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "createApplication":
				return ec.fieldContext_ApplicationMutation_createApplication(ctx, field)
			case "updateApplication":
				return ec.fieldContext_ApplicationMutation_updateApplication(ctx, field)
			case "deleteApplication":
				return ec.fieldContext_ApplicationMutation_deleteApplication(ctx, field)
			case "updateApplicationConfig":
				return ec.fieldContext_ApplicationMutation_updateApplicationConfig(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ApplicationMutation", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_dataProcess(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_dataProcess(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().DataProcess(rctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*DataProcessMutation)
	fc.Result = res
	return ec.marshalODataProcessMutation2githubcomkubeagiarcadiaapiservergraphgeneratedDataProcessMutation(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_dataProcess(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "createDataProcessTask":
				return ec.fieldContext_DataProcessMutation_createDataProcessTask(ctx, field)
			case "deleteDataProcessTask":
				return ec.fieldContext_DataProcessMutation_deleteDataProcessTask(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type DataProcessMutation", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_Dataset(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_Dataset(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().Dataset(rctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*DatasetMutation)
	fc.Result = res
	return ec.marshalODatasetMutation2githubcomkubeagiarcadiaapiservergraphgeneratedDatasetMutation(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_Dataset(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "createDataset":
				return ec.fieldContext_DatasetMutation_createDataset(ctx, field)
			case "updateDataset":
				return ec.fieldContext_DatasetMutation_updateDataset(ctx, field)
			case "deleteDatasets":
				return ec.fieldContext_DatasetMutation_deleteDatasets(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type DatasetMutation", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_Datasource(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_Datasource(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().Datasource(rctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*DatasourceMutation)
	fc.Result = res
	return ec.marshalODatasourceMutation2githubcomkubeagiarcadiaapiservergraphgeneratedDatasourceMutation(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_Datasource(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "createDatasource":
				return ec.fieldContext_DatasourceMutation_createDatasource(ctx, field)
			case "updateDatasource":
				return ec.fieldContext_DatasourceMutation_updateDatasource(ctx, field)
			case "deleteDatasources":
				return ec.fieldContext_DatasourceMutation_deleteDatasources(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type DatasourceMutation", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_Embedder(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_Embedder(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().Embedder(rctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*EmbedderMutation)
	fc.Result = res
	return ec.marshalOEmbedderMutation2githubcomkubeagiarcadiaapiservergraphgeneratedEmbedderMutation(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_Embedder(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "createEmbedder":
				return ec.fieldContext_EmbedderMutation_createEmbedder(ctx, field)
			case "updateEmbedder":
				return ec.fieldContext_EmbedderMutation_updateEmbedder(ctx, field)
			case "deleteEmbedders":
				return ec.fieldContext_EmbedderMutation_deleteEmbedders(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type EmbedderMutation", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_KnowledgeBase(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_KnowledgeBase(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().KnowledgeBase(rctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*KnowledgeBaseMutation)
	fc.Result = res
	return ec.marshalOKnowledgeBaseMutation2githubcomkubeagiarcadiaapiservergraphgeneratedKnowledgeBaseMutation(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_KnowledgeBase(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "createKnowledgeBase":
				return ec.fieldContext_KnowledgeBaseMutation_createKnowledgeBase(ctx, field)
			case "updateKnowledgeBase":
				return ec.fieldContext_KnowledgeBaseMutation_updateKnowledgeBase(ctx, field)
			case "deleteKnowledgeBase":
				return ec.fieldContext_KnowledgeBaseMutation_deleteKnowledgeBase(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type KnowledgeBaseMutation", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_Model(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_Model(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().Model(rctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*ModelMutation)
	fc.Result = res
	return ec.marshalOModelMutation2githubcomkubeagiarcadiaapiservergraphgeneratedModelMutation(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_Model(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "createModel":
				return ec.fieldContext_ModelMutation_createModel(ctx, field)
			case "updateModel":
				return ec.fieldContext_ModelMutation_updateModel(ctx, field)
			case "deleteModels":
				return ec.fieldContext_ModelMutation_deleteModels(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ModelMutation", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_ModelService(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_ModelService(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().ModelService(rctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*ModelServiceMutation)
	fc.Result = res
	return ec.marshalOModelServiceMutation2githubcomkubeagiarcadiaapiservergraphgeneratedModelServiceMutation(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_ModelService(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "createModelService":
				return ec.fieldContext_ModelServiceMutation_createModelService(ctx, field)
			case "updateModelService":
				return ec.fieldContext_ModelServiceMutation_updateModelService(ctx, field)
			case "deleteModelService":
				return ec.fieldContext_ModelServiceMutation_deleteModelService(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ModelServiceMutation", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_RAG(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_RAG(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().Rag(rctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*RAGMutation)
	fc.Result = res
	return ec.marshalORAGMutation2githubcomkubeagiarcadiaapiservergraphgeneratedRAGMutation(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_RAG(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "createRAG":
				return ec.fieldContext_RAGMutation_createRAG(ctx, field)
			case "updateRAG":
				return ec.fieldContext_RAGMutation_updateRAG(ctx, field)
			case "deleteRAG":
				return ec.fieldContext_RAGMutation_deleteRAG(ctx, field)
			case "duplicateRAG":
				return ec.fieldContext_RAGMutation_duplicateRAG(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type RAGMutation", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_VersionedDataset(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_VersionedDataset(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().VersionedDataset(rctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*VersionedDatasetMutation)
	fc.Result = res
	return ec.marshalOVersionedDatasetMutation2githubcomkubeagiarcadiaapiservergraphgeneratedVersionedDatasetMutation(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_VersionedDataset(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "createVersionedDataset":
				return ec.fieldContext_VersionedDatasetMutation_createVersionedDataset(ctx, field)
			case "updateVersionedDataset":
				return ec.fieldContext_VersionedDatasetMutation_updateVersionedDataset(ctx, field)
			case "deleteVersionedDatasets":
				return ec.fieldContext_VersionedDatasetMutation_deleteVersionedDatasets(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type VersionedDatasetMutation", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_Worker(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_Worker(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().Worker(rctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*WorkerMutation)
	fc.Result = res
	return ec.marshalOWorkerMutation2githubcomkubeagiarcadiaapiservergraphgeneratedWorkerMutation(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_Worker(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "createWorker":
				return ec.fieldContext_WorkerMutation_createWorker(ctx, field)
			case "updateWorker":
				return ec.fieldContext_WorkerMutation_updateWorker(ctx, field)
			case "deleteWorkers":
				return ec.fieldContext_WorkerMutation_deleteWorkers(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type WorkerMutation", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _NodeSelectorRequirement_key(ctx context.Context, field graphql.CollectedField, obj *NodeSelectorRequirement) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_NodeSelectorRequirement_key(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Key, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_NodeSelectorRequirement_key(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "NodeSelectorRequirement",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _NodeSelectorRequirement_operator(ctx context.Context, field graphql.CollectedField, obj *NodeSelectorRequirement) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_NodeSelectorRequirement_operator(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Operator, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_NodeSelectorRequirement_operator(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "NodeSelectorRequirement",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _NodeSelectorRequirement_values(ctx context.Context, field graphql.CollectedField, obj *NodeSelectorRequirement) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_NodeSelectorRequirement_values(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Values, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_NodeSelectorRequirement_values(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "NodeSelectorRequirement",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Oss_bucket(ctx context.Context, field graphql.CollectedField, obj *Oss) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Oss_bucket(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Bucket, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Oss_bucket(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Oss",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Oss_object(ctx context.Context, field graphql.CollectedField, obj *Oss) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Oss_object(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Object, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Oss_object(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Oss",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PaginatedDataProcessItem_status(ctx context.Context, field graphql.CollectedField, obj *PaginatedDataProcessItem) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PaginatedDataProcessItem_status(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Status, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PaginatedDataProcessItem_status(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PaginatedDataProcessItem",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PaginatedDataProcessItem_data(ctx context.Context, field graphql.CollectedField, obj *PaginatedDataProcessItem) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PaginatedDataProcessItem_data(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Data, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*DataProcessItem)
	fc.Result = res
	return ec.marshalODataProcessItem2githubcomkubeagiarcadiaapiservergraphgeneratedDataProcessItem(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PaginatedDataProcessItem_data(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PaginatedDataProcessItem",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_DataProcessItem_id(ctx, field)
			case "name":
				return ec.fieldContext_DataProcessItem_name(ctx, field)
			case "status":
				return ec.fieldContext_DataProcessItem_status(ctx, field)
			case "pre_data_set_name":
				return ec.fieldContext_DataProcessItem_pre_data_set_name(ctx, field)
			case "pre_data_set_version":
				return ec.fieldContext_DataProcessItem_pre_data_set_version(ctx, field)
			case "post_data_set_name":
				return ec.fieldContext_DataProcessItem_post_data_set_name(ctx, field)
			case "post_data_set_version":
				return ec.fieldContext_DataProcessItem_post_data_set_version(ctx, field)
			case "start_datetime":
				return ec.fieldContext_DataProcessItem_start_datetime(ctx, field)
			case "error_msg":
				return ec.fieldContext_DataProcessItem_error_msg(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type DataProcessItem", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _PaginatedDataProcessItem_message(ctx context.Context, field graphql.CollectedField, obj *PaginatedDataProcessItem) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PaginatedDataProcessItem_message(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Message, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PaginatedDataProcessItem_message(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PaginatedDataProcessItem",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PaginatedResult_hasNextPage(ctx context.Context, field graphql.CollectedField, obj *PaginatedResult) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PaginatedResult_hasNextPage(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.HasNextPage, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PaginatedResult_hasNextPage(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PaginatedResult",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PaginatedResult_nodes(ctx context.Context, field graphql.CollectedField, obj *PaginatedResult) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PaginatedResult_nodes(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Nodes, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]PageNode)
	fc.Result = res
	return ec.marshalOPageNode2githubcomkubeagiarcadiaapiservergraphgeneratedPageNode(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PaginatedResult_nodes(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PaginatedResult",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type PageNode does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PaginatedResult_page(ctx context.Context, field graphql.CollectedField, obj *PaginatedResult) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PaginatedResult_page(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Page, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalOInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PaginatedResult_page(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PaginatedResult",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PaginatedResult_pageSize(ctx context.Context, field graphql.CollectedField, obj *PaginatedResult) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PaginatedResult_pageSize(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PageSize, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalOInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PaginatedResult_pageSize(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PaginatedResult",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PaginatedResult_totalCount(ctx context.Context, field graphql.CollectedField, obj *PaginatedResult) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PaginatedResult_totalCount(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TotalCount, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PaginatedResult_totalCount(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PaginatedResult",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Parameter_key(ctx context.Context, field graphql.CollectedField, obj *Parameter) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Parameter_key(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Key, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Parameter_key(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Parameter",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Parameter_value(ctx context.Context, field graphql.CollectedField, obj *Parameter) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Parameter_value(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Value, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Parameter_value(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Parameter",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PersistentVolumeClaimSpec_accessModes(ctx context.Context, field graphql.CollectedField, obj *PersistentVolumeClaimSpec) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PersistentVolumeClaimSpec_accessModes(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AccessModes, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PersistentVolumeClaimSpec_accessModes(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PersistentVolumeClaimSpec",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PersistentVolumeClaimSpec_selector(ctx context.Context, field graphql.CollectedField, obj *PersistentVolumeClaimSpec) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PersistentVolumeClaimSpec_selector(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Selector, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*Selector)
	fc.Result = res
	return ec.marshalOSelector2githubcomkubeagiarcadiaapiservergraphgeneratedSelector(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PersistentVolumeClaimSpec_selector(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PersistentVolumeClaimSpec",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "matchLabels":
				return ec.fieldContext_Selector_matchLabels(ctx, field)
			case "matchExpressions":
				return ec.fieldContext_Selector_matchExpressions(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Selector", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _PersistentVolumeClaimSpec_resources(ctx context.Context, field graphql.CollectedField, obj *PersistentVolumeClaimSpec) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PersistentVolumeClaimSpec_resources(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Resources, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*Resource)
	fc.Result = res
	return ec.marshalOResource2githubcomkubeagiarcadiaapiservergraphgeneratedResource(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PersistentVolumeClaimSpec_resources(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PersistentVolumeClaimSpec",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "limits":
				return ec.fieldContext_Resource_limits(ctx, field)
			case "requests":
				return ec.fieldContext_Resource_requests(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Resource", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _PersistentVolumeClaimSpec_volumeName(ctx context.Context, field graphql.CollectedField, obj *PersistentVolumeClaimSpec) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PersistentVolumeClaimSpec_volumeName(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.VolumeName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PersistentVolumeClaimSpec_volumeName(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PersistentVolumeClaimSpec",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PersistentVolumeClaimSpec_storageClassName(ctx context.Context, field graphql.CollectedField, obj *PersistentVolumeClaimSpec) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PersistentVolumeClaimSpec_storageClassName(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.StorageClassName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PersistentVolumeClaimSpec_storageClassName(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PersistentVolumeClaimSpec",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PersistentVolumeClaimSpec_volumeMode(ctx context.Context, field graphql.CollectedField, obj *PersistentVolumeClaimSpec) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PersistentVolumeClaimSpec_volumeMode(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.VolumeMode, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PersistentVolumeClaimSpec_volumeMode(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PersistentVolumeClaimSpec",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PersistentVolumeClaimSpec_datasource(ctx context.Context, field graphql.CollectedField, obj *PersistentVolumeClaimSpec) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PersistentVolumeClaimSpec_datasource(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Datasource, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*TypedObjectReference)
	fc.Result = res
	return ec.marshalOTypedObjectReference2githubcomkubeagiarcadiaapiservergraphgeneratedTypedObjectReference(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PersistentVolumeClaimSpec_datasource(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PersistentVolumeClaimSpec",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "apiGroup":
				return ec.fieldContext_TypedObjectReference_apiGroup(ctx, field)
			case "kind":
				return ec.fieldContext_TypedObjectReference_kind(ctx, field)
			case "name":
				return ec.fieldContext_TypedObjectReference_name(ctx, field)
			case "displayName":
				return ec.fieldContext_TypedObjectReference_displayName(ctx, field)
			case "namespace":
				return ec.fieldContext_TypedObjectReference_namespace(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type TypedObjectReference", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _PersistentVolumeClaimSpec_dataSourceRef(ctx context.Context, field graphql.CollectedField, obj *PersistentVolumeClaimSpec) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PersistentVolumeClaimSpec_dataSourceRef(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DataSourceRef, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*TypedObjectReference)
	fc.Result = res
	return ec.marshalOTypedObjectReference2githubcomkubeagiarcadiaapiservergraphgeneratedTypedObjectReference(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PersistentVolumeClaimSpec_dataSourceRef(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PersistentVolumeClaimSpec",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "apiGroup":
				return ec.fieldContext_TypedObjectReference_apiGroup(ctx, field)
			case "kind":
				return ec.fieldContext_TypedObjectReference_kind(ctx, field)
			case "name":
				return ec.fieldContext_TypedObjectReference_name(ctx, field)
			case "displayName":
				return ec.fieldContext_TypedObjectReference_displayName(ctx, field)
			case "namespace":
				return ec.fieldContext_TypedObjectReference_namespace(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type TypedObjectReference", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Query_hello(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_hello(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().Hello(rctx, fc.Args["name"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_hello(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_hello_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_Application(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_Application(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().Application(rctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*ApplicationQuery)
	fc.Result = res
	return ec.marshalOApplicationQuery2githubcomkubeagiarcadiaapiservergraphgeneratedApplicationQuery(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_Application(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "getApplication":
				return ec.fieldContext_ApplicationQuery_getApplication(ctx, field)
			case "listApplicationMetadata":
				return ec.fieldContext_ApplicationQuery_listApplicationMetadata(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ApplicationQuery", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Query_dataProcess(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_dataProcess(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().DataProcess(rctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*DataProcessQuery)
	fc.Result = res
	return ec.marshalODataProcessQuery2githubcomkubeagiarcadiaapiservergraphgeneratedDataProcessQuery(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_dataProcess(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "allDataProcessListByPage":
				return ec.fieldContext_DataProcessQuery_allDataProcessListByPage(ctx, field)
			case "allDataProcessListByCount":
				return ec.fieldContext_DataProcessQuery_allDataProcessListByCount(ctx, field)
			case "dataProcessSupportType":
				return ec.fieldContext_DataProcessQuery_dataProcessSupportType(ctx, field)
			case "dataProcessDetails":
				return ec.fieldContext_DataProcessQuery_dataProcessDetails(ctx, field)
			case "checkDataProcessTaskName":
				return ec.fieldContext_DataProcessQuery_checkDataProcessTaskName(ctx, field)
			case "getLogInfo":
				return ec.fieldContext_DataProcessQuery_getLogInfo(ctx, field)
			case "dataProcessLogInfoByFileName":
				return ec.fieldContext_DataProcessQuery_dataProcessLogInfoByFileName(ctx, field)
			case "dataProcessRetry":
				return ec.fieldContext_DataProcessQuery_dataProcessRetry(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type DataProcessQuery", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Query_Dataset(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_Dataset(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().Dataset(rctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*DatasetQuery)
	fc.Result = res
	return ec.marshalODatasetQuery2githubcomkubeagiarcadiaapiservergraphgeneratedDatasetQuery(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_Dataset(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "getDataset":
				return ec.fieldContext_DatasetQuery_getDataset(ctx, field)
			case "listDatasets":
				return ec.fieldContext_DatasetQuery_listDatasets(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type DatasetQuery", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Query_Datasource(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_Datasource(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().Datasource(rctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*DatasourceQuery)
	fc.Result = res
	return ec.marshalODatasourceQuery2githubcomkubeagiarcadiaapiservergraphgeneratedDatasourceQuery(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_Datasource(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "getDatasource":
				return ec.fieldContext_DatasourceQuery_getDatasource(ctx, field)
			case "checkDatasource":
				return ec.fieldContext_DatasourceQuery_checkDatasource(ctx, field)
			case "listDatasources":
				return ec.fieldContext_DatasourceQuery_listDatasources(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type DatasourceQuery", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Query_Embedder(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_Embedder(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().Embedder(rctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*EmbedderQuery)
	fc.Result = res
	return ec.marshalOEmbedderQuery2githubcomkubeagiarcadiaapiservergraphgeneratedEmbedderQuery(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_Embedder(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "getEmbedder":
				return ec.fieldContext_EmbedderQuery_getEmbedder(ctx, field)
			case "listEmbedders":
				return ec.fieldContext_EmbedderQuery_listEmbedders(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type EmbedderQuery", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Query_GPT(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_GPT(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().Gpt(rctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*GPTQuery)
	fc.Result = res
	return ec.marshalOGPTQuery2githubcomkubeagiarcadiaapiservergraphgeneratedGPTQuery(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_GPT(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "getGPT":
				return ec.fieldContext_GPTQuery_getGPT(ctx, field)
			case "listGPT":
				return ec.fieldContext_GPTQuery_listGPT(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type GPTQuery", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Query_KnowledgeBase(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_KnowledgeBase(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().KnowledgeBase(rctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*KnowledgeBaseQuery)
	fc.Result = res
	return ec.marshalOKnowledgeBaseQuery2githubcomkubeagiarcadiaapiservergraphgeneratedKnowledgeBaseQuery(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_KnowledgeBase(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "getKnowledgeBase":
				return ec.fieldContext_KnowledgeBaseQuery_getKnowledgeBase(ctx, field)
			case "listKnowledgeBases":
				return ec.fieldContext_KnowledgeBaseQuery_listKnowledgeBases(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type KnowledgeBaseQuery", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Query_LLM(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_LLM(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().Llm(rctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*LLMQuery)
	fc.Result = res
	return ec.marshalOLLMQuery2githubcomkubeagiarcadiaapiservergraphgeneratedLLMQuery(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_LLM(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "getLLM":
				return ec.fieldContext_LLMQuery_getLLM(ctx, field)
			case "listLLMs":
				return ec.fieldContext_LLMQuery_listLLMs(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type LLMQuery", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Query_Model(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_Model(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().Model(rctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*ModelQuery)
	fc.Result = res
	return ec.marshalOModelQuery2githubcomkubeagiarcadiaapiservergraphgeneratedModelQuery(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_Model(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "getModel":
				return ec.fieldContext_ModelQuery_getModel(ctx, field)
			case "listModels":
				return ec.fieldContext_ModelQuery_listModels(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ModelQuery", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Query_ModelService(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_ModelService(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().ModelService(rctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*ModelServiceQuery)
	fc.Result = res
	return ec.marshalOModelServiceQuery2githubcomkubeagiarcadiaapiservergraphgeneratedModelServiceQuery(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_ModelService(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "getModelService":
				return ec.fieldContext_ModelServiceQuery_getModelService(ctx, field)
			case "listModelServices":
				return ec.fieldContext_ModelServiceQuery_listModelServices(ctx, field)
			case "checkModelService":
				return ec.fieldContext_ModelServiceQuery_checkModelService(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ModelServiceQuery", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Query_RAG(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_RAG(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().Rag(rctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*RAGQuery)
	fc.Result = res
	return ec.marshalORAGQuery2githubcomkubeagiarcadiaapiservergraphgeneratedRAGQuery(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_RAG(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "getRAG":
				return ec.fieldContext_RAGQuery_getRAG(ctx, field)
			case "listRAG":
				return ec.fieldContext_RAGQuery_listRAG(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type RAGQuery", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Query_RayCluster(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_RayCluster(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().RayCluster(rctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*RayClusterQuery)
	fc.Result = res
	return ec.marshalORayClusterQuery2githubcomkubeagiarcadiaapiservergraphgeneratedRayClusterQuery(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_RayCluster(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "listRayClusters":
				return ec.fieldContext_RayClusterQuery_listRayClusters(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type RayClusterQuery", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Query_VersionedDataset(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_VersionedDataset(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().VersionedDataset(rctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*VersionedDatasetQuery)
	fc.Result = res
	return ec.marshalOVersionedDatasetQuery2githubcomkubeagiarcadiaapiservergraphgeneratedVersionedDatasetQuery(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_VersionedDataset(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "getVersionedDataset":
				return ec.fieldContext_VersionedDatasetQuery_getVersionedDataset(ctx, field)
			case "listVersionedDatasets":
				return ec.fieldContext_VersionedDatasetQuery_listVersionedDatasets(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type VersionedDatasetQuery", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Query_Worker(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_Worker(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().Worker(rctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*WorkerQuery)
	fc.Result = res
	return ec.marshalOWorkerQuery2githubcomkubeagiarcadiaapiservergraphgeneratedWorkerQuery(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_Worker(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "getWorker":
				return ec.fieldContext_WorkerQuery_getWorker(ctx, field)
			case "listWorkers":
				return ec.fieldContext_WorkerQuery_listWorkers(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type WorkerQuery", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Query___type(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query___type(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.introspectType(fc.Args["name"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalO__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query___type(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query___type_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query___schema(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query___schema(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.introspectSchema()
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*introspection.Schema)
	fc.Result = res
	return ec.marshalO__Schema2githubcom99designsgqlgengraphqlintrospectionSchema(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query___schema(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "description":
				return ec.fieldContext___Schema_description(ctx, field)
			case "types":
				return ec.fieldContext___Schema_types(ctx, field)
			case "queryType":
				return ec.fieldContext___Schema_queryType(ctx, field)
			case "mutationType":
				return ec.fieldContext___Schema_mutationType(ctx, field)
			case "subscriptionType":
				return ec.fieldContext___Schema_subscriptionType(ctx, field)
			case "directives":
				return ec.fieldContext___Schema_directives(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Schema", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _RAG_name(ctx context.Context, field graphql.CollectedField, obj *Rag) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RAG_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RAG_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RAG",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RAG_namespace(ctx context.Context, field graphql.CollectedField, obj *Rag) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RAG_namespace(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Namespace, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RAG_namespace(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RAG",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RAG_labels(ctx context.Context, field graphql.CollectedField, obj *Rag) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RAG_labels(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Labels, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(map[string]interface{})
	fc.Result = res
	return ec.marshalOMap2map(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RAG_labels(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RAG",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Map does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RAG_annotations(ctx context.Context, field graphql.CollectedField, obj *Rag) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RAG_annotations(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Annotations, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(map[string]interface{})
	fc.Result = res
	return ec.marshalOMap2map(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RAG_annotations(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RAG",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Map does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RAG_creator(ctx context.Context, field graphql.CollectedField, obj *Rag) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RAG_creator(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Creator, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RAG_creator(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RAG",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RAG_displayName(ctx context.Context, field graphql.CollectedField, obj *Rag) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RAG_displayName(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DisplayName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RAG_displayName(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RAG",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RAG_description(ctx context.Context, field graphql.CollectedField, obj *Rag) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RAG_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RAG_description(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RAG",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RAG_creationTimestamp(ctx context.Context, field graphql.CollectedField, obj *Rag) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RAG_creationTimestamp(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CreationTimestamp, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*time.Time)
	fc.Result = res
	return ec.marshalOTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RAG_creationTimestamp(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RAG",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RAG_completeTimestamp(ctx context.Context, field graphql.CollectedField, obj *Rag) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RAG_completeTimestamp(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CompleteTimestamp, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*time.Time)
	fc.Result = res
	return ec.marshalOTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RAG_completeTimestamp(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RAG",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RAG_application(ctx context.Context, field graphql.CollectedField, obj *Rag) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RAG_application(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.RAG().Application(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*Application)
	fc.Result = res
	return ec.marshalNApplication2githubcomkubeagiarcadiaapiservergraphgeneratedApplication(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RAG_application(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RAG",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "metadata":
				return ec.fieldContext_Application_metadata(ctx, field)
			case "prologue":
				return ec.fieldContext_Application_prologue(ctx, field)
			case "model":
				return ec.fieldContext_Application_model(ctx, field)
			case "llm":
				return ec.fieldContext_Application_llm(ctx, field)
			case "temperature":
				return ec.fieldContext_Application_temperature(ctx, field)
			case "maxLength":
				return ec.fieldContext_Application_maxLength(ctx, field)
			case "maxTokens":
				return ec.fieldContext_Application_maxTokens(ctx, field)
			case "conversionWindowSize":
				return ec.fieldContext_Application_conversionWindowSize(ctx, field)
			case "knowledgebase":
				return ec.fieldContext_Application_knowledgebase(ctx, field)
			case "scoreThreshold":
				return ec.fieldContext_Application_scoreThreshold(ctx, field)
			case "numDocuments":
				return ec.fieldContext_Application_numDocuments(ctx, field)
			case "docNullReturn":
				return ec.fieldContext_Application_docNullReturn(ctx, field)
			case "userPrompt":
				return ec.fieldContext_Application_userPrompt(ctx, field)
			case "showRespInfo":
				return ec.fieldContext_Application_showRespInfo(ctx, field)
			case "showRetrievalInfo":
				return ec.fieldContext_Application_showRetrievalInfo(ctx, field)
			case "showNextGuide":
				return ec.fieldContext_Application_showNextGuide(ctx, field)
			case "tools":
				return ec.fieldContext_Application_tools(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Application", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _RAG_datasets(ctx context.Context, field graphql.CollectedField, obj *Rag) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RAG_datasets(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.RAG().Datasets(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*RAGDataset)
	fc.Result = res
	return ec.marshalNRAGDataset2githubcomkubeagiarcadiaapiservergraphgeneratedRAGDataset(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RAG_datasets(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RAG",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "source":
				return ec.fieldContext_RAGDataset_source(ctx, field)
			case "files":
				return ec.fieldContext_RAGDataset_files(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type RAGDataset", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _RAG_judgeLLM(ctx context.Context, field graphql.CollectedField, obj *Rag) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RAG_judgeLLM(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.RAG().JudgeLlm(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*Llm)
	fc.Result = res
	return ec.marshalNLLM2githubcomkubeagiarcadiaapiservergraphgeneratedLlm(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RAG_judgeLLM(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RAG",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_LLM_id(ctx, field)
			case "name":
				return ec.fieldContext_LLM_name(ctx, field)
			case "namespace":
				return ec.fieldContext_LLM_namespace(ctx, field)
			case "labels":
				return ec.fieldContext_LLM_labels(ctx, field)
			case "annotations":
				return ec.fieldContext_LLM_annotations(ctx, field)
			case "creator":
				return ec.fieldContext_LLM_creator(ctx, field)
			case "displayName":
				return ec.fieldContext_LLM_displayName(ctx, field)
			case "description":
				return ec.fieldContext_LLM_description(ctx, field)
			case "baseUrl":
				return ec.fieldContext_LLM_baseUrl(ctx, field)
			case "models":
				return ec.fieldContext_LLM_models(ctx, field)
			case "provider":
				return ec.fieldContext_LLM_provider(ctx, field)
			case "type":
				return ec.fieldContext_LLM_type(ctx, field)
			case "creationTimestamp":
				return ec.fieldContext_LLM_creationTimestamp(ctx, field)
			case "updateTimestamp":
				return ec.fieldContext_LLM_updateTimestamp(ctx, field)
			case "status":
				return ec.fieldContext_LLM_status(ctx, field)
			case "message":
				return ec.fieldContext_LLM_message(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type LLM", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _RAG_metrics(ctx context.Context, field graphql.CollectedField, obj *Rag) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RAG_metrics(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.RAG().Metrics(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*RAGMetric)
	fc.Result = res
	return ec.marshalNRAGMetric2githubcomkubeagiarcadiaapiservergraphgeneratedRAGMetric(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RAG_metrics(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RAG",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "metricKind":
				return ec.fieldContext_RAGMetric_metricKind(ctx, field)
			case "parameters":
				return ec.fieldContext_RAGMetric_parameters(ctx, field)
			case "toleranceThreshbold":
				return ec.fieldContext_RAGMetric_toleranceThreshbold(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type RAGMetric", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _RAG_storage(ctx context.Context, field graphql.CollectedField, obj *Rag) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RAG_storage(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Storage, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(PersistentVolumeClaimSpec)
	fc.Result = res
	return ec.marshalNPersistentVolumeClaimSpec2githubcomkubeagiarcadiaapiservergraphgeneratedPersistentVolumeClaimSpec(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RAG_storage(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RAG",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "accessModes":
				return ec.fieldContext_PersistentVolumeClaimSpec_accessModes(ctx, field)
			case "selector":
				return ec.fieldContext_PersistentVolumeClaimSpec_selector(ctx, field)
			case "resources":
				return ec.fieldContext_PersistentVolumeClaimSpec_resources(ctx, field)
			case "volumeName":
				return ec.fieldContext_PersistentVolumeClaimSpec_volumeName(ctx, field)
			case "storageClassName":
				return ec.fieldContext_PersistentVolumeClaimSpec_storageClassName(ctx, field)
			case "volumeMode":
				return ec.fieldContext_PersistentVolumeClaimSpec_volumeMode(ctx, field)
			case "datasource":
				return ec.fieldContext_PersistentVolumeClaimSpec_datasource(ctx, field)
			case "dataSourceRef":
				return ec.fieldContext_PersistentVolumeClaimSpec_dataSourceRef(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type PersistentVolumeClaimSpec", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _RAG_serviceAccountName(ctx context.Context, field graphql.CollectedField, obj *Rag) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RAG_serviceAccountName(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ServiceAccountName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RAG_serviceAccountName(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RAG",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RAG_suspend(ctx context.Context, field graphql.CollectedField, obj *Rag) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RAG_suspend(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Suspend, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RAG_suspend(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RAG",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RAG_status(ctx context.Context, field graphql.CollectedField, obj *Rag) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RAG_status(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Status, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RAG_status(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RAG",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RAG_phase(ctx context.Context, field graphql.CollectedField, obj *Rag) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RAG_phase(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Phase, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RAG_phase(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RAG",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RAG_phaseMessage(ctx context.Context, field graphql.CollectedField, obj *Rag) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RAG_phaseMessage(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PhaseMessage, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RAG_phaseMessage(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RAG",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RAGDataset_source(ctx context.Context, field graphql.CollectedField, obj *RAGDataset) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RAGDataset_source(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Source, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*TypedObjectReference)
	fc.Result = res
	return ec.marshalOTypedObjectReference2githubcomkubeagiarcadiaapiservergraphgeneratedTypedObjectReference(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RAGDataset_source(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RAGDataset",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "apiGroup":
				return ec.fieldContext_TypedObjectReference_apiGroup(ctx, field)
			case "kind":
				return ec.fieldContext_TypedObjectReference_kind(ctx, field)
			case "name":
				return ec.fieldContext_TypedObjectReference_name(ctx, field)
			case "displayName":
				return ec.fieldContext_TypedObjectReference_displayName(ctx, field)
			case "namespace":
				return ec.fieldContext_TypedObjectReference_namespace(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type TypedObjectReference", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _RAGDataset_files(ctx context.Context, field graphql.CollectedField, obj *RAGDataset) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RAGDataset_files(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Files, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*F)
	fc.Result = res
	return ec.marshalOF2githubcomkubeagiarcadiaapiservergraphgeneratedF(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RAGDataset_files(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RAGDataset",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "path":
				return ec.fieldContext_F_path(ctx, field)
			case "fileType":
				return ec.fieldContext_F_fileType(ctx, field)
			case "count":
				return ec.fieldContext_F_count(ctx, field)
			case "time":
				return ec.fieldContext_F_time(ctx, field)
			case "size":
				return ec.fieldContext_F_size(ctx, field)
			case "creationTimestamp":
				return ec.fieldContext_F_creationTimestamp(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type F", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _RAGMetric_metricKind(ctx context.Context, field graphql.CollectedField, obj *RAGMetric) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RAGMetric_metricKind(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MetricKind, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RAGMetric_metricKind(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RAGMetric",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RAGMetric_parameters(ctx context.Context, field graphql.CollectedField, obj *RAGMetric) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RAGMetric_parameters(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Parameters, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*Parameter)
	fc.Result = res
	return ec.marshalOParameter2githubcomkubeagiarcadiaapiservergraphgeneratedParameter(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RAGMetric_parameters(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RAGMetric",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "key":
				return ec.fieldContext_Parameter_key(ctx, field)
			case "value":
				return ec.fieldContext_Parameter_value(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Parameter", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _RAGMetric_toleranceThreshbold(ctx context.Context, field graphql.CollectedField, obj *RAGMetric) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RAGMetric_toleranceThreshbold(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ToleranceThreshbold, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalOInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RAGMetric_toleranceThreshbold(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RAGMetric",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RAGMutation_createRAG(ctx context.Context, field graphql.CollectedField, obj *RAGMutation) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RAGMutation_createRAG(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.RAGMutation().CreateRag(rctx, obj, fc.Args["input"].(CreateRAGInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*Rag)
	fc.Result = res
	return ec.marshalNRAG2githubcomkubeagiarcadiaapiservergraphgeneratedRag(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RAGMutation_createRAG(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RAGMutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext_RAG_name(ctx, field)
			case "namespace":
				return ec.fieldContext_RAG_namespace(ctx, field)
			case "labels":
				return ec.fieldContext_RAG_labels(ctx, field)
			case "annotations":
				return ec.fieldContext_RAG_annotations(ctx, field)
			case "creator":
				return ec.fieldContext_RAG_creator(ctx, field)
			case "displayName":
				return ec.fieldContext_RAG_displayName(ctx, field)
			case "description":
				return ec.fieldContext_RAG_description(ctx, field)
			case "creationTimestamp":
				return ec.fieldContext_RAG_creationTimestamp(ctx, field)
			case "completeTimestamp":
				return ec.fieldContext_RAG_completeTimestamp(ctx, field)
			case "application":
				return ec.fieldContext_RAG_application(ctx, field)
			case "datasets":
				return ec.fieldContext_RAG_datasets(ctx, field)
			case "judgeLLM":
				return ec.fieldContext_RAG_judgeLLM(ctx, field)
			case "metrics":
				return ec.fieldContext_RAG_metrics(ctx, field)
			case "storage":
				return ec.fieldContext_RAG_storage(ctx, field)
			case "serviceAccountName":
				return ec.fieldContext_RAG_serviceAccountName(ctx, field)
			case "suspend":
				return ec.fieldContext_RAG_suspend(ctx, field)
			case "status":
				return ec.fieldContext_RAG_status(ctx, field)
			case "phase":
				return ec.fieldContext_RAG_phase(ctx, field)
			case "phaseMessage":
				return ec.fieldContext_RAG_phaseMessage(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type RAG", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_RAGMutation_createRAG_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _RAGMutation_updateRAG(ctx context.Context, field graphql.CollectedField, obj *RAGMutation) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RAGMutation_updateRAG(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.RAGMutation().UpdateRag(rctx, obj, fc.Args["input"].(UpdateRAGInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*Rag)
	fc.Result = res
	return ec.marshalNRAG2githubcomkubeagiarcadiaapiservergraphgeneratedRag(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RAGMutation_updateRAG(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RAGMutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext_RAG_name(ctx, field)
			case "namespace":
				return ec.fieldContext_RAG_namespace(ctx, field)
			case "labels":
				return ec.fieldContext_RAG_labels(ctx, field)
			case "annotations":
				return ec.fieldContext_RAG_annotations(ctx, field)
			case "creator":
				return ec.fieldContext_RAG_creator(ctx, field)
			case "displayName":
				return ec.fieldContext_RAG_displayName(ctx, field)
			case "description":
				return ec.fieldContext_RAG_description(ctx, field)
			case "creationTimestamp":
				return ec.fieldContext_RAG_creationTimestamp(ctx, field)
			case "completeTimestamp":
				return ec.fieldContext_RAG_completeTimestamp(ctx, field)
			case "application":
				return ec.fieldContext_RAG_application(ctx, field)
			case "datasets":
				return ec.fieldContext_RAG_datasets(ctx, field)
			case "judgeLLM":
				return ec.fieldContext_RAG_judgeLLM(ctx, field)
			case "metrics":
				return ec.fieldContext_RAG_metrics(ctx, field)
			case "storage":
				return ec.fieldContext_RAG_storage(ctx, field)
			case "serviceAccountName":
				return ec.fieldContext_RAG_serviceAccountName(ctx, field)
			case "suspend":
				return ec.fieldContext_RAG_suspend(ctx, field)
			case "status":
				return ec.fieldContext_RAG_status(ctx, field)
			case "phase":
				return ec.fieldContext_RAG_phase(ctx, field)
			case "phaseMessage":
				return ec.fieldContext_RAG_phaseMessage(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type RAG", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_RAGMutation_updateRAG_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _RAGMutation_deleteRAG(ctx context.Context, field graphql.CollectedField, obj *RAGMutation) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RAGMutation_deleteRAG(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.RAGMutation().DeleteRag(rctx, obj, fc.Args["input"].(DeleteRAGInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOVoid2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RAGMutation_deleteRAG(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RAGMutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Void does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_RAGMutation_deleteRAG_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _RAGMutation_duplicateRAG(ctx context.Context, field graphql.CollectedField, obj *RAGMutation) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RAGMutation_duplicateRAG(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.RAGMutation().DuplicateRag(rctx, obj, fc.Args["input"].(DuplicateRAGInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*Rag)
	fc.Result = res
	return ec.marshalNRAG2githubcomkubeagiarcadiaapiservergraphgeneratedRag(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RAGMutation_duplicateRAG(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RAGMutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext_RAG_name(ctx, field)
			case "namespace":
				return ec.fieldContext_RAG_namespace(ctx, field)
			case "labels":
				return ec.fieldContext_RAG_labels(ctx, field)
			case "annotations":
				return ec.fieldContext_RAG_annotations(ctx, field)
			case "creator":
				return ec.fieldContext_RAG_creator(ctx, field)
			case "displayName":
				return ec.fieldContext_RAG_displayName(ctx, field)
			case "description":
				return ec.fieldContext_RAG_description(ctx, field)
			case "creationTimestamp":
				return ec.fieldContext_RAG_creationTimestamp(ctx, field)
			case "completeTimestamp":
				return ec.fieldContext_RAG_completeTimestamp(ctx, field)
			case "application":
				return ec.fieldContext_RAG_application(ctx, field)
			case "datasets":
				return ec.fieldContext_RAG_datasets(ctx, field)
			case "judgeLLM":
				return ec.fieldContext_RAG_judgeLLM(ctx, field)
			case "metrics":
				return ec.fieldContext_RAG_metrics(ctx, field)
			case "storage":
				return ec.fieldContext_RAG_storage(ctx, field)
			case "serviceAccountName":
				return ec.fieldContext_RAG_serviceAccountName(ctx, field)
			case "suspend":
				return ec.fieldContext_RAG_suspend(ctx, field)
			case "status":
				return ec.fieldContext_RAG_status(ctx, field)
			case "phase":
				return ec.fieldContext_RAG_phase(ctx, field)
			case "phaseMessage":
				return ec.fieldContext_RAG_phaseMessage(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type RAG", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_RAGMutation_duplicateRAG_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _RAGQuery_getRAG(ctx context.Context, field graphql.CollectedField, obj *RAGQuery) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RAGQuery_getRAG(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.RAGQuery().GetRag(rctx, obj, fc.Args["name"].(string), fc.Args["namespace"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*Rag)
	fc.Result = res
	return ec.marshalNRAG2githubcomkubeagiarcadiaapiservergraphgeneratedRag(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RAGQuery_getRAG(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RAGQuery",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext_RAG_name(ctx, field)
			case "namespace":
				return ec.fieldContext_RAG_namespace(ctx, field)
			case "labels":
				return ec.fieldContext_RAG_labels(ctx, field)
			case "annotations":
				return ec.fieldContext_RAG_annotations(ctx, field)
			case "creator":
				return ec.fieldContext_RAG_creator(ctx, field)
			case "displayName":
				return ec.fieldContext_RAG_displayName(ctx, field)
			case "description":
				return ec.fieldContext_RAG_description(ctx, field)
			case "creationTimestamp":
				return ec.fieldContext_RAG_creationTimestamp(ctx, field)
			case "completeTimestamp":
				return ec.fieldContext_RAG_completeTimestamp(ctx, field)
			case "application":
				return ec.fieldContext_RAG_application(ctx, field)
			case "datasets":
				return ec.fieldContext_RAG_datasets(ctx, field)
			case "judgeLLM":
				return ec.fieldContext_RAG_judgeLLM(ctx, field)
			case "metrics":
				return ec.fieldContext_RAG_metrics(ctx, field)
			case "storage":
				return ec.fieldContext_RAG_storage(ctx, field)
			case "serviceAccountName":
				return ec.fieldContext_RAG_serviceAccountName(ctx, field)
			case "suspend":
				return ec.fieldContext_RAG_suspend(ctx, field)
			case "status":
				return ec.fieldContext_RAG_status(ctx, field)
			case "phase":
				return ec.fieldContext_RAG_phase(ctx, field)
			case "phaseMessage":
				return ec.fieldContext_RAG_phaseMessage(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type RAG", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_RAGQuery_getRAG_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _RAGQuery_listRAG(ctx context.Context, field graphql.CollectedField, obj *RAGQuery) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RAGQuery_listRAG(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.RAGQuery().ListRag(rctx, obj, fc.Args["input"].(ListRAGInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*PaginatedResult)
	fc.Result = res
	return ec.marshalNPaginatedResult2githubcomkubeagiarcadiaapiservergraphgeneratedPaginatedResult(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RAGQuery_listRAG(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RAGQuery",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "hasNextPage":
				return ec.fieldContext_PaginatedResult_hasNextPage(ctx, field)
			case "nodes":
				return ec.fieldContext_PaginatedResult_nodes(ctx, field)
			case "page":
				return ec.fieldContext_PaginatedResult_page(ctx, field)
			case "pageSize":
				return ec.fieldContext_PaginatedResult_pageSize(ctx, field)
			case "totalCount":
				return ec.fieldContext_PaginatedResult_totalCount(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type PaginatedResult", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_RAGQuery_listRAG_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _RayCluster_index(ctx context.Context, field graphql.CollectedField, obj *RayCluster) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RayCluster_index(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Index, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RayCluster_index(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RayCluster",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RayCluster_name(ctx context.Context, field graphql.CollectedField, obj *RayCluster) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RayCluster_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RayCluster_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RayCluster",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RayCluster_headAddress(ctx context.Context, field graphql.CollectedField, obj *RayCluster) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RayCluster_headAddress(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.HeadAddress, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RayCluster_headAddress(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RayCluster",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RayCluster_dashboardHost(ctx context.Context, field graphql.CollectedField, obj *RayCluster) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RayCluster_dashboardHost(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DashboardHost, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RayCluster_dashboardHost(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RayCluster",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RayCluster_pythonVersion(ctx context.Context, field graphql.CollectedField, obj *RayCluster) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RayCluster_pythonVersion(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PythonVersion, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RayCluster_pythonVersion(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RayCluster",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RayClusterQuery_listRayClusters(ctx context.Context, field graphql.CollectedField, obj *RayClusterQuery) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RayClusterQuery_listRayClusters(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.RayClusterQuery().ListRayClusters(rctx, obj, fc.Args["input"].(ListCommonInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*PaginatedResult)
	fc.Result = res
	return ec.marshalNPaginatedResult2githubcomkubeagiarcadiaapiservergraphgeneratedPaginatedResult(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RayClusterQuery_listRayClusters(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RayClusterQuery",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "hasNextPage":
				return ec.fieldContext_PaginatedResult_hasNextPage(ctx, field)
			case "nodes":
				return ec.fieldContext_PaginatedResult_nodes(ctx, field)
			case "page":
				return ec.fieldContext_PaginatedResult_page(ctx, field)
			case "pageSize":
				return ec.fieldContext_PaginatedResult_pageSize(ctx, field)
			case "totalCount":
				return ec.fieldContext_PaginatedResult_totalCount(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type PaginatedResult", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_RayClusterQuery_listRayClusters_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _RemoveDuplicateConfigItem_embedding_name(ctx context.Context, field graphql.CollectedField, obj *RemoveDuplicateConfigItem) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RemoveDuplicateConfigItem_embedding_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.EmbeddingName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RemoveDuplicateConfigItem_embedding_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RemoveDuplicateConfigItem",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RemoveDuplicateConfigItem_embedding_namespace(ctx context.Context, field graphql.CollectedField, obj *RemoveDuplicateConfigItem) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RemoveDuplicateConfigItem_embedding_namespace(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.EmbeddingNamespace, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RemoveDuplicateConfigItem_embedding_namespace(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RemoveDuplicateConfigItem",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RemoveDuplicateConfigItem_embedding_model(ctx context.Context, field graphql.CollectedField, obj *RemoveDuplicateConfigItem) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RemoveDuplicateConfigItem_embedding_model(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.EmbeddingModel, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RemoveDuplicateConfigItem_embedding_model(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RemoveDuplicateConfigItem",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RemoveDuplicateConfigItem_embedding_provider(ctx context.Context, field graphql.CollectedField, obj *RemoveDuplicateConfigItem) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RemoveDuplicateConfigItem_embedding_provider(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.EmbeddingProvider, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RemoveDuplicateConfigItem_embedding_provider(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RemoveDuplicateConfigItem",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RemoveDuplicateConfigItem_similarity(ctx context.Context, field graphql.CollectedField, obj *RemoveDuplicateConfigItem) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RemoveDuplicateConfigItem_similarity(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Similarity, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RemoveDuplicateConfigItem_similarity(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RemoveDuplicateConfigItem",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Resource_limits(ctx context.Context, field graphql.CollectedField, obj *Resource) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Resource_limits(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Limits, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(map[string]interface{})
	fc.Result = res
	return ec.marshalOMap2map(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Resource_limits(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Resource",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Map does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Resource_requests(ctx context.Context, field graphql.CollectedField, obj *Resource) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Resource_requests(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Requests, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(map[string]interface{})
	fc.Result = res
	return ec.marshalOMap2map(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Resource_requests(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Resource",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Map does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Resources_cpu(ctx context.Context, field graphql.CollectedField, obj *Resources) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Resources_cpu(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CPU, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Resources_cpu(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Resources",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Resources_memory(ctx context.Context, field graphql.CollectedField, obj *Resources) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Resources_memory(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Memory, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Resources_memory(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Resources",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Resources_nvidiaGPU(ctx context.Context, field graphql.CollectedField, obj *Resources) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Resources_nvidiaGPU(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.NvidiaGpu, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Resources_nvidiaGPU(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Resources",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Selector_matchLabels(ctx context.Context, field graphql.CollectedField, obj *Selector) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Selector_matchLabels(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MatchLabels, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(map[string]interface{})
	fc.Result = res
	return ec.marshalOMap2map(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Selector_matchLabels(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Selector",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Map does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Selector_matchExpressions(ctx context.Context, field graphql.CollectedField, obj *Selector) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Selector_matchExpressions(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MatchExpressions, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*LabelSelectorRequirement)
	fc.Result = res
	return ec.marshalOLabelSelectorRequirement2githubcomkubeagiarcadiaapiservergraphgeneratedLabelSelectorRequirement(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Selector_matchExpressions(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Selector",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "key":
				return ec.fieldContext_LabelSelectorRequirement_key(ctx, field)
			case "values":
				return ec.fieldContext_LabelSelectorRequirement_values(ctx, field)
			case "operator":
				return ec.fieldContext_LabelSelectorRequirement_operator(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type LabelSelectorRequirement", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Tool_name(ctx context.Context, field graphql.CollectedField, obj *Tool) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Tool_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Tool_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Tool",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Tool_params(ctx context.Context, field graphql.CollectedField, obj *Tool) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Tool_params(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Params, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(map[string]interface{})
	fc.Result = res
	return ec.marshalOMap2map(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Tool_params(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Tool",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Map does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TypedObjectReference_apiGroup(ctx context.Context, field graphql.CollectedField, obj *TypedObjectReference) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TypedObjectReference_apiGroup(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.APIGroup, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TypedObjectReference_apiGroup(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TypedObjectReference",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TypedObjectReference_kind(ctx context.Context, field graphql.CollectedField, obj *TypedObjectReference) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TypedObjectReference_kind(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Kind, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TypedObjectReference_kind(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TypedObjectReference",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TypedObjectReference_name(ctx context.Context, field graphql.CollectedField, obj *TypedObjectReference) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TypedObjectReference_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TypedObjectReference_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TypedObjectReference",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TypedObjectReference_displayName(ctx context.Context, field graphql.CollectedField, obj *TypedObjectReference) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TypedObjectReference_displayName(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DisplayName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TypedObjectReference_displayName(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TypedObjectReference",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TypedObjectReference_namespace(ctx context.Context, field graphql.CollectedField, obj *TypedObjectReference) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TypedObjectReference_namespace(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Namespace, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TypedObjectReference_namespace(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TypedObjectReference",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _VersionedDataset_id(ctx context.Context, field graphql.CollectedField, obj *VersionedDataset) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_VersionedDataset_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_VersionedDataset_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "VersionedDataset",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _VersionedDataset_name(ctx context.Context, field graphql.CollectedField, obj *VersionedDataset) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_VersionedDataset_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_VersionedDataset_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "VersionedDataset",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _VersionedDataset_namespace(ctx context.Context, field graphql.CollectedField, obj *VersionedDataset) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_VersionedDataset_namespace(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Namespace, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_VersionedDataset_namespace(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "VersionedDataset",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _VersionedDataset_labels(ctx context.Context, field graphql.CollectedField, obj *VersionedDataset) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_VersionedDataset_labels(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Labels, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(map[string]interface{})
	fc.Result = res
	return ec.marshalOMap2map(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_VersionedDataset_labels(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "VersionedDataset",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Map does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _VersionedDataset_annotations(ctx context.Context, field graphql.CollectedField, obj *VersionedDataset) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_VersionedDataset_annotations(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Annotations, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(map[string]interface{})
	fc.Result = res
	return ec.marshalOMap2map(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_VersionedDataset_annotations(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "VersionedDataset",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Map does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _VersionedDataset_creator(ctx context.Context, field graphql.CollectedField, obj *VersionedDataset) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_VersionedDataset_creator(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Creator, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_VersionedDataset_creator(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "VersionedDataset",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _VersionedDataset_displayName(ctx context.Context, field graphql.CollectedField, obj *VersionedDataset) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_VersionedDataset_displayName(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DisplayName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_VersionedDataset_displayName(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "VersionedDataset",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _VersionedDataset_description(ctx context.Context, field graphql.CollectedField, obj *VersionedDataset) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_VersionedDataset_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_VersionedDataset_description(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "VersionedDataset",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _VersionedDataset_dataset(ctx context.Context, field graphql.CollectedField, obj *VersionedDataset) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_VersionedDataset_dataset(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Dataset, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(TypedObjectReference)
	fc.Result = res
	return ec.marshalNTypedObjectReference2githubcomkubeagiarcadiaapiservergraphgeneratedTypedObjectReference(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_VersionedDataset_dataset(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "VersionedDataset",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "apiGroup":
				return ec.fieldContext_TypedObjectReference_apiGroup(ctx, field)
			case "kind":
				return ec.fieldContext_TypedObjectReference_kind(ctx, field)
			case "name":
				return ec.fieldContext_TypedObjectReference_name(ctx, field)
			case "displayName":
				return ec.fieldContext_TypedObjectReference_displayName(ctx, field)
			case "namespace":
				return ec.fieldContext_TypedObjectReference_namespace(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type TypedObjectReference", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _VersionedDataset_updateTimestamp(ctx context.Context, field graphql.CollectedField, obj *VersionedDataset) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_VersionedDataset_updateTimestamp(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UpdateTimestamp, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*time.Time)
	fc.Result = res
	return ec.marshalOTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_VersionedDataset_updateTimestamp(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "VersionedDataset",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _VersionedDataset_creationTimestamp(ctx context.Context, field graphql.CollectedField, obj *VersionedDataset) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_VersionedDataset_creationTimestamp(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CreationTimestamp, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return ec.marshalNTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_VersionedDataset_creationTimestamp(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "VersionedDataset",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _VersionedDataset_files(ctx context.Context, field graphql.CollectedField, obj *VersionedDataset) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_VersionedDataset_files(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.VersionedDataset().Files(rctx, obj, fc.Args["input"].(*FileFilter))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*PaginatedResult)
	fc.Result = res
	return ec.marshalNPaginatedResult2githubcomkubeagiarcadiaapiservergraphgeneratedPaginatedResult(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_VersionedDataset_files(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "VersionedDataset",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "hasNextPage":
				return ec.fieldContext_PaginatedResult_hasNextPage(ctx, field)
			case "nodes":
				return ec.fieldContext_PaginatedResult_nodes(ctx, field)
			case "page":
				return ec.fieldContext_PaginatedResult_page(ctx, field)
			case "pageSize":
				return ec.fieldContext_PaginatedResult_pageSize(ctx, field)
			case "totalCount":
				return ec.fieldContext_PaginatedResult_totalCount(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type PaginatedResult", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_VersionedDataset_files_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _VersionedDataset_version(ctx context.Context, field graphql.CollectedField, obj *VersionedDataset) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_VersionedDataset_version(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Version, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_VersionedDataset_version(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "VersionedDataset",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _VersionedDataset_released(ctx context.Context, field graphql.CollectedField, obj *VersionedDataset) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_VersionedDataset_released(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Released, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_VersionedDataset_released(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "VersionedDataset",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _VersionedDataset_syncStatus(ctx context.Context, field graphql.CollectedField, obj *VersionedDataset) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_VersionedDataset_syncStatus(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SyncStatus, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_VersionedDataset_syncStatus(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "VersionedDataset",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _VersionedDataset_syncMsg(ctx context.Context, field graphql.CollectedField, obj *VersionedDataset) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_VersionedDataset_syncMsg(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SyncMsg, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_VersionedDataset_syncMsg(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "VersionedDataset",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _VersionedDataset_dataProcessStatus(ctx context.Context, field graphql.CollectedField, obj *VersionedDataset) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_VersionedDataset_dataProcessStatus(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DataProcessStatus, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_VersionedDataset_dataProcessStatus(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "VersionedDataset",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _VersionedDataset_dataProcessMsg(ctx context.Context, field graphql.CollectedField, obj *VersionedDataset) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_VersionedDataset_dataProcessMsg(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DataProcessMsg, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_VersionedDataset_dataProcessMsg(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "VersionedDataset",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _VersionedDatasetMutation_createVersionedDataset(ctx context.Context, field graphql.CollectedField, obj *VersionedDatasetMutation) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_VersionedDatasetMutation_createVersionedDataset(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.VersionedDatasetMutation().CreateVersionedDataset(rctx, obj, fc.Args["input"].(CreateVersionedDatasetInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*VersionedDataset)
	fc.Result = res
	return ec.marshalNVersionedDataset2githubcomkubeagiarcadiaapiservergraphgeneratedVersionedDataset(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_VersionedDatasetMutation_createVersionedDataset(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "VersionedDatasetMutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_VersionedDataset_id(ctx, field)
			case "name":
				return ec.fieldContext_VersionedDataset_name(ctx, field)
			case "namespace":
				return ec.fieldContext_VersionedDataset_namespace(ctx, field)
			case "labels":
				return ec.fieldContext_VersionedDataset_labels(ctx, field)
			case "annotations":
				return ec.fieldContext_VersionedDataset_annotations(ctx, field)
			case "creator":
				return ec.fieldContext_VersionedDataset_creator(ctx, field)
			case "displayName":
				return ec.fieldContext_VersionedDataset_displayName(ctx, field)
			case "description":
				return ec.fieldContext_VersionedDataset_description(ctx, field)
			case "dataset":
				return ec.fieldContext_VersionedDataset_dataset(ctx, field)
			case "updateTimestamp":
				return ec.fieldContext_VersionedDataset_updateTimestamp(ctx, field)
			case "creationTimestamp":
				return ec.fieldContext_VersionedDataset_creationTimestamp(ctx, field)
			case "files":
				return ec.fieldContext_VersionedDataset_files(ctx, field)
			case "version":
				return ec.fieldContext_VersionedDataset_version(ctx, field)
			case "released":
				return ec.fieldContext_VersionedDataset_released(ctx, field)
			case "syncStatus":
				return ec.fieldContext_VersionedDataset_syncStatus(ctx, field)
			case "syncMsg":
				return ec.fieldContext_VersionedDataset_syncMsg(ctx, field)
			case "dataProcessStatus":
				return ec.fieldContext_VersionedDataset_dataProcessStatus(ctx, field)
			case "dataProcessMsg":
				return ec.fieldContext_VersionedDataset_dataProcessMsg(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type VersionedDataset", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_VersionedDatasetMutation_createVersionedDataset_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _VersionedDatasetMutation_updateVersionedDataset(ctx context.Context, field graphql.CollectedField, obj *VersionedDatasetMutation) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_VersionedDatasetMutation_updateVersionedDataset(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.VersionedDatasetMutation().UpdateVersionedDataset(rctx, obj, fc.Args["input"].(UpdateVersionedDatasetInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*VersionedDataset)
	fc.Result = res
	return ec.marshalNVersionedDataset2githubcomkubeagiarcadiaapiservergraphgeneratedVersionedDataset(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_VersionedDatasetMutation_updateVersionedDataset(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "VersionedDatasetMutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_VersionedDataset_id(ctx, field)
			case "name":
				return ec.fieldContext_VersionedDataset_name(ctx, field)
			case "namespace":
				return ec.fieldContext_VersionedDataset_namespace(ctx, field)
			case "labels":
				return ec.fieldContext_VersionedDataset_labels(ctx, field)
			case "annotations":
				return ec.fieldContext_VersionedDataset_annotations(ctx, field)
			case "creator":
				return ec.fieldContext_VersionedDataset_creator(ctx, field)
			case "displayName":
				return ec.fieldContext_VersionedDataset_displayName(ctx, field)
			case "description":
				return ec.fieldContext_VersionedDataset_description(ctx, field)
			case "dataset":
				return ec.fieldContext_VersionedDataset_dataset(ctx, field)
			case "updateTimestamp":
				return ec.fieldContext_VersionedDataset_updateTimestamp(ctx, field)
			case "creationTimestamp":
				return ec.fieldContext_VersionedDataset_creationTimestamp(ctx, field)
			case "files":
				return ec.fieldContext_VersionedDataset_files(ctx, field)
			case "version":
				return ec.fieldContext_VersionedDataset_version(ctx, field)
			case "released":
				return ec.fieldContext_VersionedDataset_released(ctx, field)
			case "syncStatus":
				return ec.fieldContext_VersionedDataset_syncStatus(ctx, field)
			case "syncMsg":
				return ec.fieldContext_VersionedDataset_syncMsg(ctx, field)
			case "dataProcessStatus":
				return ec.fieldContext_VersionedDataset_dataProcessStatus(ctx, field)
			case "dataProcessMsg":
				return ec.fieldContext_VersionedDataset_dataProcessMsg(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type VersionedDataset", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_VersionedDatasetMutation_updateVersionedDataset_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _VersionedDatasetMutation_deleteVersionedDatasets(ctx context.Context, field graphql.CollectedField, obj *VersionedDatasetMutation) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_VersionedDatasetMutation_deleteVersionedDatasets(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.VersionedDatasetMutation().DeleteVersionedDatasets(rctx, obj, fc.Args["input"].(DeleteVersionedDatasetInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOVoid2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_VersionedDatasetMutation_deleteVersionedDatasets(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "VersionedDatasetMutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Void does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_VersionedDatasetMutation_deleteVersionedDatasets_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _VersionedDatasetQuery_getVersionedDataset(ctx context.Context, field graphql.CollectedField, obj *VersionedDatasetQuery) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_VersionedDatasetQuery_getVersionedDataset(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.VersionedDatasetQuery().GetVersionedDataset(rctx, obj, fc.Args["name"].(string), fc.Args["namespace"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*VersionedDataset)
	fc.Result = res
	return ec.marshalNVersionedDataset2githubcomkubeagiarcadiaapiservergraphgeneratedVersionedDataset(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_VersionedDatasetQuery_getVersionedDataset(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "VersionedDatasetQuery",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_VersionedDataset_id(ctx, field)
			case "name":
				return ec.fieldContext_VersionedDataset_name(ctx, field)
			case "namespace":
				return ec.fieldContext_VersionedDataset_namespace(ctx, field)
			case "labels":
				return ec.fieldContext_VersionedDataset_labels(ctx, field)
			case "annotations":
				return ec.fieldContext_VersionedDataset_annotations(ctx, field)
			case "creator":
				return ec.fieldContext_VersionedDataset_creator(ctx, field)
			case "displayName":
				return ec.fieldContext_VersionedDataset_displayName(ctx, field)
			case "description":
				return ec.fieldContext_VersionedDataset_description(ctx, field)
			case "dataset":
				return ec.fieldContext_VersionedDataset_dataset(ctx, field)
			case "updateTimestamp":
				return ec.fieldContext_VersionedDataset_updateTimestamp(ctx, field)
			case "creationTimestamp":
				return ec.fieldContext_VersionedDataset_creationTimestamp(ctx, field)
			case "files":
				return ec.fieldContext_VersionedDataset_files(ctx, field)
			case "version":
				return ec.fieldContext_VersionedDataset_version(ctx, field)
			case "released":
				return ec.fieldContext_VersionedDataset_released(ctx, field)
			case "syncStatus":
				return ec.fieldContext_VersionedDataset_syncStatus(ctx, field)
			case "syncMsg":
				return ec.fieldContext_VersionedDataset_syncMsg(ctx, field)
			case "dataProcessStatus":
				return ec.fieldContext_VersionedDataset_dataProcessStatus(ctx, field)
			case "dataProcessMsg":
				return ec.fieldContext_VersionedDataset_dataProcessMsg(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type VersionedDataset", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_VersionedDatasetQuery_getVersionedDataset_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _VersionedDatasetQuery_listVersionedDatasets(ctx context.Context, field graphql.CollectedField, obj *VersionedDatasetQuery) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_VersionedDatasetQuery_listVersionedDatasets(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.VersionedDatasetQuery().ListVersionedDatasets(rctx, obj, fc.Args["input"].(ListVersionedDatasetInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*PaginatedResult)
	fc.Result = res
	return ec.marshalNPaginatedResult2githubcomkubeagiarcadiaapiservergraphgeneratedPaginatedResult(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_VersionedDatasetQuery_listVersionedDatasets(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "VersionedDatasetQuery",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "hasNextPage":
				return ec.fieldContext_PaginatedResult_hasNextPage(ctx, field)
			case "nodes":
				return ec.fieldContext_PaginatedResult_nodes(ctx, field)
			case "page":
				return ec.fieldContext_PaginatedResult_page(ctx, field)
			case "pageSize":
				return ec.fieldContext_PaginatedResult_pageSize(ctx, field)
			case "totalCount":
				return ec.fieldContext_PaginatedResult_totalCount(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type PaginatedResult", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_VersionedDatasetQuery_listVersionedDatasets_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Web_recommendIntervalTime(ctx context.Context, field graphql.CollectedField, obj *Web) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Web_recommendIntervalTime(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.RecommendIntervalTime, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalOInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Web_recommendIntervalTime(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Web",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Worker_id(ctx context.Context, field graphql.CollectedField, obj *Worker) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Worker_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Worker_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Worker",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Worker_name(ctx context.Context, field graphql.CollectedField, obj *Worker) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Worker_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Worker_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Worker",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Worker_namespace(ctx context.Context, field graphql.CollectedField, obj *Worker) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Worker_namespace(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Namespace, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Worker_namespace(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Worker",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Worker_labels(ctx context.Context, field graphql.CollectedField, obj *Worker) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Worker_labels(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Labels, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(map[string]interface{})
	fc.Result = res
	return ec.marshalOMap2map(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Worker_labels(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Worker",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Map does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Worker_annotations(ctx context.Context, field graphql.CollectedField, obj *Worker) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Worker_annotations(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Annotations, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(map[string]interface{})
	fc.Result = res
	return ec.marshalOMap2map(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Worker_annotations(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Worker",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Map does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Worker_creator(ctx context.Context, field graphql.CollectedField, obj *Worker) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Worker_creator(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Creator, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Worker_creator(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Worker",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Worker_displayName(ctx context.Context, field graphql.CollectedField, obj *Worker) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Worker_displayName(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DisplayName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Worker_displayName(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Worker",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Worker_description(ctx context.Context, field graphql.CollectedField, obj *Worker) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Worker_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Worker_description(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Worker",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Worker_creationTimestamp(ctx context.Context, field graphql.CollectedField, obj *Worker) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Worker_creationTimestamp(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CreationTimestamp, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*time.Time)
	fc.Result = res
	return ec.marshalOTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Worker_creationTimestamp(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Worker",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Worker_updateTimestamp(ctx context.Context, field graphql.CollectedField, obj *Worker) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Worker_updateTimestamp(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UpdateTimestamp, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*time.Time)
	fc.Result = res
	return ec.marshalOTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Worker_updateTimestamp(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Worker",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Worker_type(ctx context.Context, field graphql.CollectedField, obj *Worker) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Worker_type(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Type, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Worker_type(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Worker",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Worker_model(ctx context.Context, field graphql.CollectedField, obj *Worker) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Worker_model(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Model, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(TypedObjectReference)
	fc.Result = res
	return ec.marshalNTypedObjectReference2githubcomkubeagiarcadiaapiservergraphgeneratedTypedObjectReference(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Worker_model(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Worker",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "apiGroup":
				return ec.fieldContext_TypedObjectReference_apiGroup(ctx, field)
			case "kind":
				return ec.fieldContext_TypedObjectReference_kind(ctx, field)
			case "name":
				return ec.fieldContext_TypedObjectReference_name(ctx, field)
			case "displayName":
				return ec.fieldContext_TypedObjectReference_displayName(ctx, field)
			case "namespace":
				return ec.fieldContext_TypedObjectReference_namespace(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type TypedObjectReference", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Worker_modelTypes(ctx context.Context, field graphql.CollectedField, obj *Worker) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Worker_modelTypes(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ModelTypes, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Worker_modelTypes(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Worker",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Worker_replicas(ctx context.Context, field graphql.CollectedField, obj *Worker) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Worker_replicas(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Replicas, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Worker_replicas(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Worker",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Worker_resources(ctx context.Context, field graphql.CollectedField, obj *Worker) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Worker_resources(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Resources, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(Resources)
	fc.Result = res
	return ec.marshalNResources2githubcomkubeagiarcadiaapiservergraphgeneratedResources(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Worker_resources(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Worker",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "cpu":
				return ec.fieldContext_Resources_cpu(ctx, field)
			case "memory":
				return ec.fieldContext_Resources_memory(ctx, field)
			case "nvidiaGPU":
				return ec.fieldContext_Resources_nvidiaGPU(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Resources", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Worker_status(ctx context.Context, field graphql.CollectedField, obj *Worker) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Worker_status(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Status, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Worker_status(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Worker",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Worker_message(ctx context.Context, field graphql.CollectedField, obj *Worker) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Worker_message(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Message, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Worker_message(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Worker",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Worker_api(ctx context.Context, field graphql.CollectedField, obj *Worker) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Worker_api(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.API, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Worker_api(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Worker",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Worker_matchExpressions(ctx context.Context, field graphql.CollectedField, obj *Worker) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Worker_matchExpressions(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MatchExpressions, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*NodeSelectorRequirement)
	fc.Result = res
	return ec.marshalONodeSelectorRequirement2githubcomkubeagiarcadiaapiservergraphgeneratedNodeSelectorRequirement(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Worker_matchExpressions(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Worker",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "key":
				return ec.fieldContext_NodeSelectorRequirement_key(ctx, field)
			case "operator":
				return ec.fieldContext_NodeSelectorRequirement_operator(ctx, field)
			case "values":
				return ec.fieldContext_NodeSelectorRequirement_values(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type NodeSelectorRequirement", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Worker_additionalEnvs(ctx context.Context, field graphql.CollectedField, obj *Worker) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Worker_additionalEnvs(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AdditionalEnvs, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(map[string]interface{})
	fc.Result = res
	return ec.marshalOMap2map(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Worker_additionalEnvs(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Worker",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Map does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _WorkerMutation_createWorker(ctx context.Context, field graphql.CollectedField, obj *WorkerMutation) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_WorkerMutation_createWorker(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.WorkerMutation().CreateWorker(rctx, obj, fc.Args["input"].(CreateWorkerInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*Worker)
	fc.Result = res
	return ec.marshalNWorker2githubcomkubeagiarcadiaapiservergraphgeneratedWorker(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_WorkerMutation_createWorker(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "WorkerMutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Worker_id(ctx, field)
			case "name":
				return ec.fieldContext_Worker_name(ctx, field)
			case "namespace":
				return ec.fieldContext_Worker_namespace(ctx, field)
			case "labels":
				return ec.fieldContext_Worker_labels(ctx, field)
			case "annotations":
				return ec.fieldContext_Worker_annotations(ctx, field)
			case "creator":
				return ec.fieldContext_Worker_creator(ctx, field)
			case "displayName":
				return ec.fieldContext_Worker_displayName(ctx, field)
			case "description":
				return ec.fieldContext_Worker_description(ctx, field)
			case "creationTimestamp":
				return ec.fieldContext_Worker_creationTimestamp(ctx, field)
			case "updateTimestamp":
				return ec.fieldContext_Worker_updateTimestamp(ctx, field)
			case "type":
				return ec.fieldContext_Worker_type(ctx, field)
			case "model":
				return ec.fieldContext_Worker_model(ctx, field)
			case "modelTypes":
				return ec.fieldContext_Worker_modelTypes(ctx, field)
			case "replicas":
				return ec.fieldContext_Worker_replicas(ctx, field)
			case "resources":
				return ec.fieldContext_Worker_resources(ctx, field)
			case "status":
				return ec.fieldContext_Worker_status(ctx, field)
			case "message":
				return ec.fieldContext_Worker_message(ctx, field)
			case "api":
				return ec.fieldContext_Worker_api(ctx, field)
			case "matchExpressions":
				return ec.fieldContext_Worker_matchExpressions(ctx, field)
			case "additionalEnvs":
				return ec.fieldContext_Worker_additionalEnvs(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Worker", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_WorkerMutation_createWorker_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _WorkerMutation_updateWorker(ctx context.Context, field graphql.CollectedField, obj *WorkerMutation) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_WorkerMutation_updateWorker(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.WorkerMutation().UpdateWorker(rctx, obj, fc.Args["input"].(*UpdateWorkerInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*Worker)
	fc.Result = res
	return ec.marshalNWorker2githubcomkubeagiarcadiaapiservergraphgeneratedWorker(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_WorkerMutation_updateWorker(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "WorkerMutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Worker_id(ctx, field)
			case "name":
				return ec.fieldContext_Worker_name(ctx, field)
			case "namespace":
				return ec.fieldContext_Worker_namespace(ctx, field)
			case "labels":
				return ec.fieldContext_Worker_labels(ctx, field)
			case "annotations":
				return ec.fieldContext_Worker_annotations(ctx, field)
			case "creator":
				return ec.fieldContext_Worker_creator(ctx, field)
			case "displayName":
				return ec.fieldContext_Worker_displayName(ctx, field)
			case "description":
				return ec.fieldContext_Worker_description(ctx, field)
			case "creationTimestamp":
				return ec.fieldContext_Worker_creationTimestamp(ctx, field)
			case "updateTimestamp":
				return ec.fieldContext_Worker_updateTimestamp(ctx, field)
			case "type":
				return ec.fieldContext_Worker_type(ctx, field)
			case "model":
				return ec.fieldContext_Worker_model(ctx, field)
			case "modelTypes":
				return ec.fieldContext_Worker_modelTypes(ctx, field)
			case "replicas":
				return ec.fieldContext_Worker_replicas(ctx, field)
			case "resources":
				return ec.fieldContext_Worker_resources(ctx, field)
			case "status":
				return ec.fieldContext_Worker_status(ctx, field)
			case "message":
				return ec.fieldContext_Worker_message(ctx, field)
			case "api":
				return ec.fieldContext_Worker_api(ctx, field)
			case "matchExpressions":
				return ec.fieldContext_Worker_matchExpressions(ctx, field)
			case "additionalEnvs":
				return ec.fieldContext_Worker_additionalEnvs(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Worker", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_WorkerMutation_updateWorker_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _WorkerMutation_deleteWorkers(ctx context.Context, field graphql.CollectedField, obj *WorkerMutation) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_WorkerMutation_deleteWorkers(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.WorkerMutation().DeleteWorkers(rctx, obj, fc.Args["input"].(*DeleteCommonInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOVoid2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_WorkerMutation_deleteWorkers(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "WorkerMutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Void does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_WorkerMutation_deleteWorkers_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _WorkerQuery_getWorker(ctx context.Context, field graphql.CollectedField, obj *WorkerQuery) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_WorkerQuery_getWorker(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.WorkerQuery().GetWorker(rctx, obj, fc.Args["name"].(string), fc.Args["namespace"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*Worker)
	fc.Result = res
	return ec.marshalNWorker2githubcomkubeagiarcadiaapiservergraphgeneratedWorker(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_WorkerQuery_getWorker(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "WorkerQuery",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Worker_id(ctx, field)
			case "name":
				return ec.fieldContext_Worker_name(ctx, field)
			case "namespace":
				return ec.fieldContext_Worker_namespace(ctx, field)
			case "labels":
				return ec.fieldContext_Worker_labels(ctx, field)
			case "annotations":
				return ec.fieldContext_Worker_annotations(ctx, field)
			case "creator":
				return ec.fieldContext_Worker_creator(ctx, field)
			case "displayName":
				return ec.fieldContext_Worker_displayName(ctx, field)
			case "description":
				return ec.fieldContext_Worker_description(ctx, field)
			case "creationTimestamp":
				return ec.fieldContext_Worker_creationTimestamp(ctx, field)
			case "updateTimestamp":
				return ec.fieldContext_Worker_updateTimestamp(ctx, field)
			case "type":
				return ec.fieldContext_Worker_type(ctx, field)
			case "model":
				return ec.fieldContext_Worker_model(ctx, field)
			case "modelTypes":
				return ec.fieldContext_Worker_modelTypes(ctx, field)
			case "replicas":
				return ec.fieldContext_Worker_replicas(ctx, field)
			case "resources":
				return ec.fieldContext_Worker_resources(ctx, field)
			case "status":
				return ec.fieldContext_Worker_status(ctx, field)
			case "message":
				return ec.fieldContext_Worker_message(ctx, field)
			case "api":
				return ec.fieldContext_Worker_api(ctx, field)
			case "matchExpressions":
				return ec.fieldContext_Worker_matchExpressions(ctx, field)
			case "additionalEnvs":
				return ec.fieldContext_Worker_additionalEnvs(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Worker", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_WorkerQuery_getWorker_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _WorkerQuery_listWorkers(ctx context.Context, field graphql.CollectedField, obj *WorkerQuery) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_WorkerQuery_listWorkers(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.WorkerQuery().ListWorkers(rctx, obj, fc.Args["input"].(ListWorkerInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*PaginatedResult)
	fc.Result = res
	return ec.marshalNPaginatedResult2githubcomkubeagiarcadiaapiservergraphgeneratedPaginatedResult(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_WorkerQuery_listWorkers(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "WorkerQuery",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "hasNextPage":
				return ec.fieldContext_PaginatedResult_hasNextPage(ctx, field)
			case "nodes":
				return ec.fieldContext_PaginatedResult_nodes(ctx, field)
			case "page":
				return ec.fieldContext_PaginatedResult_page(ctx, field)
			case "pageSize":
				return ec.fieldContext_PaginatedResult_pageSize(ctx, field)
			case "totalCount":
				return ec.fieldContext_PaginatedResult_totalCount(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type PaginatedResult", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_WorkerQuery_listWorkers_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) ___Directive_name(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Directive_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Directive_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Directive",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Directive_description(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Directive_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Directive_description(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Directive",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Directive_locations(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Directive_locations(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Locations, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalN__DirectiveLocation2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Directive_locations(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Directive",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type __DirectiveLocation does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Directive_args(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Directive_args(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Args, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]introspection.InputValue)
	fc.Result = res
	return ec.marshalN__InputValue2githubcom99designsgqlgengraphqlintrospectionInputValue(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Directive_args(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Directive",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext___InputValue_name(ctx, field)
			case "description":
				return ec.fieldContext___InputValue_description(ctx, field)
			case "type":
				return ec.fieldContext___InputValue_type(ctx, field)
			case "defaultValue":
				return ec.fieldContext___InputValue_defaultValue(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __InputValue", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Directive_isRepeatable(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Directive_isRepeatable(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsRepeatable, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Directive_isRepeatable(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Directive",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___EnumValue_name(ctx context.Context, field graphql.CollectedField, obj *introspection.EnumValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___EnumValue_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___EnumValue_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__EnumValue",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___EnumValue_description(ctx context.Context, field graphql.CollectedField, obj *introspection.EnumValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___EnumValue_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___EnumValue_description(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__EnumValue",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___EnumValue_isDeprecated(ctx context.Context, field graphql.CollectedField, obj *introspection.EnumValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___EnumValue_isDeprecated(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsDeprecated(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___EnumValue_isDeprecated(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__EnumValue",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___EnumValue_deprecationReason(ctx context.Context, field graphql.CollectedField, obj *introspection.EnumValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___EnumValue_deprecationReason(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DeprecationReason(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___EnumValue_deprecationReason(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__EnumValue",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Field_name(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Field_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Field_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Field",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Field_description(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Field_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Field_description(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Field",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Field_args(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Field_args(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Args, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]introspection.InputValue)
	fc.Result = res
	return ec.marshalN__InputValue2githubcom99designsgqlgengraphqlintrospectionInputValue(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Field_args(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Field",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext___InputValue_name(ctx, field)
			case "description":
				return ec.fieldContext___InputValue_description(ctx, field)
			case "type":
				return ec.fieldContext___InputValue_type(ctx, field)
			case "defaultValue":
				return ec.fieldContext___InputValue_defaultValue(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __InputValue", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Field_type(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Field_type(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Type, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalN__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Field_type(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Field",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Field_isDeprecated(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Field_isDeprecated(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsDeprecated(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Field_isDeprecated(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Field",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Field_deprecationReason(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Field_deprecationReason(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DeprecationReason(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Field_deprecationReason(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Field",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___InputValue_name(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___InputValue_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___InputValue_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__InputValue",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___InputValue_description(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___InputValue_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___InputValue_description(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__InputValue",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___InputValue_type(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___InputValue_type(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Type, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalN__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___InputValue_type(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__InputValue",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___InputValue_defaultValue(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___InputValue_defaultValue(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DefaultValue, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___InputValue_defaultValue(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__InputValue",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Schema_description(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Schema_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Schema_description(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Schema",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Schema_types(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Schema_types(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Types(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]introspection.Type)
	fc.Result = res
	return ec.marshalN__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Schema_types(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Schema",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Schema_queryType(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Schema_queryType(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.QueryType(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalN__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Schema_queryType(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Schema",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Schema_mutationType(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Schema_mutationType(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MutationType(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalO__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Schema_mutationType(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Schema",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Schema_subscriptionType(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Schema_subscriptionType(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SubscriptionType(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalO__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Schema_subscriptionType(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Schema",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Schema_directives(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Schema_directives(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Directives(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]introspection.Directive)
	fc.Result = res
	return ec.marshalN__Directive2githubcom99designsgqlgengraphqlintrospectionDirective(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Schema_directives(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Schema",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext___Directive_name(ctx, field)
			case "description":
				return ec.fieldContext___Directive_description(ctx, field)
			case "locations":
				return ec.fieldContext___Directive_locations(ctx, field)
			case "args":
				return ec.fieldContext___Directive_args(ctx, field)
			case "isRepeatable":
				return ec.fieldContext___Directive_isRepeatable(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Directive", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_kind(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_kind(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Kind(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalN__TypeKind2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_kind(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type __TypeKind does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_name(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_description(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_description(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_fields(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_fields(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Fields(fc.Args["includeDeprecated"].(bool)), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]introspection.Field)
	fc.Result = res
	return ec.marshalO__Field2githubcom99designsgqlgengraphqlintrospectionField(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_fields(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext___Field_name(ctx, field)
			case "description":
				return ec.fieldContext___Field_description(ctx, field)
			case "args":
				return ec.fieldContext___Field_args(ctx, field)
			case "type":
				return ec.fieldContext___Field_type(ctx, field)
			case "isDeprecated":
				return ec.fieldContext___Field_isDeprecated(ctx, field)
			case "deprecationReason":
				return ec.fieldContext___Field_deprecationReason(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Field", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field___Type_fields_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) ___Type_interfaces(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_interfaces(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Interfaces(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]introspection.Type)
	fc.Result = res
	return ec.marshalO__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_interfaces(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_possibleTypes(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_possibleTypes(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PossibleTypes(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]introspection.Type)
	fc.Result = res
	return ec.marshalO__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_possibleTypes(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_enumValues(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_enumValues(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.EnumValues(fc.Args["includeDeprecated"].(bool)), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]introspection.EnumValue)
	fc.Result = res
	return ec.marshalO__EnumValue2githubcom99designsgqlgengraphqlintrospectionEnumValue(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_enumValues(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext___EnumValue_name(ctx, field)
			case "description":
				return ec.fieldContext___EnumValue_description(ctx, field)
			case "isDeprecated":
				return ec.fieldContext___EnumValue_isDeprecated(ctx, field)
			case "deprecationReason":
				return ec.fieldContext___EnumValue_deprecationReason(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __EnumValue", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field___Type_enumValues_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) ___Type_inputFields(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_inputFields(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.InputFields(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]introspection.InputValue)
	fc.Result = res
	return ec.marshalO__InputValue2githubcom99designsgqlgengraphqlintrospectionInputValue(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_inputFields(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext___InputValue_name(ctx, field)
			case "description":
				return ec.fieldContext___InputValue_description(ctx, field)
			case "type":
				return ec.fieldContext___InputValue_type(ctx, field)
			case "defaultValue":
				return ec.fieldContext___InputValue_defaultValue(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __InputValue", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_ofType(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_ofType(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.OfType(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalO__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_ofType(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_specifiedByURL(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_specifiedByURL(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SpecifiedByURL(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_specifiedByURL(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _filedetail_path(ctx context.Context, field graphql.CollectedField, obj *Filedetail) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_filedetail_path(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Path, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_filedetail_path(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "filedetail",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _filedetail_fileType(ctx context.Context, field graphql.CollectedField, obj *Filedetail) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_filedetail_fileType(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.FileType, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_filedetail_fileType(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "filedetail",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _filedetail_count(ctx context.Context, field graphql.CollectedField, obj *Filedetail) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_filedetail_count(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Count, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_filedetail_count(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "filedetail",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _filedetail_size(ctx context.Context, field graphql.CollectedField, obj *Filedetail) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_filedetail_size(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Size, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_filedetail_size(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "filedetail",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _filedetail_updateTimestamp(ctx context.Context, field graphql.CollectedField, obj *Filedetail) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_filedetail_updateTimestamp(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UpdateTimestamp, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*time.Time)
	fc.Result = res
	return ec.marshalOTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_filedetail_updateTimestamp(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "filedetail",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _filedetail_timeCost(ctx context.Context, field graphql.CollectedField, obj *Filedetail) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_filedetail_timeCost(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TimeCost, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_filedetail_timeCost(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "filedetail",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _filedetail_phase(ctx context.Context, field graphql.CollectedField, obj *Filedetail) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_filedetail_phase(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Phase, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_filedetail_phase(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "filedetail",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _filegroup_source(ctx context.Context, field graphql.CollectedField, obj *Filegroup) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_filegroup_source(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Source, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*TypedObjectReference)
	fc.Result = res
	return ec.marshalOTypedObjectReference2githubcomkubeagiarcadiaapiservergraphgeneratedTypedObjectReference(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_filegroup_source(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "filegroup",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "apiGroup":
				return ec.fieldContext_TypedObjectReference_apiGroup(ctx, field)
			case "kind":
				return ec.fieldContext_TypedObjectReference_kind(ctx, field)
			case "name":
				return ec.fieldContext_TypedObjectReference_name(ctx, field)
			case "displayName":
				return ec.fieldContext_TypedObjectReference_displayName(ctx, field)
			case "namespace":
				return ec.fieldContext_TypedObjectReference_namespace(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type TypedObjectReference", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _filegroup_path(ctx context.Context, field graphql.CollectedField, obj *Filegroup) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_filegroup_path(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Path, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_filegroup_path(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "filegroup",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _filegroupdetail_source(ctx context.Context, field graphql.CollectedField, obj *Filegroupdetail) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_filegroupdetail_source(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Source, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*TypedObjectReference)
	fc.Result = res
	return ec.marshalOTypedObjectReference2githubcomkubeagiarcadiaapiservergraphgeneratedTypedObjectReference(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_filegroupdetail_source(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "filegroupdetail",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "apiGroup":
				return ec.fieldContext_TypedObjectReference_apiGroup(ctx, field)
			case "kind":
				return ec.fieldContext_TypedObjectReference_kind(ctx, field)
			case "name":
				return ec.fieldContext_TypedObjectReference_name(ctx, field)
			case "displayName":
				return ec.fieldContext_TypedObjectReference_displayName(ctx, field)
			case "namespace":
				return ec.fieldContext_TypedObjectReference_namespace(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type TypedObjectReference", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _filegroupdetail_filedetails(ctx context.Context, field graphql.CollectedField, obj *Filegroupdetail) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_filegroupdetail_filedetails(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Filedetails, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*Filedetail)
	fc.Result = res
	return ec.marshalOfiledetail2githubcomkubeagiarcadiaapiservergraphgeneratedFiledetail(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_filegroupdetail_filedetails(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "filegroupdetail",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "path":
				return ec.fieldContext_filedetail_path(ctx, field)
			case "fileType":
				return ec.fieldContext_filedetail_fileType(ctx, field)
			case "count":
				return ec.fieldContext_filedetail_count(ctx, field)
			case "size":
				return ec.fieldContext_filedetail_size(ctx, field)
			case "updateTimestamp":
				return ec.fieldContext_filedetail_updateTimestamp(ctx, field)
			case "timeCost":
				return ec.fieldContext_filedetail_timeCost(ctx, field)
			case "phase":
				return ec.fieldContext_filedetail_phase(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type filedetail", field.Name)
		},
	}
	return fc, nil
}

// endregion **************************** field.gotpl *****************************

// region    **************************** input.gotpl *****************************

func (ec *executionContext) unmarshalInputAddDataProcessInput(ctx context.Context, obj interface{}) (AddDataProcessInput, error) {
	var it AddDataProcessInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"name", "file_type", "pre_data_set_name", "pre_data_set_version", "file_names", "post_data_set_name", "post_data_set_version", "data_process_config_info", "version_data_set_name", "namespace", "creator"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "name":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Name = data
		case "file_type":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("file_type"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.FileType = data
		case "pre_data_set_name":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("pre_data_set_name"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.PreDataSetName = data
		case "pre_data_set_version":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("pre_data_set_version"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.PreDataSetVersion = data
		case "file_names":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("file_names"))
			data, err := ec.unmarshalOFileItem2githubcomkubeagiarcadiaapiservergraphgeneratedFileItem(ctx, v)
			if err != nil {
				return it, err
			}
			it.FileNames = data
		case "post_data_set_name":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("post_data_set_name"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.PostDataSetName = data
		case "post_data_set_version":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("post_data_set_version"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.PostDataSetVersion = data
		case "data_process_config_info":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("data_process_config_info"))
			data, err := ec.unmarshalODataProcessConfigItem2githubcomkubeagiarcadiaapiservergraphgeneratedDataProcessConfigItem(ctx, v)
			if err != nil {
				return it, err
			}
			it.DataProcessConfigInfo = data
		case "version_data_set_name":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("version_data_set_name"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.VersionDataSetName = data
		case "namespace":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("namespace"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Namespace = data
		case "creator":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("creator"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Creator = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputAllDataProcessListByCountInput(ctx context.Context, obj interface{}) (AllDataProcessListByCountInput, error) {
	var it AllDataProcessListByCountInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"keyword", "namespace"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "keyword":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("keyword"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Keyword = data
		case "namespace":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("namespace"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Namespace = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputAllDataProcessListByPageInput(ctx context.Context, obj interface{}) (AllDataProcessListByPageInput, error) {
	var it AllDataProcessListByPageInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"pageIndex", "pageSize", "keyword", "namespace"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "pageIndex":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("pageIndex"))
			data, err := ec.unmarshalNInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.PageIndex = data
		case "pageSize":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("pageSize"))
			data, err := ec.unmarshalNInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.PageSize = data
		case "keyword":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("keyword"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Keyword = data
		case "namespace":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("namespace"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Namespace = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputCheckDataProcessTaskNameInput(ctx context.Context, obj interface{}) (CheckDataProcessTaskNameInput, error) {
	var it CheckDataProcessTaskNameInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"name", "namespace"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "name":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Name = data
		case "namespace":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("namespace"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Namespace = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputCreateApplicationMetadataInput(ctx context.Context, obj interface{}) (CreateApplicationMetadataInput, error) {
	var it CreateApplicationMetadataInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"name", "namespace", "labels", "annotations", "displayName", "description", "icon", "isPublic", "category"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "name":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Name = data
		case "namespace":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("namespace"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Namespace = data
		case "labels":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("labels"))
			data, err := ec.unmarshalOMap2map(ctx, v)
			if err != nil {
				return it, err
			}
			it.Labels = data
		case "annotations":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("annotations"))
			data, err := ec.unmarshalOMap2map(ctx, v)
			if err != nil {
				return it, err
			}
			it.Annotations = data
		case "displayName":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("displayName"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.DisplayName = data
		case "description":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("description"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Description = data
		case "icon":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("icon"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Icon = data
		case "isPublic":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("isPublic"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.IsPublic = data
		case "category":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("category"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Category = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputCreateDatasetInput(ctx context.Context, obj interface{}) (CreateDatasetInput, error) {
	var it CreateDatasetInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"name", "namespace", "labels", "annotations", "displayName", "description", "contentType", "filed"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "name":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Name = data
		case "namespace":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("namespace"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Namespace = data
		case "labels":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("labels"))
			data, err := ec.unmarshalOMap2map(ctx, v)
			if err != nil {
				return it, err
			}
			it.Labels = data
		case "annotations":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("annotations"))
			data, err := ec.unmarshalOMap2map(ctx, v)
			if err != nil {
				return it, err
			}
			it.Annotations = data
		case "displayName":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("displayName"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.DisplayName = data
		case "description":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("description"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Description = data
		case "contentType":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("contentType"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.ContentType = data
		case "filed":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("filed"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Filed = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputCreateDatasourceInput(ctx context.Context, obj interface{}) (CreateDatasourceInput, error) {
	var it CreateDatasourceInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"name", "namespace", "labels", "annotations", "displayName", "description", "endpointinput", "ossinput", "webinput"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "name":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Name = data
		case "namespace":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("namespace"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Namespace = data
		case "labels":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("labels"))
			data, err := ec.unmarshalOMap2map(ctx, v)
			if err != nil {
				return it, err
			}
			it.Labels = data
		case "annotations":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("annotations"))
			data, err := ec.unmarshalOMap2map(ctx, v)
			if err != nil {
				return it, err
			}
			it.Annotations = data
		case "displayName":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("displayName"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.DisplayName = data
		case "description":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("description"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Description = data
		case "endpointinput":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("endpointinput"))
			data, err := ec.unmarshalNEndpointInput2githubcomkubeagiarcadiaapiservergraphgeneratedEndpointInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.Endpointinput = data
		case "ossinput":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("ossinput"))
			data, err := ec.unmarshalOOssInput2githubcomkubeagiarcadiaapiservergraphgeneratedOssInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.Ossinput = data
		case "webinput":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("webinput"))
			data, err := ec.unmarshalOWebInput2githubcomkubeagiarcadiaapiservergraphgeneratedWebInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.Webinput = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputCreateEmbedderInput(ctx context.Context, obj interface{}) (CreateEmbedderInput, error) {
	var it CreateEmbedderInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"name", "namespace", "labels", "annotations", "displayName", "description", "endpointinput", "type", "models"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "name":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Name = data
		case "namespace":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("namespace"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Namespace = data
		case "labels":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("labels"))
			data, err := ec.unmarshalOMap2map(ctx, v)
			if err != nil {
				return it, err
			}
			it.Labels = data
		case "annotations":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("annotations"))
			data, err := ec.unmarshalOMap2map(ctx, v)
			if err != nil {
				return it, err
			}
			it.Annotations = data
		case "displayName":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("displayName"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.DisplayName = data
		case "description":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("description"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Description = data
		case "endpointinput":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("endpointinput"))
			data, err := ec.unmarshalNEndpointInput2githubcomkubeagiarcadiaapiservergraphgeneratedEndpointInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.Endpointinput = data
		case "type":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("type"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Type = data
		case "models":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("models"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Models = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputCreateKnowledgeBaseInput(ctx context.Context, obj interface{}) (CreateKnowledgeBaseInput, error) {
	var it CreateKnowledgeBaseInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"name", "namespace", "labels", "annotations", "displayName", "description", "embedder", "vectorStore", "fileGroups", "chunkSize", "chunkOverlap", "batchSize"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "name":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Name = data
		case "namespace":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("namespace"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Namespace = data
		case "labels":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("labels"))
			data, err := ec.unmarshalOMap2map(ctx, v)
			if err != nil {
				return it, err
			}
			it.Labels = data
		case "annotations":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("annotations"))
			data, err := ec.unmarshalOMap2map(ctx, v)
			if err != nil {
				return it, err
			}
			it.Annotations = data
		case "displayName":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("displayName"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.DisplayName = data
		case "description":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("description"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Description = data
		case "embedder":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("embedder"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Embedder = data
		case "vectorStore":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("vectorStore"))
			data, err := ec.unmarshalOTypedObjectReferenceInput2githubcomkubeagiarcadiaapiservergraphgeneratedTypedObjectReferenceInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.VectorStore = data
		case "fileGroups":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("fileGroups"))
			data, err := ec.unmarshalOfilegroupinput2githubcomkubeagiarcadiaapiservergraphgeneratedFilegroupinput(ctx, v)
			if err != nil {
				return it, err
			}
			it.FileGroups = data
		case "chunkSize":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("chunkSize"))
			data, err := ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.ChunkSize = data
		case "chunkOverlap":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("chunkOverlap"))
			data, err := ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.ChunkOverlap = data
		case "batchSize":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("batchSize"))
			data, err := ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.BatchSize = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputCreateLLMInput(ctx context.Context, obj interface{}) (CreateLLMInput, error) {
	var it CreateLLMInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"name", "namespace", "labels", "annotations", "displayName", "description", "endpointinput", "type", "models"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "name":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Name = data
		case "namespace":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("namespace"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Namespace = data
		case "labels":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("labels"))
			data, err := ec.unmarshalOMap2map(ctx, v)
			if err != nil {
				return it, err
			}
			it.Labels = data
		case "annotations":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("annotations"))
			data, err := ec.unmarshalOMap2map(ctx, v)
			if err != nil {
				return it, err
			}
			it.Annotations = data
		case "displayName":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("displayName"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.DisplayName = data
		case "description":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("description"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Description = data
		case "endpointinput":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("endpointinput"))
			data, err := ec.unmarshalNEndpointInput2githubcomkubeagiarcadiaapiservergraphgeneratedEndpointInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.Endpointinput = data
		case "type":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("type"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Type = data
		case "models":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("models"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Models = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputCreateModelInput(ctx context.Context, obj interface{}) (CreateModelInput, error) {
	var it CreateModelInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"name", "namespace", "displayName", "description", "types", "huggingFaceRepo", "modelScopeRepo", "revision", "modelSource"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "name":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Name = data
		case "namespace":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("namespace"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Namespace = data
		case "displayName":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("displayName"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.DisplayName = data
		case "description":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("description"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Description = data
		case "types":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("types"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Types = data
		case "huggingFaceRepo":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("huggingFaceRepo"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.HuggingFaceRepo = data
		case "modelScopeRepo":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("modelScopeRepo"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.ModelScopeRepo = data
		case "revision":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("revision"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Revision = data
		case "modelSource":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("modelSource"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.ModelSource = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputCreateModelServiceInput(ctx context.Context, obj interface{}) (CreateModelServiceInput, error) {
	var it CreateModelServiceInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"name", "namespace", "labels", "annotations", "displayName", "description", "types", "apiType", "endpoint", "llmModels", "embeddingModels"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "name":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Name = data
		case "namespace":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("namespace"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Namespace = data
		case "labels":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("labels"))
			data, err := ec.unmarshalOMap2map(ctx, v)
			if err != nil {
				return it, err
			}
			it.Labels = data
		case "annotations":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("annotations"))
			data, err := ec.unmarshalOMap2map(ctx, v)
			if err != nil {
				return it, err
			}
			it.Annotations = data
		case "displayName":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("displayName"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.DisplayName = data
		case "description":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("description"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Description = data
		case "types":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("types"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Types = data
		case "apiType":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("apiType"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.APIType = data
		case "endpoint":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("endpoint"))
			data, err := ec.unmarshalNEndpointInput2githubcomkubeagiarcadiaapiservergraphgeneratedEndpointInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.Endpoint = data
		case "llmModels":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("llmModels"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.LlmModels = data
		case "embeddingModels":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("embeddingModels"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.EmbeddingModels = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputCreateRAGInput(ctx context.Context, obj interface{}) (CreateRAGInput, error) {
	var it CreateRAGInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"name", "namespace", "labels", "annotations", "creator", "displayName", "description", "application", "datasets", "judgeLLM", "metrics", "storage", "serviceAccountName", "suspend"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "name":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Name = data
		case "namespace":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("namespace"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Namespace = data
		case "labels":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("labels"))
			data, err := ec.unmarshalOMap2map(ctx, v)
			if err != nil {
				return it, err
			}
			it.Labels = data
		case "annotations":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("annotations"))
			data, err := ec.unmarshalOMap2map(ctx, v)
			if err != nil {
				return it, err
			}
			it.Annotations = data
		case "creator":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("creator"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Creator = data
		case "displayName":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("displayName"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.DisplayName = data
		case "description":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("description"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Description = data
		case "application":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("application"))
			data, err := ec.unmarshalNTypedObjectReferenceInput2githubcomkubeagiarcadiaapiservergraphgeneratedTypedObjectReferenceInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.Application = data
		case "datasets":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("datasets"))
			data, err := ec.unmarshalNRAGDatasetInput2githubcomkubeagiarcadiaapiservergraphgeneratedRAGDatasetInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.Datasets = data
		case "judgeLLM":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("judgeLLM"))
			data, err := ec.unmarshalNTypedObjectReferenceInput2githubcomkubeagiarcadiaapiservergraphgeneratedTypedObjectReferenceInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.JudgeLlm = data
		case "metrics":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("metrics"))
			data, err := ec.unmarshalNRAGMetricInput2githubcomkubeagiarcadiaapiservergraphgeneratedRAGMetricInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.Metrics = data
		case "storage":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("storage"))
			data, err := ec.unmarshalOPersistentVolumeClaimSpecInput2githubcomkubeagiarcadiaapiservergraphgeneratedPersistentVolumeClaimSpecInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.Storage = data
		case "serviceAccountName":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("serviceAccountName"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.ServiceAccountName = data
		case "suspend":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("suspend"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.Suspend = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputCreateVersionedDatasetInput(ctx context.Context, obj interface{}) (CreateVersionedDatasetInput, error) {
	var it CreateVersionedDatasetInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"name", "namespace", "datasetName", "labels", "annotations", "displayName", "description", "version", "released", "fileGrups", "inheritedFrom"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "name":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Name = data
		case "namespace":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("namespace"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Namespace = data
		case "datasetName":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("datasetName"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.DatasetName = data
		case "labels":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("labels"))
			data, err := ec.unmarshalOMap2map(ctx, v)
			if err != nil {
				return it, err
			}
			it.Labels = data
		case "annotations":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("annotations"))
			data, err := ec.unmarshalOMap2map(ctx, v)
			if err != nil {
				return it, err
			}
			it.Annotations = data
		case "displayName":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("displayName"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.DisplayName = data
		case "description":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("description"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Description = data
		case "version":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("version"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Version = data
		case "released":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("released"))
			data, err := ec.unmarshalNInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.Released = data
		case "fileGrups":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("fileGrups"))
			data, err := ec.unmarshalOFileGroup2githubcomkubeagiarcadiaapiservergraphgeneratedFileGroup(ctx, v)
			if err != nil {
				return it, err
			}
			it.FileGrups = data
		case "inheritedFrom":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("inheritedFrom"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.InheritedFrom = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputCreateWorkerInput(ctx context.Context, obj interface{}) (CreateWorkerInput, error) {
	var it CreateWorkerInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"name", "namespace", "displayName", "description", "type", "model", "resources", "matchExpressions", "additionalEnvs"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "name":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Name = data
		case "namespace":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("namespace"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Namespace = data
		case "displayName":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("displayName"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.DisplayName = data
		case "description":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("description"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Description = data
		case "type":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("type"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Type = data
		case "model":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("model"))
			data, err := ec.unmarshalNTypedObjectReferenceInput2githubcomkubeagiarcadiaapiservergraphgeneratedTypedObjectReferenceInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.Model = data
		case "resources":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("resources"))
			data, err := ec.unmarshalNResourcesInput2githubcomkubeagiarcadiaapiservergraphgeneratedResourcesInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.Resources = data
		case "matchExpressions":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("matchExpressions"))
			data, err := ec.unmarshalONodeSelectorRequirementInput2githubcomkubeagiarcadiaapiservergraphgeneratedNodeSelectorRequirementInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.MatchExpressions = data
		case "additionalEnvs":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("additionalEnvs"))
			data, err := ec.unmarshalOMap2map(ctx, v)
			if err != nil {
				return it, err
			}
			it.AdditionalEnvs = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputDataProcessConfigItem(ctx context.Context, obj interface{}) (DataProcessConfigItem, error) {
	var it DataProcessConfigItem
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"type", "chunk_size", "chunk_overlap", "llm_config", "remove_duplicate_config"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "type":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("type"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Type = data
		case "chunk_size":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("chunk_size"))
			data, err := ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.ChunkSize = data
		case "chunk_overlap":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("chunk_overlap"))
			data, err := ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.ChunkOverlap = data
		case "llm_config":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("llm_config"))
			data, err := ec.unmarshalOLLMConfigItem2githubcomkubeagiarcadiaapiservergraphgeneratedLLMConfigItem(ctx, v)
			if err != nil {
				return it, err
			}
			it.LlmConfig = data
		case "remove_duplicate_config":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("remove_duplicate_config"))
			data, err := ec.unmarshalORemoveDuplicateConfig2githubcomkubeagiarcadiaapiservergraphgeneratedRemoveDuplicateConfig(ctx, v)
			if err != nil {
				return it, err
			}
			it.RemoveDuplicateConfig = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputDataProcessDetailsInput(ctx context.Context, obj interface{}) (DataProcessDetailsInput, error) {
	var it DataProcessDetailsInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"id"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "id":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.ID = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputDataProcessFileLogInput(ctx context.Context, obj interface{}) (DataProcessFileLogInput, error) {
	var it DataProcessFileLogInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"id", "file_name", "type"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "id":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.ID = data
		case "file_name":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("file_name"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.FileName = data
		case "type":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("type"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Type = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputDataProcessRetryInput(ctx context.Context, obj interface{}) (DataProcessRetryInput, error) {
	var it DataProcessRetryInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"id", "creator"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "id":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.ID = data
		case "creator":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("creator"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Creator = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputDeleteCommonInput(ctx context.Context, obj interface{}) (DeleteCommonInput, error) {
	var it DeleteCommonInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"name", "namespace", "labelSelector", "fieldSelector"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "name":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Name = data
		case "namespace":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("namespace"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Namespace = data
		case "labelSelector":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("labelSelector"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.LabelSelector = data
		case "fieldSelector":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("fieldSelector"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.FieldSelector = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputDeleteDataProcessInput(ctx context.Context, obj interface{}) (DeleteDataProcessInput, error) {
	var it DeleteDataProcessInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"id"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "id":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.ID = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputDeleteRAGInput(ctx context.Context, obj interface{}) (DeleteRAGInput, error) {
	var it DeleteRAGInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"name", "namespace", "labelSelector"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "name":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Name = data
		case "namespace":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("namespace"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Namespace = data
		case "labelSelector":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("labelSelector"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.LabelSelector = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputDeleteVersionedDatasetInput(ctx context.Context, obj interface{}) (DeleteVersionedDatasetInput, error) {
	var it DeleteVersionedDatasetInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"name", "namespace", "labelSelector", "fieldSelector"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "name":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Name = data
		case "namespace":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("namespace"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Namespace = data
		case "labelSelector":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("labelSelector"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.LabelSelector = data
		case "fieldSelector":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("fieldSelector"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.FieldSelector = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputDuplicateRAGInput(ctx context.Context, obj interface{}) (DuplicateRAGInput, error) {
	var it DuplicateRAGInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"name", "namespace", "displayName"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "name":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Name = data
		case "namespace":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("namespace"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Namespace = data
		case "displayName":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("displayName"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.DisplayName = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputEndpointInput(ctx context.Context, obj interface{}) (EndpointInput, error) {
	var it EndpointInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"url", "auth", "insecure"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "url":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("url"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.URL = data
		case "auth":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("auth"))
			data, err := ec.unmarshalOMap2map(ctx, v)
			if err != nil {
				return it, err
			}
			it.Auth = data
		case "insecure":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("insecure"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.Insecure = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputFileFilter(ctx context.Context, obj interface{}) (FileFilter, error) {
	var it FileFilter
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"keyword", "page", "pageSize", "sortBy"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "keyword":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("keyword"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Keyword = data
		case "page":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("page"))
			data, err := ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.Page = data
		case "pageSize":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("pageSize"))
			data, err := ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.PageSize = data
		case "sortBy":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("sortBy"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.SortBy = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputFileGroup(ctx context.Context, obj interface{}) (FileGroup, error) {
	var it FileGroup
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"source", "paths"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "source":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("source"))
			data, err := ec.unmarshalNTypedObjectReferenceInput2githubcomkubeagiarcadiaapiservergraphgeneratedTypedObjectReferenceInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.Source = data
		case "paths":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("paths"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Paths = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputFileItem(ctx context.Context, obj interface{}) (FileItem, error) {
	var it FileItem
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"name"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "name":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Name = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputLLMConfigItem(ctx context.Context, obj interface{}) (LLMConfigItem, error) {
	var it LLMConfigItem
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"name", "namespace", "model", "temperature", "top_p", "max_tokens", "prompt_template", "provider"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "name":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Name = data
		case "namespace":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("namespace"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Namespace = data
		case "model":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("model"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Model = data
		case "temperature":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("temperature"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Temperature = data
		case "top_p":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("top_p"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.TopP = data
		case "max_tokens":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("max_tokens"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.MaxTokens = data
		case "prompt_template":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("prompt_template"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.PromptTemplate = data
		case "provider":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("provider"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Provider = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputLabelSelectorRequirementInput(ctx context.Context, obj interface{}) (LabelSelectorRequirementInput, error) {
	var it LabelSelectorRequirementInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"key", "values", "operator"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "key":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("key"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Key = data
		case "values":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("values"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Values = data
		case "operator":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("operator"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Operator = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputListCommonInput(ctx context.Context, obj interface{}) (ListCommonInput, error) {
	var it ListCommonInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"namespace", "keyword", "labelSelector", "fieldSelector", "page", "pageSize"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "namespace":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("namespace"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Namespace = data
		case "keyword":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("keyword"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Keyword = data
		case "labelSelector":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("labelSelector"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.LabelSelector = data
		case "fieldSelector":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("fieldSelector"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.FieldSelector = data
		case "page":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("page"))
			data, err := ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.Page = data
		case "pageSize":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("pageSize"))
			data, err := ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.PageSize = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputListDatasetInput(ctx context.Context, obj interface{}) (ListDatasetInput, error) {
	var it ListDatasetInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"namespace", "name", "displayName", "labelSelector", "fieldSelector", "page", "pageSize", "keyword"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "namespace":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("namespace"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Namespace = data
		case "name":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Name = data
		case "displayName":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("displayName"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.DisplayName = data
		case "labelSelector":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("labelSelector"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.LabelSelector = data
		case "fieldSelector":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("fieldSelector"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.FieldSelector = data
		case "page":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("page"))
			data, err := ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.Page = data
		case "pageSize":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("pageSize"))
			data, err := ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.PageSize = data
		case "keyword":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("keyword"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Keyword = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputListGPTInput(ctx context.Context, obj interface{}) (ListGPTInput, error) {
	var it ListGPTInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"category", "keyword", "page", "pageSize"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "category":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("category"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Category = data
		case "keyword":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("keyword"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Keyword = data
		case "page":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("page"))
			data, err := ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.Page = data
		case "pageSize":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("pageSize"))
			data, err := ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.PageSize = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputListKnowledgeBaseInput(ctx context.Context, obj interface{}) (ListKnowledgeBaseInput, error) {
	var it ListKnowledgeBaseInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"name", "namespace", "displayName", "labelSelector", "fieldSelector", "page", "pageSize", "keyword"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "name":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Name = data
		case "namespace":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("namespace"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Namespace = data
		case "displayName":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("displayName"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.DisplayName = data
		case "labelSelector":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("labelSelector"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.LabelSelector = data
		case "fieldSelector":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("fieldSelector"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.FieldSelector = data
		case "page":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("page"))
			data, err := ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.Page = data
		case "pageSize":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("pageSize"))
			data, err := ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.PageSize = data
		case "keyword":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("keyword"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Keyword = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputListModelInput(ctx context.Context, obj interface{}) (ListModelInput, error) {
	var it ListModelInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"namespace", "systemModel", "keyword", "labelSelector", "fieldSelector", "page", "pageSize"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "namespace":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("namespace"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Namespace = data
		case "systemModel":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("systemModel"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.SystemModel = data
		case "keyword":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("keyword"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Keyword = data
		case "labelSelector":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("labelSelector"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.LabelSelector = data
		case "fieldSelector":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("fieldSelector"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.FieldSelector = data
		case "page":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("page"))
			data, err := ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.Page = data
		case "pageSize":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("pageSize"))
			data, err := ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.PageSize = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputListModelServiceInput(ctx context.Context, obj interface{}) (ListModelServiceInput, error) {
	var it ListModelServiceInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"keyword", "namespace", "page", "pageSize", "types", "providerType", "apiType"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "keyword":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("keyword"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Keyword = data
		case "namespace":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("namespace"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Namespace = data
		case "page":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("page"))
			data, err := ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.Page = data
		case "pageSize":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("pageSize"))
			data, err := ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.PageSize = data
		case "types":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("types"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Types = data
		case "providerType":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("providerType"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.ProviderType = data
		case "apiType":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("apiType"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.APIType = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputListRAGInput(ctx context.Context, obj interface{}) (ListRAGInput, error) {
	var it ListRAGInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"appName", "namespace", "status", "keyword", "page", "pageSize"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "appName":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("appName"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.AppName = data
		case "namespace":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("namespace"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Namespace = data
		case "status":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("status"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Status = data
		case "keyword":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("keyword"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Keyword = data
		case "page":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("page"))
			data, err := ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.Page = data
		case "pageSize":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("pageSize"))
			data, err := ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.PageSize = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputListVersionedDatasetInput(ctx context.Context, obj interface{}) (ListVersionedDatasetInput, error) {
	var it ListVersionedDatasetInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"name", "namespace", "displayName", "labelSelector", "fieldSelector", "page", "pageSize", "keyword"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "name":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Name = data
		case "namespace":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("namespace"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Namespace = data
		case "displayName":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("displayName"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.DisplayName = data
		case "labelSelector":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("labelSelector"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.LabelSelector = data
		case "fieldSelector":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("fieldSelector"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.FieldSelector = data
		case "page":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("page"))
			data, err := ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.Page = data
		case "pageSize":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("pageSize"))
			data, err := ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.PageSize = data
		case "keyword":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("keyword"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Keyword = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputListWorkerInput(ctx context.Context, obj interface{}) (ListWorkerInput, error) {
	var it ListWorkerInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"namespace", "keyword", "labelSelector", "fieldSelector", "page", "pageSize", "modelTypes"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "namespace":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("namespace"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Namespace = data
		case "keyword":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("keyword"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Keyword = data
		case "labelSelector":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("labelSelector"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.LabelSelector = data
		case "fieldSelector":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("fieldSelector"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.FieldSelector = data
		case "page":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("page"))
			data, err := ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.Page = data
		case "pageSize":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("pageSize"))
			data, err := ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.PageSize = data
		case "modelTypes":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("modelTypes"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.ModelTypes = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputNodeSelectorRequirementInput(ctx context.Context, obj interface{}) (NodeSelectorRequirementInput, error) {
	var it NodeSelectorRequirementInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"key", "operator", "values"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "key":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("key"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Key = data
		case "operator":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("operator"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Operator = data
		case "values":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("values"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Values = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputOssInput(ctx context.Context, obj interface{}) (OssInput, error) {
	var it OssInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"bucket", "object"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "bucket":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("bucket"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Bucket = data
		case "object":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("object"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Object = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputParameterInput(ctx context.Context, obj interface{}) (ParameterInput, error) {
	var it ParameterInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"key", "value"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "key":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("key"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Key = data
		case "value":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("value"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Value = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputPersistentVolumeClaimSpecInput(ctx context.Context, obj interface{}) (PersistentVolumeClaimSpecInput, error) {
	var it PersistentVolumeClaimSpecInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"accessModes", "selector", "resources", "volumeName", "storageClassName", "volumeMode", "datasource", "dataSourceRef"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "accessModes":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("accessModes"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.AccessModes = data
		case "selector":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("selector"))
			data, err := ec.unmarshalOSelectorInput2githubcomkubeagiarcadiaapiservergraphgeneratedSelectorInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.Selector = data
		case "resources":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("resources"))
			data, err := ec.unmarshalOResourceInput2githubcomkubeagiarcadiaapiservergraphgeneratedResourceInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.Resources = data
		case "volumeName":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("volumeName"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.VolumeName = data
		case "storageClassName":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("storageClassName"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.StorageClassName = data
		case "volumeMode":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("volumeMode"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.VolumeMode = data
		case "datasource":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("datasource"))
			data, err := ec.unmarshalOTypedObjectReferenceInput2githubcomkubeagiarcadiaapiservergraphgeneratedTypedObjectReferenceInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.Datasource = data
		case "dataSourceRef":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("dataSourceRef"))
			data, err := ec.unmarshalOTypedObjectReferenceInput2githubcomkubeagiarcadiaapiservergraphgeneratedTypedObjectReferenceInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.DataSourceRef = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputRAGDatasetInput(ctx context.Context, obj interface{}) (RAGDatasetInput, error) {
	var it RAGDatasetInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"source", "files"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "source":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("source"))
			data, err := ec.unmarshalOTypedObjectReferenceInput2githubcomkubeagiarcadiaapiservergraphgeneratedTypedObjectReferenceInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.Source = data
		case "files":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("files"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Files = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputRAGMetricInput(ctx context.Context, obj interface{}) (RAGMetricInput, error) {
	var it RAGMetricInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"metricKind", "parameters", "toleranceThreshbold"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "metricKind":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("metricKind"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.MetricKind = data
		case "parameters":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("parameters"))
			data, err := ec.unmarshalOParameterInput2githubcomkubeagiarcadiaapiservergraphgeneratedParameterInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.Parameters = data
		case "toleranceThreshbold":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("toleranceThreshbold"))
			data, err := ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.ToleranceThreshbold = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputRemoveDuplicateConfig(ctx context.Context, obj interface{}) (RemoveDuplicateConfig, error) {
	var it RemoveDuplicateConfig
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"embedding_name", "embedding_namespace", "embedding_model", "embedding_provider", "similarity"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "embedding_name":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("embedding_name"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.EmbeddingName = data
		case "embedding_namespace":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("embedding_namespace"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.EmbeddingNamespace = data
		case "embedding_model":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("embedding_model"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.EmbeddingModel = data
		case "embedding_provider":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("embedding_provider"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.EmbeddingProvider = data
		case "similarity":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("similarity"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Similarity = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputResourceInput(ctx context.Context, obj interface{}) (ResourceInput, error) {
	var it ResourceInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"limits", "requests"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "limits":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("limits"))
			data, err := ec.unmarshalOMap2map(ctx, v)
			if err != nil {
				return it, err
			}
			it.Limits = data
		case "requests":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("requests"))
			data, err := ec.unmarshalOMap2map(ctx, v)
			if err != nil {
				return it, err
			}
			it.Requests = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputResourcesInput(ctx context.Context, obj interface{}) (ResourcesInput, error) {
	var it ResourcesInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"cpu", "memory", "nvidiaGPU"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "cpu":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("cpu"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.CPU = data
		case "memory":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("memory"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Memory = data
		case "nvidiaGPU":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nvidiaGPU"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.NvidiaGpu = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputSelectorInput(ctx context.Context, obj interface{}) (SelectorInput, error) {
	var it SelectorInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"matchLabels", "matchExpressions"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "matchLabels":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("matchLabels"))
			data, err := ec.unmarshalOMap2map(ctx, v)
			if err != nil {
				return it, err
			}
			it.MatchLabels = data
		case "matchExpressions":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("matchExpressions"))
			data, err := ec.unmarshalOLabelSelectorRequirementInput2githubcomkubeagiarcadiaapiservergraphgeneratedLabelSelectorRequirementInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.MatchExpressions = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputToolInput(ctx context.Context, obj interface{}) (ToolInput, error) {
	var it ToolInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"name", "params"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "name":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Name = data
		case "params":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("params"))
			data, err := ec.unmarshalOMap2map(ctx, v)
			if err != nil {
				return it, err
			}
			it.Params = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputTypedObjectReferenceInput(ctx context.Context, obj interface{}) (TypedObjectReferenceInput, error) {
	var it TypedObjectReferenceInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"apiGroup", "kind", "name", "namespace"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "apiGroup":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("apiGroup"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.APIGroup = data
		case "kind":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("kind"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Kind = data
		case "name":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Name = data
		case "namespace":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("namespace"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Namespace = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputUpdateApplicationConfigInput(ctx context.Context, obj interface{}) (UpdateApplicationConfigInput, error) {
	var it UpdateApplicationConfigInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"name", "namespace", "prologue", "model", "llm", "temperature", "maxLength", "maxTokens", "conversionWindowSize", "knowledgebase", "scoreThreshold", "numDocuments", "docNullReturn", "userPrompt", "showRespInfo", "showRetrievalInfo", "showNextGuide", "tools"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "name":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Name = data
		case "namespace":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("namespace"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Namespace = data
		case "prologue":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("prologue"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Prologue = data
		case "model":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("model"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Model = data
		case "llm":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("llm"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Llm = data
		case "temperature":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("temperature"))
			data, err := ec.unmarshalOFloat2float64(ctx, v)
			if err != nil {
				return it, err
			}
			it.Temperature = data
		case "maxLength":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("maxLength"))
			data, err := ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.MaxLength = data
		case "maxTokens":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("maxTokens"))
			data, err := ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.MaxTokens = data
		case "conversionWindowSize":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("conversionWindowSize"))
			data, err := ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.ConversionWindowSize = data
		case "knowledgebase":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("knowledgebase"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Knowledgebase = data
		case "scoreThreshold":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("scoreThreshold"))
			data, err := ec.unmarshalOFloat2float64(ctx, v)
			if err != nil {
				return it, err
			}
			it.ScoreThreshold = data
		case "numDocuments":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("numDocuments"))
			data, err := ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.NumDocuments = data
		case "docNullReturn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("docNullReturn"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.DocNullReturn = data
		case "userPrompt":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("userPrompt"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.UserPrompt = data
		case "showRespInfo":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("showRespInfo"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.ShowRespInfo = data
		case "showRetrievalInfo":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("showRetrievalInfo"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.ShowRetrievalInfo = data
		case "showNextGuide":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("showNextGuide"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.ShowNextGuide = data
		case "tools":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("tools"))
			data, err := ec.unmarshalOToolInput2githubcomkubeagiarcadiaapiservergraphgeneratedToolInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.Tools = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputUpdateApplicationMetadataInput(ctx context.Context, obj interface{}) (UpdateApplicationMetadataInput, error) {
	var it UpdateApplicationMetadataInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"name", "namespace", "labels", "annotations", "displayName", "description", "icon", "isPublic", "category"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "name":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Name = data
		case "namespace":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("namespace"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Namespace = data
		case "labels":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("labels"))
			data, err := ec.unmarshalOMap2map(ctx, v)
			if err != nil {
				return it, err
			}
			it.Labels = data
		case "annotations":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("annotations"))
			data, err := ec.unmarshalOMap2map(ctx, v)
			if err != nil {
				return it, err
			}
			it.Annotations = data
		case "displayName":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("displayName"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.DisplayName = data
		case "description":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("description"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Description = data
		case "icon":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("icon"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Icon = data
		case "isPublic":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("isPublic"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.IsPublic = data
		case "category":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("category"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Category = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputUpdateDatasetInput(ctx context.Context, obj interface{}) (UpdateDatasetInput, error) {
	var it UpdateDatasetInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"name", "namespace", "labels", "annotations", "displayName", "description"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "name":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Name = data
		case "namespace":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("namespace"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Namespace = data
		case "labels":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("labels"))
			data, err := ec.unmarshalOMap2map(ctx, v)
			if err != nil {
				return it, err
			}
			it.Labels = data
		case "annotations":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("annotations"))
			data, err := ec.unmarshalOMap2map(ctx, v)
			if err != nil {
				return it, err
			}
			it.Annotations = data
		case "displayName":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("displayName"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.DisplayName = data
		case "description":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("description"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Description = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputUpdateDatasourceInput(ctx context.Context, obj interface{}) (UpdateDatasourceInput, error) {
	var it UpdateDatasourceInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"name", "namespace", "labels", "annotations", "displayName", "description", "endpointinput", "ossinput", "webinput"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "name":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Name = data
		case "namespace":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("namespace"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Namespace = data
		case "labels":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("labels"))
			data, err := ec.unmarshalOMap2map(ctx, v)
			if err != nil {
				return it, err
			}
			it.Labels = data
		case "annotations":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("annotations"))
			data, err := ec.unmarshalOMap2map(ctx, v)
			if err != nil {
				return it, err
			}
			it.Annotations = data
		case "displayName":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("displayName"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.DisplayName = data
		case "description":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("description"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Description = data
		case "endpointinput":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("endpointinput"))
			data, err := ec.unmarshalOEndpointInput2githubcomkubeagiarcadiaapiservergraphgeneratedEndpointInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.Endpointinput = data
		case "ossinput":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("ossinput"))
			data, err := ec.unmarshalOOssInput2githubcomkubeagiarcadiaapiservergraphgeneratedOssInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.Ossinput = data
		case "webinput":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("webinput"))
			data, err := ec.unmarshalOWebInput2githubcomkubeagiarcadiaapiservergraphgeneratedWebInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.Webinput = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputUpdateEmbedderInput(ctx context.Context, obj interface{}) (UpdateEmbedderInput, error) {
	var it UpdateEmbedderInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"name", "namespace", "labels", "annotations", "displayName", "description", "endpointinput", "type", "models"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "name":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Name = data
		case "namespace":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("namespace"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Namespace = data
		case "labels":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("labels"))
			data, err := ec.unmarshalOMap2map(ctx, v)
			if err != nil {
				return it, err
			}
			it.Labels = data
		case "annotations":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("annotations"))
			data, err := ec.unmarshalOMap2map(ctx, v)
			if err != nil {
				return it, err
			}
			it.Annotations = data
		case "displayName":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("displayName"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.DisplayName = data
		case "description":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("description"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Description = data
		case "endpointinput":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("endpointinput"))
			data, err := ec.unmarshalOEndpointInput2githubcomkubeagiarcadiaapiservergraphgeneratedEndpointInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.Endpointinput = data
		case "type":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("type"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Type = data
		case "models":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("models"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Models = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputUpdateKnowledgeBaseInput(ctx context.Context, obj interface{}) (UpdateKnowledgeBaseInput, error) {
	var it UpdateKnowledgeBaseInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"name", "namespace", "labels", "annotations", "displayName", "description", "fileGroups", "chunkSize", "chunkOverlap", "batchSize"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "name":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Name = data
		case "namespace":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("namespace"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Namespace = data
		case "labels":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("labels"))
			data, err := ec.unmarshalOMap2map(ctx, v)
			if err != nil {
				return it, err
			}
			it.Labels = data
		case "annotations":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("annotations"))
			data, err := ec.unmarshalOMap2map(ctx, v)
			if err != nil {
				return it, err
			}
			it.Annotations = data
		case "displayName":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("displayName"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.DisplayName = data
		case "description":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("description"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Description = data
		case "fileGroups":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("fileGroups"))
			data, err := ec.unmarshalOfilegroupinput2githubcomkubeagiarcadiaapiservergraphgeneratedFilegroupinput(ctx, v)
			if err != nil {
				return it, err
			}
			it.FileGroups = data
		case "chunkSize":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("chunkSize"))
			data, err := ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.ChunkSize = data
		case "chunkOverlap":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("chunkOverlap"))
			data, err := ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.ChunkOverlap = data
		case "batchSize":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("batchSize"))
			data, err := ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.BatchSize = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputUpdateLLMInput(ctx context.Context, obj interface{}) (UpdateLLMInput, error) {
	var it UpdateLLMInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"name", "namespace", "labels", "annotations", "displayName", "description", "endpointinput", "type", "models"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "name":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Name = data
		case "namespace":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("namespace"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Namespace = data
		case "labels":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("labels"))
			data, err := ec.unmarshalOMap2map(ctx, v)
			if err != nil {
				return it, err
			}
			it.Labels = data
		case "annotations":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("annotations"))
			data, err := ec.unmarshalOMap2map(ctx, v)
			if err != nil {
				return it, err
			}
			it.Annotations = data
		case "displayName":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("displayName"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.DisplayName = data
		case "description":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("description"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Description = data
		case "endpointinput":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("endpointinput"))
			data, err := ec.unmarshalOEndpointInput2githubcomkubeagiarcadiaapiservergraphgeneratedEndpointInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.Endpointinput = data
		case "type":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("type"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Type = data
		case "models":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("models"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Models = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputUpdateModelInput(ctx context.Context, obj interface{}) (UpdateModelInput, error) {
	var it UpdateModelInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"name", "namespace", "labels", "annotations", "displayName", "description", "types", "huggingFaceRepo", "modelScopeRepo", "revision", "modelSource"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "name":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Name = data
		case "namespace":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("namespace"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Namespace = data
		case "labels":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("labels"))
			data, err := ec.unmarshalOMap2map(ctx, v)
			if err != nil {
				return it, err
			}
			it.Labels = data
		case "annotations":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("annotations"))
			data, err := ec.unmarshalOMap2map(ctx, v)
			if err != nil {
				return it, err
			}
			it.Annotations = data
		case "displayName":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("displayName"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.DisplayName = data
		case "description":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("description"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Description = data
		case "types":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("types"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Types = data
		case "huggingFaceRepo":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("huggingFaceRepo"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.HuggingFaceRepo = data
		case "modelScopeRepo":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("modelScopeRepo"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.ModelScopeRepo = data
		case "revision":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("revision"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Revision = data
		case "modelSource":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("modelSource"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.ModelSource = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputUpdateModelServiceInput(ctx context.Context, obj interface{}) (UpdateModelServiceInput, error) {
	var it UpdateModelServiceInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"name", "namespace", "labels", "annotations", "displayName", "description", "types", "apiType", "endpoint", "llmModels", "embeddingModels"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "name":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Name = data
		case "namespace":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("namespace"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Namespace = data
		case "labels":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("labels"))
			data, err := ec.unmarshalOMap2map(ctx, v)
			if err != nil {
				return it, err
			}
			it.Labels = data
		case "annotations":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("annotations"))
			data, err := ec.unmarshalOMap2map(ctx, v)
			if err != nil {
				return it, err
			}
			it.Annotations = data
		case "displayName":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("displayName"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.DisplayName = data
		case "description":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("description"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Description = data
		case "types":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("types"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Types = data
		case "apiType":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("apiType"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.APIType = data
		case "endpoint":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("endpoint"))
			data, err := ec.unmarshalNEndpointInput2githubcomkubeagiarcadiaapiservergraphgeneratedEndpointInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.Endpoint = data
		case "llmModels":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("llmModels"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.LlmModels = data
		case "embeddingModels":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("embeddingModels"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.EmbeddingModels = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputUpdateRAGInput(ctx context.Context, obj interface{}) (UpdateRAGInput, error) {
	var it UpdateRAGInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"name", "namespace", "labels", "annotations", "displayName", "description", "application", "datasets", "judgeLLM", "metrics", "storage", "serviceAccountName", "suspend"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "name":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Name = data
		case "namespace":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("namespace"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Namespace = data
		case "labels":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("labels"))
			data, err := ec.unmarshalOMap2map(ctx, v)
			if err != nil {
				return it, err
			}
			it.Labels = data
		case "annotations":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("annotations"))
			data, err := ec.unmarshalOMap2map(ctx, v)
			if err != nil {
				return it, err
			}
			it.Annotations = data
		case "displayName":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("displayName"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.DisplayName = data
		case "description":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("description"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Description = data
		case "application":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("application"))
			data, err := ec.unmarshalOTypedObjectReferenceInput2githubcomkubeagiarcadiaapiservergraphgeneratedTypedObjectReferenceInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.Application = data
		case "datasets":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("datasets"))
			data, err := ec.unmarshalORAGDatasetInput2githubcomkubeagiarcadiaapiservergraphgeneratedRAGDatasetInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.Datasets = data
		case "judgeLLM":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("judgeLLM"))
			data, err := ec.unmarshalOTypedObjectReferenceInput2githubcomkubeagiarcadiaapiservergraphgeneratedTypedObjectReferenceInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.JudgeLlm = data
		case "metrics":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("metrics"))
			data, err := ec.unmarshalORAGMetricInput2githubcomkubeagiarcadiaapiservergraphgeneratedRAGMetricInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.Metrics = data
		case "storage":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("storage"))
			data, err := ec.unmarshalOPersistentVolumeClaimSpecInput2githubcomkubeagiarcadiaapiservergraphgeneratedPersistentVolumeClaimSpecInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.Storage = data
		case "serviceAccountName":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("serviceAccountName"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.ServiceAccountName = data
		case "suspend":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("suspend"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.Suspend = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputUpdateVersionedDatasetInput(ctx context.Context, obj interface{}) (UpdateVersionedDatasetInput, error) {
	var it UpdateVersionedDatasetInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"name", "namespace", "labels", "annotations", "displayName", "description", "fileGroups", "released"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "name":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Name = data
		case "namespace":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("namespace"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Namespace = data
		case "labels":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("labels"))
			data, err := ec.unmarshalOMap2map(ctx, v)
			if err != nil {
				return it, err
			}
			it.Labels = data
		case "annotations":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("annotations"))
			data, err := ec.unmarshalOMap2map(ctx, v)
			if err != nil {
				return it, err
			}
			it.Annotations = data
		case "displayName":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("displayName"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.DisplayName = data
		case "description":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("description"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Description = data
		case "fileGroups":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("fileGroups"))
			data, err := ec.unmarshalOFileGroup2githubcomkubeagiarcadiaapiservergraphgeneratedFileGroup(ctx, v)
			if err != nil {
				return it, err
			}
			it.FileGroups = data
		case "released":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("released"))
			data, err := ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.Released = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputUpdateWorkerInput(ctx context.Context, obj interface{}) (UpdateWorkerInput, error) {
	var it UpdateWorkerInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"name", "namespace", "labels", "annotations", "displayName", "description", "type", "replicas", "resources", "matchExpressions", "additionalEnvs"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "name":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Name = data
		case "namespace":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("namespace"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Namespace = data
		case "labels":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("labels"))
			data, err := ec.unmarshalOMap2map(ctx, v)
			if err != nil {
				return it, err
			}
			it.Labels = data
		case "annotations":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("annotations"))
			data, err := ec.unmarshalOMap2map(ctx, v)
			if err != nil {
				return it, err
			}
			it.Annotations = data
		case "displayName":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("displayName"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.DisplayName = data
		case "description":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("description"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Description = data
		case "type":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("type"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Type = data
		case "replicas":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("replicas"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Replicas = data
		case "resources":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("resources"))
			data, err := ec.unmarshalOResourcesInput2githubcomkubeagiarcadiaapiservergraphgeneratedResourcesInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.Resources = data
		case "matchExpressions":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("matchExpressions"))
			data, err := ec.unmarshalONodeSelectorRequirementInput2githubcomkubeagiarcadiaapiservergraphgeneratedNodeSelectorRequirementInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.MatchExpressions = data
		case "additionalEnvs":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("additionalEnvs"))
			data, err := ec.unmarshalOMap2map(ctx, v)
			if err != nil {
				return it, err
			}
			it.AdditionalEnvs = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputWebInput(ctx context.Context, obj interface{}) (WebInput, error) {
	var it WebInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"recommendIntervalTime"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "recommendIntervalTime":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("recommendIntervalTime"))
			data, err := ec.unmarshalNInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.RecommendIntervalTime = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputfilegroupinput(ctx context.Context, obj interface{}) (Filegroupinput, error) {
	var it Filegroupinput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"source", "path"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "source":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("source"))
			data, err := ec.unmarshalNTypedObjectReferenceInput2githubcomkubeagiarcadiaapiservergraphgeneratedTypedObjectReferenceInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.Source = data
		case "path":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("path"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Path = data
		}
	}

	return it, nil
}

// endregion **************************** input.gotpl *****************************

// region    ************************** interface.gotpl ***************************

func (ec *executionContext) _PageNode(ctx context.Context, sel ast.SelectionSet, obj PageNode) graphql.Marshaler {
	switch obj := (obj).(type) {
	case nil:
		return graphql.Null
	case Datasource:
		return ec._Datasource(ctx, sel, &obj)
	case *Datasource:
		if obj == nil {
			return graphql.Null
		}
		return ec._Datasource(ctx, sel, obj)
	case Model:
		return ec._Model(ctx, sel, &obj)
	case *Model:
		if obj == nil {
			return graphql.Null
		}
		return ec._Model(ctx, sel, obj)
	case Embedder:
		return ec._Embedder(ctx, sel, &obj)
	case *Embedder:
		if obj == nil {
			return graphql.Null
		}
		return ec._Embedder(ctx, sel, obj)
	case KnowledgeBase:
		return ec._KnowledgeBase(ctx, sel, &obj)
	case *KnowledgeBase:
		if obj == nil {
			return graphql.Null
		}
		return ec._KnowledgeBase(ctx, sel, obj)
	case Dataset:
		return ec._Dataset(ctx, sel, &obj)
	case *Dataset:
		if obj == nil {
			return graphql.Null
		}
		return ec._Dataset(ctx, sel, obj)
	case VersionedDataset:
		return ec._VersionedDataset(ctx, sel, &obj)
	case *VersionedDataset:
		if obj == nil {
			return graphql.Null
		}
		return ec._VersionedDataset(ctx, sel, obj)
	case F:
		return ec._F(ctx, sel, &obj)
	case *F:
		if obj == nil {
			return graphql.Null
		}
		return ec._F(ctx, sel, obj)
	case Worker:
		return ec._Worker(ctx, sel, &obj)
	case *Worker:
		if obj == nil {
			return graphql.Null
		}
		return ec._Worker(ctx, sel, obj)
	case ApplicationMetadata:
		return ec._ApplicationMetadata(ctx, sel, &obj)
	case *ApplicationMetadata:
		if obj == nil {
			return graphql.Null
		}
		return ec._ApplicationMetadata(ctx, sel, obj)
	case Llm:
		return ec._LLM(ctx, sel, &obj)
	case *Llm:
		if obj == nil {
			return graphql.Null
		}
		return ec._LLM(ctx, sel, obj)
	case ModelService:
		return ec._ModelService(ctx, sel, &obj)
	case *ModelService:
		if obj == nil {
			return graphql.Null
		}
		return ec._ModelService(ctx, sel, obj)
	case RayCluster:
		return ec._RayCluster(ctx, sel, &obj)
	case *RayCluster:
		if obj == nil {
			return graphql.Null
		}
		return ec._RayCluster(ctx, sel, obj)
	case Rag:
		return ec._RAG(ctx, sel, &obj)
	case *Rag:
		if obj == nil {
			return graphql.Null
		}
		return ec._RAG(ctx, sel, obj)
	case Gpt:
		return ec._GPT(ctx, sel, &obj)
	case *Gpt:
		if obj == nil {
			return graphql.Null
		}
		return ec._GPT(ctx, sel, obj)
	default:
		panic(fmt.Errorf("unexpected type %T", obj))
	}
}

// endregion ************************** interface.gotpl ***************************

// region    **************************** object.gotpl ****************************

var applicationImplementors = []string{"Application"}

func (ec *executionContext) _Application(ctx context.Context, sel ast.SelectionSet, obj *Application) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, applicationImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Application")
		case "metadata":
			out.Values[i] = ec._Application_metadata(ctx, field, obj)
		case "prologue":
			out.Values[i] = ec._Application_prologue(ctx, field, obj)
		case "model":
			out.Values[i] = ec._Application_model(ctx, field, obj)
		case "llm":
			out.Values[i] = ec._Application_llm(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "temperature":
			out.Values[i] = ec._Application_temperature(ctx, field, obj)
		case "maxLength":
			out.Values[i] = ec._Application_maxLength(ctx, field, obj)
		case "maxTokens":
			out.Values[i] = ec._Application_maxTokens(ctx, field, obj)
		case "conversionWindowSize":
			out.Values[i] = ec._Application_conversionWindowSize(ctx, field, obj)
		case "knowledgebase":
			out.Values[i] = ec._Application_knowledgebase(ctx, field, obj)
		case "scoreThreshold":
			out.Values[i] = ec._Application_scoreThreshold(ctx, field, obj)
		case "numDocuments":
			out.Values[i] = ec._Application_numDocuments(ctx, field, obj)
		case "docNullReturn":
			out.Values[i] = ec._Application_docNullReturn(ctx, field, obj)
		case "userPrompt":
			out.Values[i] = ec._Application_userPrompt(ctx, field, obj)
		case "showRespInfo":
			out.Values[i] = ec._Application_showRespInfo(ctx, field, obj)
		case "showRetrievalInfo":
			out.Values[i] = ec._Application_showRetrievalInfo(ctx, field, obj)
		case "showNextGuide":
			out.Values[i] = ec._Application_showNextGuide(ctx, field, obj)
		case "tools":
			out.Values[i] = ec._Application_tools(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var applicationMetadataImplementors = []string{"ApplicationMetadata", "PageNode"}

func (ec *executionContext) _ApplicationMetadata(ctx context.Context, sel ast.SelectionSet, obj *ApplicationMetadata) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, applicationMetadataImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ApplicationMetadata")
		case "name":
			out.Values[i] = ec._ApplicationMetadata_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "namespace":
			out.Values[i] = ec._ApplicationMetadata_namespace(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "id":
			out.Values[i] = ec._ApplicationMetadata_id(ctx, field, obj)
		case "labels":
			out.Values[i] = ec._ApplicationMetadata_labels(ctx, field, obj)
		case "annotations":
			out.Values[i] = ec._ApplicationMetadata_annotations(ctx, field, obj)
		case "displayName":
			out.Values[i] = ec._ApplicationMetadata_displayName(ctx, field, obj)
		case "description":
			out.Values[i] = ec._ApplicationMetadata_description(ctx, field, obj)
		case "icon":
			out.Values[i] = ec._ApplicationMetadata_icon(ctx, field, obj)
		case "creator":
			out.Values[i] = ec._ApplicationMetadata_creator(ctx, field, obj)
		case "creationTimestamp":
			out.Values[i] = ec._ApplicationMetadata_creationTimestamp(ctx, field, obj)
		case "updateTimestamp":
			out.Values[i] = ec._ApplicationMetadata_updateTimestamp(ctx, field, obj)
		case "isPublic":
			out.Values[i] = ec._ApplicationMetadata_isPublic(ctx, field, obj)
		case "status":
			out.Values[i] = ec._ApplicationMetadata_status(ctx, field, obj)
		case "category":
			out.Values[i] = ec._ApplicationMetadata_category(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var applicationMutationImplementors = []string{"ApplicationMutation"}

func (ec *executionContext) _ApplicationMutation(ctx context.Context, sel ast.SelectionSet, obj *ApplicationMutation) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, applicationMutationImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ApplicationMutation")
		case "createApplication":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._ApplicationMutation_createApplication(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "updateApplication":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._ApplicationMutation_updateApplication(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "deleteApplication":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._ApplicationMutation_deleteApplication(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "updateApplicationConfig":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._ApplicationMutation_updateApplicationConfig(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var applicationQueryImplementors = []string{"ApplicationQuery"}

func (ec *executionContext) _ApplicationQuery(ctx context.Context, sel ast.SelectionSet, obj *ApplicationQuery) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, applicationQueryImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ApplicationQuery")
		case "getApplication":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._ApplicationQuery_getApplication(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "listApplicationMetadata":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._ApplicationQuery_listApplicationMetadata(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var countDataProcessItemImplementors = []string{"CountDataProcessItem"}

func (ec *executionContext) _CountDataProcessItem(ctx context.Context, sel ast.SelectionSet, obj *CountDataProcessItem) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, countDataProcessItemImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("CountDataProcessItem")
		case "status":
			out.Values[i] = ec._CountDataProcessItem_status(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "data":
			out.Values[i] = ec._CountDataProcessItem_data(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "message":
			out.Values[i] = ec._CountDataProcessItem_message(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var dataProcessConfigImplementors = []string{"DataProcessConfig"}

func (ec *executionContext) _DataProcessConfig(ctx context.Context, sel ast.SelectionSet, obj *DataProcessConfig) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, dataProcessConfigImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("DataProcessConfig")
		case "name":
			out.Values[i] = ec._DataProcessConfig_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "description":
			out.Values[i] = ec._DataProcessConfig_description(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "file_num":
			out.Values[i] = ec._DataProcessConfig_file_num(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "status":
			out.Values[i] = ec._DataProcessConfig_status(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "children":
			out.Values[i] = ec._DataProcessConfig_children(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var dataProcessConfigChildrenImplementors = []string{"DataProcessConfigChildren"}

func (ec *executionContext) _DataProcessConfigChildren(ctx context.Context, sel ast.SelectionSet, obj *DataProcessConfigChildren) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, dataProcessConfigChildrenImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("DataProcessConfigChildren")
		case "name":
			out.Values[i] = ec._DataProcessConfigChildren_name(ctx, field, obj)
		case "enable":
			out.Values[i] = ec._DataProcessConfigChildren_enable(ctx, field, obj)
		case "zh_name":
			out.Values[i] = ec._DataProcessConfigChildren_zh_name(ctx, field, obj)
		case "description":
			out.Values[i] = ec._DataProcessConfigChildren_description(ctx, field, obj)
		case "chunk_size":
			out.Values[i] = ec._DataProcessConfigChildren_chunk_size(ctx, field, obj)
		case "chunk_overlap":
			out.Values[i] = ec._DataProcessConfigChildren_chunk_overlap(ctx, field, obj)
		case "llm_config":
			out.Values[i] = ec._DataProcessConfigChildren_llm_config(ctx, field, obj)
		case "preview":
			out.Values[i] = ec._DataProcessConfigChildren_preview(ctx, field, obj)
		case "file_progress":
			out.Values[i] = ec._DataProcessConfigChildren_file_progress(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var dataProcessConfigInfoImplementors = []string{"DataProcessConfigInfo"}

func (ec *executionContext) _DataProcessConfigInfo(ctx context.Context, sel ast.SelectionSet, obj *DataProcessConfigInfo) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, dataProcessConfigInfoImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("DataProcessConfigInfo")
		case "type":
			out.Values[i] = ec._DataProcessConfigInfo_type(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "llm_config":
			out.Values[i] = ec._DataProcessConfigInfo_llm_config(ctx, field, obj)
		case "remove_duplicate_config":
			out.Values[i] = ec._DataProcessConfigInfo_remove_duplicate_config(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var dataProcessConfigpreFileProgressImplementors = []string{"DataProcessConfigpreFileProgress"}

func (ec *executionContext) _DataProcessConfigpreFileProgress(ctx context.Context, sel ast.SelectionSet, obj *DataProcessConfigpreFileProgress) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, dataProcessConfigpreFileProgressImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("DataProcessConfigpreFileProgress")
		case "id":
			out.Values[i] = ec._DataProcessConfigpreFileProgress_id(ctx, field, obj)
		case "file_name":
			out.Values[i] = ec._DataProcessConfigpreFileProgress_file_name(ctx, field, obj)
		case "status":
			out.Values[i] = ec._DataProcessConfigpreFileProgress_status(ctx, field, obj)
		case "start_time":
			out.Values[i] = ec._DataProcessConfigpreFileProgress_start_time(ctx, field, obj)
		case "end_time":
			out.Values[i] = ec._DataProcessConfigpreFileProgress_end_time(ctx, field, obj)
		case "progress":
			out.Values[i] = ec._DataProcessConfigpreFileProgress_progress(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var dataProcessConfigpreViewImplementors = []string{"DataProcessConfigpreView"}

func (ec *executionContext) _DataProcessConfigpreView(ctx context.Context, sel ast.SelectionSet, obj *DataProcessConfigpreView) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, dataProcessConfigpreViewImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("DataProcessConfigpreView")
		case "file_name":
			out.Values[i] = ec._DataProcessConfigpreView_file_name(ctx, field, obj)
		case "content":
			out.Values[i] = ec._DataProcessConfigpreView_content(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var dataProcessConfigpreViewContentImplementors = []string{"DataProcessConfigpreViewContent"}

func (ec *executionContext) _DataProcessConfigpreViewContent(ctx context.Context, sel ast.SelectionSet, obj *DataProcessConfigpreViewContent) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, dataProcessConfigpreViewContentImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("DataProcessConfigpreViewContent")
		case "pre":
			out.Values[i] = ec._DataProcessConfigpreViewContent_pre(ctx, field, obj)
		case "post":
			out.Values[i] = ec._DataProcessConfigpreViewContent_post(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var dataProcessDetailsImplementors = []string{"DataProcessDetails"}

func (ec *executionContext) _DataProcessDetails(ctx context.Context, sel ast.SelectionSet, obj *DataProcessDetails) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, dataProcessDetailsImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("DataProcessDetails")
		case "status":
			out.Values[i] = ec._DataProcessDetails_status(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "data":
			out.Values[i] = ec._DataProcessDetails_data(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "message":
			out.Values[i] = ec._DataProcessDetails_message(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var dataProcessDetailsItemImplementors = []string{"DataProcessDetailsItem"}

func (ec *executionContext) _DataProcessDetailsItem(ctx context.Context, sel ast.SelectionSet, obj *DataProcessDetailsItem) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, dataProcessDetailsItemImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("DataProcessDetailsItem")
		case "id":
			out.Values[i] = ec._DataProcessDetailsItem_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "status":
			out.Values[i] = ec._DataProcessDetailsItem_status(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "name":
			out.Values[i] = ec._DataProcessDetailsItem_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "file_type":
			out.Values[i] = ec._DataProcessDetailsItem_file_type(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "pre_dataset_name":
			out.Values[i] = ec._DataProcessDetailsItem_pre_dataset_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "pre_dataset_version":
			out.Values[i] = ec._DataProcessDetailsItem_pre_dataset_version(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "post_dataset_name":
			out.Values[i] = ec._DataProcessDetailsItem_post_dataset_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "post_dataset_version":
			out.Values[i] = ec._DataProcessDetailsItem_post_dataset_version(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "file_num":
			out.Values[i] = ec._DataProcessDetailsItem_file_num(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "start_time":
			out.Values[i] = ec._DataProcessDetailsItem_start_time(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "end_time":
			out.Values[i] = ec._DataProcessDetailsItem_end_time(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "creator":
			out.Values[i] = ec._DataProcessDetailsItem_creator(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "error_msg":
			out.Values[i] = ec._DataProcessDetailsItem_error_msg(ctx, field, obj)
		case "data_process_config_info":
			out.Values[i] = ec._DataProcessDetailsItem_data_process_config_info(ctx, field, obj)
		case "config":
			out.Values[i] = ec._DataProcessDetailsItem_config(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var dataProcessItemImplementors = []string{"DataProcessItem"}

func (ec *executionContext) _DataProcessItem(ctx context.Context, sel ast.SelectionSet, obj *DataProcessItem) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, dataProcessItemImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("DataProcessItem")
		case "id":
			out.Values[i] = ec._DataProcessItem_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "name":
			out.Values[i] = ec._DataProcessItem_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "status":
			out.Values[i] = ec._DataProcessItem_status(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "pre_data_set_name":
			out.Values[i] = ec._DataProcessItem_pre_data_set_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "pre_data_set_version":
			out.Values[i] = ec._DataProcessItem_pre_data_set_version(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "post_data_set_name":
			out.Values[i] = ec._DataProcessItem_post_data_set_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "post_data_set_version":
			out.Values[i] = ec._DataProcessItem_post_data_set_version(ctx, field, obj)
		case "start_datetime":
			out.Values[i] = ec._DataProcessItem_start_datetime(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "error_msg":
			out.Values[i] = ec._DataProcessItem_error_msg(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var dataProcessMutationImplementors = []string{"DataProcessMutation"}

func (ec *executionContext) _DataProcessMutation(ctx context.Context, sel ast.SelectionSet, obj *DataProcessMutation) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, dataProcessMutationImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("DataProcessMutation")
		case "createDataProcessTask":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._DataProcessMutation_createDataProcessTask(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "deleteDataProcessTask":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._DataProcessMutation_deleteDataProcessTask(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var dataProcessQueryImplementors = []string{"DataProcessQuery"}

func (ec *executionContext) _DataProcessQuery(ctx context.Context, sel ast.SelectionSet, obj *DataProcessQuery) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, dataProcessQueryImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("DataProcessQuery")
		case "allDataProcessListByPage":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._DataProcessQuery_allDataProcessListByPage(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "allDataProcessListByCount":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._DataProcessQuery_allDataProcessListByCount(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "dataProcessSupportType":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._DataProcessQuery_dataProcessSupportType(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "dataProcessDetails":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._DataProcessQuery_dataProcessDetails(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "checkDataProcessTaskName":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._DataProcessQuery_checkDataProcessTaskName(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "getLogInfo":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._DataProcessQuery_getLogInfo(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "dataProcessLogInfoByFileName":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._DataProcessQuery_dataProcessLogInfoByFileName(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "dataProcessRetry":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._DataProcessQuery_dataProcessRetry(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var dataProcessResponseImplementors = []string{"DataProcessResponse"}

func (ec *executionContext) _DataProcessResponse(ctx context.Context, sel ast.SelectionSet, obj *DataProcessResponse) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, dataProcessResponseImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("DataProcessResponse")
		case "status":
			out.Values[i] = ec._DataProcessResponse_status(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "data":
			out.Values[i] = ec._DataProcessResponse_data(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "message":
			out.Values[i] = ec._DataProcessResponse_message(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var dataProcessSupportTypeImplementors = []string{"DataProcessSupportType"}

func (ec *executionContext) _DataProcessSupportType(ctx context.Context, sel ast.SelectionSet, obj *DataProcessSupportType) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, dataProcessSupportTypeImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("DataProcessSupportType")
		case "status":
			out.Values[i] = ec._DataProcessSupportType_status(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "data":
			out.Values[i] = ec._DataProcessSupportType_data(ctx, field, obj)
		case "message":
			out.Values[i] = ec._DataProcessSupportType_message(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var dataProcessSupportTypeChildrenImplementors = []string{"DataProcessSupportTypeChildren"}

func (ec *executionContext) _DataProcessSupportTypeChildren(ctx context.Context, sel ast.SelectionSet, obj *DataProcessSupportTypeChildren) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, dataProcessSupportTypeChildrenImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("DataProcessSupportTypeChildren")
		case "name":
			out.Values[i] = ec._DataProcessSupportTypeChildren_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "zh_name":
			out.Values[i] = ec._DataProcessSupportTypeChildren_zh_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "enable":
			out.Values[i] = ec._DataProcessSupportTypeChildren_enable(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "description":
			out.Values[i] = ec._DataProcessSupportTypeChildren_description(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var dataProcessSupportTypeItemImplementors = []string{"DataProcessSupportTypeItem"}

func (ec *executionContext) _DataProcessSupportTypeItem(ctx context.Context, sel ast.SelectionSet, obj *DataProcessSupportTypeItem) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, dataProcessSupportTypeItemImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("DataProcessSupportTypeItem")
		case "name":
			out.Values[i] = ec._DataProcessSupportTypeItem_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "description":
			out.Values[i] = ec._DataProcessSupportTypeItem_description(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "children":
			out.Values[i] = ec._DataProcessSupportTypeItem_children(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var datasetImplementors = []string{"Dataset", "PageNode"}

func (ec *executionContext) _Dataset(ctx context.Context, sel ast.SelectionSet, obj *Dataset) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, datasetImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Dataset")
		case "name":
			out.Values[i] = ec._Dataset_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "namespace":
			out.Values[i] = ec._Dataset_namespace(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "labels":
			out.Values[i] = ec._Dataset_labels(ctx, field, obj)
		case "annotations":
			out.Values[i] = ec._Dataset_annotations(ctx, field, obj)
		case "creator":
			out.Values[i] = ec._Dataset_creator(ctx, field, obj)
		case "displayName":
			out.Values[i] = ec._Dataset_displayName(ctx, field, obj)
		case "description":
			out.Values[i] = ec._Dataset_description(ctx, field, obj)
		case "creationTimestamp":
			out.Values[i] = ec._Dataset_creationTimestamp(ctx, field, obj)
		case "updateTimestamp":
			out.Values[i] = ec._Dataset_updateTimestamp(ctx, field, obj)
		case "contentType":
			out.Values[i] = ec._Dataset_contentType(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "field":
			out.Values[i] = ec._Dataset_field(ctx, field, obj)
		case "versions":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Dataset_versions(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var datasetMutationImplementors = []string{"DatasetMutation"}

func (ec *executionContext) _DatasetMutation(ctx context.Context, sel ast.SelectionSet, obj *DatasetMutation) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, datasetMutationImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("DatasetMutation")
		case "createDataset":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._DatasetMutation_createDataset(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "updateDataset":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._DatasetMutation_updateDataset(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "deleteDatasets":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._DatasetMutation_deleteDatasets(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var datasetQueryImplementors = []string{"DatasetQuery"}

func (ec *executionContext) _DatasetQuery(ctx context.Context, sel ast.SelectionSet, obj *DatasetQuery) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, datasetQueryImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("DatasetQuery")
		case "getDataset":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._DatasetQuery_getDataset(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "listDatasets":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._DatasetQuery_listDatasets(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var datasourceImplementors = []string{"Datasource", "PageNode"}

func (ec *executionContext) _Datasource(ctx context.Context, sel ast.SelectionSet, obj *Datasource) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, datasourceImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Datasource")
		case "id":
			out.Values[i] = ec._Datasource_id(ctx, field, obj)
		case "name":
			out.Values[i] = ec._Datasource_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "namespace":
			out.Values[i] = ec._Datasource_namespace(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "labels":
			out.Values[i] = ec._Datasource_labels(ctx, field, obj)
		case "annotations":
			out.Values[i] = ec._Datasource_annotations(ctx, field, obj)
		case "creator":
			out.Values[i] = ec._Datasource_creator(ctx, field, obj)
		case "displayName":
			out.Values[i] = ec._Datasource_displayName(ctx, field, obj)
		case "description":
			out.Values[i] = ec._Datasource_description(ctx, field, obj)
		case "endpoint":
			out.Values[i] = ec._Datasource_endpoint(ctx, field, obj)
		case "type":
			out.Values[i] = ec._Datasource_type(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "oss":
			out.Values[i] = ec._Datasource_oss(ctx, field, obj)
		case "web":
			out.Values[i] = ec._Datasource_web(ctx, field, obj)
		case "status":
			out.Values[i] = ec._Datasource_status(ctx, field, obj)
		case "message":
			out.Values[i] = ec._Datasource_message(ctx, field, obj)
		case "creationTimestamp":
			out.Values[i] = ec._Datasource_creationTimestamp(ctx, field, obj)
		case "updateTimestamp":
			out.Values[i] = ec._Datasource_updateTimestamp(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var datasourceMutationImplementors = []string{"DatasourceMutation"}

func (ec *executionContext) _DatasourceMutation(ctx context.Context, sel ast.SelectionSet, obj *DatasourceMutation) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, datasourceMutationImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("DatasourceMutation")
		case "createDatasource":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._DatasourceMutation_createDatasource(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "updateDatasource":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._DatasourceMutation_updateDatasource(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "deleteDatasources":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._DatasourceMutation_deleteDatasources(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var datasourceQueryImplementors = []string{"DatasourceQuery"}

func (ec *executionContext) _DatasourceQuery(ctx context.Context, sel ast.SelectionSet, obj *DatasourceQuery) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, datasourceQueryImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("DatasourceQuery")
		case "getDatasource":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._DatasourceQuery_getDatasource(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "checkDatasource":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._DatasourceQuery_checkDatasource(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "listDatasources":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._DatasourceQuery_listDatasources(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var embedderImplementors = []string{"Embedder", "PageNode"}

func (ec *executionContext) _Embedder(ctx context.Context, sel ast.SelectionSet, obj *Embedder) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, embedderImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Embedder")
		case "id":
			out.Values[i] = ec._Embedder_id(ctx, field, obj)
		case "name":
			out.Values[i] = ec._Embedder_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "namespace":
			out.Values[i] = ec._Embedder_namespace(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "labels":
			out.Values[i] = ec._Embedder_labels(ctx, field, obj)
		case "annotations":
			out.Values[i] = ec._Embedder_annotations(ctx, field, obj)
		case "creator":
			out.Values[i] = ec._Embedder_creator(ctx, field, obj)
		case "displayName":
			out.Values[i] = ec._Embedder_displayName(ctx, field, obj)
		case "description":
			out.Values[i] = ec._Embedder_description(ctx, field, obj)
		case "baseUrl":
			out.Values[i] = ec._Embedder_baseUrl(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "models":
			out.Values[i] = ec._Embedder_models(ctx, field, obj)
		case "provider":
			out.Values[i] = ec._Embedder_provider(ctx, field, obj)
		case "type":
			out.Values[i] = ec._Embedder_type(ctx, field, obj)
		case "creationTimestamp":
			out.Values[i] = ec._Embedder_creationTimestamp(ctx, field, obj)
		case "updateTimestamp":
			out.Values[i] = ec._Embedder_updateTimestamp(ctx, field, obj)
		case "status":
			out.Values[i] = ec._Embedder_status(ctx, field, obj)
		case "message":
			out.Values[i] = ec._Embedder_message(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var embedderMutationImplementors = []string{"EmbedderMutation"}

func (ec *executionContext) _EmbedderMutation(ctx context.Context, sel ast.SelectionSet, obj *EmbedderMutation) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, embedderMutationImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("EmbedderMutation")
		case "createEmbedder":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._EmbedderMutation_createEmbedder(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "updateEmbedder":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._EmbedderMutation_updateEmbedder(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "deleteEmbedders":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._EmbedderMutation_deleteEmbedders(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var embedderQueryImplementors = []string{"EmbedderQuery"}

func (ec *executionContext) _EmbedderQuery(ctx context.Context, sel ast.SelectionSet, obj *EmbedderQuery) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, embedderQueryImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("EmbedderQuery")
		case "getEmbedder":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._EmbedderQuery_getEmbedder(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "listEmbedders":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._EmbedderQuery_listEmbedders(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var endpointImplementors = []string{"Endpoint"}

func (ec *executionContext) _Endpoint(ctx context.Context, sel ast.SelectionSet, obj *Endpoint) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, endpointImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Endpoint")
		case "url":
			out.Values[i] = ec._Endpoint_url(ctx, field, obj)
		case "authSecret":
			out.Values[i] = ec._Endpoint_authSecret(ctx, field, obj)
		case "insecure":
			out.Values[i] = ec._Endpoint_insecure(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var fImplementors = []string{"F", "PageNode"}

func (ec *executionContext) _F(ctx context.Context, sel ast.SelectionSet, obj *F) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, fImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("F")
		case "path":
			out.Values[i] = ec._F_path(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "fileType":
			out.Values[i] = ec._F_fileType(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "count":
			out.Values[i] = ec._F_count(ctx, field, obj)
		case "time":
			out.Values[i] = ec._F_time(ctx, field, obj)
		case "size":
			out.Values[i] = ec._F_size(ctx, field, obj)
		case "creationTimestamp":
			out.Values[i] = ec._F_creationTimestamp(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var gPTImplementors = []string{"GPT", "PageNode"}

func (ec *executionContext) _GPT(ctx context.Context, sel ast.SelectionSet, obj *Gpt) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, gPTImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("GPT")
		case "name":
			out.Values[i] = ec._GPT_name(ctx, field, obj)
		case "displayName":
			out.Values[i] = ec._GPT_displayName(ctx, field, obj)
		case "description":
			out.Values[i] = ec._GPT_description(ctx, field, obj)
		case "hot":
			out.Values[i] = ec._GPT_hot(ctx, field, obj)
		case "creator":
			out.Values[i] = ec._GPT_creator(ctx, field, obj)
		case "category":
			out.Values[i] = ec._GPT_category(ctx, field, obj)
		case "icon":
			out.Values[i] = ec._GPT_icon(ctx, field, obj)
		case "prologue":
			out.Values[i] = ec._GPT_prologue(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var gPTQueryImplementors = []string{"GPTQuery"}

func (ec *executionContext) _GPTQuery(ctx context.Context, sel ast.SelectionSet, obj *GPTQuery) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, gPTQueryImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("GPTQuery")
		case "getGPT":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._GPTQuery_getGPT(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "listGPT":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._GPTQuery_listGPT(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var knowledgeBaseImplementors = []string{"KnowledgeBase", "PageNode"}

func (ec *executionContext) _KnowledgeBase(ctx context.Context, sel ast.SelectionSet, obj *KnowledgeBase) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, knowledgeBaseImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("KnowledgeBase")
		case "id":
			out.Values[i] = ec._KnowledgeBase_id(ctx, field, obj)
		case "name":
			out.Values[i] = ec._KnowledgeBase_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "namespace":
			out.Values[i] = ec._KnowledgeBase_namespace(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "labels":
			out.Values[i] = ec._KnowledgeBase_labels(ctx, field, obj)
		case "annotations":
			out.Values[i] = ec._KnowledgeBase_annotations(ctx, field, obj)
		case "creator":
			out.Values[i] = ec._KnowledgeBase_creator(ctx, field, obj)
		case "displayName":
			out.Values[i] = ec._KnowledgeBase_displayName(ctx, field, obj)
		case "description":
			out.Values[i] = ec._KnowledgeBase_description(ctx, field, obj)
		case "creationTimestamp":
			out.Values[i] = ec._KnowledgeBase_creationTimestamp(ctx, field, obj)
		case "updateTimestamp":
			out.Values[i] = ec._KnowledgeBase_updateTimestamp(ctx, field, obj)
		case "embedder":
			out.Values[i] = ec._KnowledgeBase_embedder(ctx, field, obj)
		case "embedderType":
			out.Values[i] = ec._KnowledgeBase_embedderType(ctx, field, obj)
		case "vectorStore":
			out.Values[i] = ec._KnowledgeBase_vectorStore(ctx, field, obj)
		case "fileGroupDetails":
			out.Values[i] = ec._KnowledgeBase_fileGroupDetails(ctx, field, obj)
		case "chunkSize":
			out.Values[i] = ec._KnowledgeBase_chunkSize(ctx, field, obj)
		case "chunkOverlap":
			out.Values[i] = ec._KnowledgeBase_chunkOverlap(ctx, field, obj)
		case "batchSize":
			out.Values[i] = ec._KnowledgeBase_batchSize(ctx, field, obj)
		case "status":
			out.Values[i] = ec._KnowledgeBase_status(ctx, field, obj)
		case "reason":
			out.Values[i] = ec._KnowledgeBase_reason(ctx, field, obj)
		case "message":
			out.Values[i] = ec._KnowledgeBase_message(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var knowledgeBaseMutationImplementors = []string{"KnowledgeBaseMutation"}

func (ec *executionContext) _KnowledgeBaseMutation(ctx context.Context, sel ast.SelectionSet, obj *KnowledgeBaseMutation) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, knowledgeBaseMutationImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("KnowledgeBaseMutation")
		case "createKnowledgeBase":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._KnowledgeBaseMutation_createKnowledgeBase(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "updateKnowledgeBase":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._KnowledgeBaseMutation_updateKnowledgeBase(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "deleteKnowledgeBase":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._KnowledgeBaseMutation_deleteKnowledgeBase(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var knowledgeBaseQueryImplementors = []string{"KnowledgeBaseQuery"}

func (ec *executionContext) _KnowledgeBaseQuery(ctx context.Context, sel ast.SelectionSet, obj *KnowledgeBaseQuery) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, knowledgeBaseQueryImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("KnowledgeBaseQuery")
		case "getKnowledgeBase":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._KnowledgeBaseQuery_getKnowledgeBase(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "listKnowledgeBases":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._KnowledgeBaseQuery_listKnowledgeBases(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var lLMImplementors = []string{"LLM", "PageNode"}

func (ec *executionContext) _LLM(ctx context.Context, sel ast.SelectionSet, obj *Llm) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, lLMImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("LLM")
		case "id":
			out.Values[i] = ec._LLM_id(ctx, field, obj)
		case "name":
			out.Values[i] = ec._LLM_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "namespace":
			out.Values[i] = ec._LLM_namespace(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "labels":
			out.Values[i] = ec._LLM_labels(ctx, field, obj)
		case "annotations":
			out.Values[i] = ec._LLM_annotations(ctx, field, obj)
		case "creator":
			out.Values[i] = ec._LLM_creator(ctx, field, obj)
		case "displayName":
			out.Values[i] = ec._LLM_displayName(ctx, field, obj)
		case "description":
			out.Values[i] = ec._LLM_description(ctx, field, obj)
		case "baseUrl":
			out.Values[i] = ec._LLM_baseUrl(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "models":
			out.Values[i] = ec._LLM_models(ctx, field, obj)
		case "provider":
			out.Values[i] = ec._LLM_provider(ctx, field, obj)
		case "type":
			out.Values[i] = ec._LLM_type(ctx, field, obj)
		case "creationTimestamp":
			out.Values[i] = ec._LLM_creationTimestamp(ctx, field, obj)
		case "updateTimestamp":
			out.Values[i] = ec._LLM_updateTimestamp(ctx, field, obj)
		case "status":
			out.Values[i] = ec._LLM_status(ctx, field, obj)
		case "message":
			out.Values[i] = ec._LLM_message(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var lLMConfigImplementors = []string{"LLMConfig"}

func (ec *executionContext) _LLMConfig(ctx context.Context, sel ast.SelectionSet, obj *LLMConfig) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, lLMConfigImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("LLMConfig")
		case "name":
			out.Values[i] = ec._LLMConfig_name(ctx, field, obj)
		case "namespace":
			out.Values[i] = ec._LLMConfig_namespace(ctx, field, obj)
		case "model":
			out.Values[i] = ec._LLMConfig_model(ctx, field, obj)
		case "temperature":
			out.Values[i] = ec._LLMConfig_temperature(ctx, field, obj)
		case "top_p":
			out.Values[i] = ec._LLMConfig_top_p(ctx, field, obj)
		case "max_tokens":
			out.Values[i] = ec._LLMConfig_max_tokens(ctx, field, obj)
		case "prompt_template":
			out.Values[i] = ec._LLMConfig_prompt_template(ctx, field, obj)
		case "provider":
			out.Values[i] = ec._LLMConfig_provider(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var lLMQueryImplementors = []string{"LLMQuery"}

func (ec *executionContext) _LLMQuery(ctx context.Context, sel ast.SelectionSet, obj *LLMQuery) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, lLMQueryImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("LLMQuery")
		case "getLLM":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._LLMQuery_getLLM(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "listLLMs":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._LLMQuery_listLLMs(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var labelSelectorRequirementImplementors = []string{"LabelSelectorRequirement"}

func (ec *executionContext) _LabelSelectorRequirement(ctx context.Context, sel ast.SelectionSet, obj *LabelSelectorRequirement) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, labelSelectorRequirementImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("LabelSelectorRequirement")
		case "key":
			out.Values[i] = ec._LabelSelectorRequirement_key(ctx, field, obj)
		case "values":
			out.Values[i] = ec._LabelSelectorRequirement_values(ctx, field, obj)
		case "operator":
			out.Values[i] = ec._LabelSelectorRequirement_operator(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var modelImplementors = []string{"Model", "PageNode"}

func (ec *executionContext) _Model(ctx context.Context, sel ast.SelectionSet, obj *Model) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, modelImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Model")
		case "id":
			out.Values[i] = ec._Model_id(ctx, field, obj)
		case "name":
			out.Values[i] = ec._Model_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "namespace":
			out.Values[i] = ec._Model_namespace(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "systemModel":
			out.Values[i] = ec._Model_systemModel(ctx, field, obj)
		case "labels":
			out.Values[i] = ec._Model_labels(ctx, field, obj)
		case "annotations":
			out.Values[i] = ec._Model_annotations(ctx, field, obj)
		case "creator":
			out.Values[i] = ec._Model_creator(ctx, field, obj)
		case "displayName":
			out.Values[i] = ec._Model_displayName(ctx, field, obj)
		case "description":
			out.Values[i] = ec._Model_description(ctx, field, obj)
		case "creationTimestamp":
			out.Values[i] = ec._Model_creationTimestamp(ctx, field, obj)
		case "updateTimestamp":
			out.Values[i] = ec._Model_updateTimestamp(ctx, field, obj)
		case "types":
			out.Values[i] = ec._Model_types(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "status":
			out.Values[i] = ec._Model_status(ctx, field, obj)
		case "message":
			out.Values[i] = ec._Model_message(ctx, field, obj)
		case "files":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Model_files(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "huggingFaceRepo":
			out.Values[i] = ec._Model_huggingFaceRepo(ctx, field, obj)
		case "modelScopeRepo":
			out.Values[i] = ec._Model_modelScopeRepo(ctx, field, obj)
		case "revision":
			out.Values[i] = ec._Model_revision(ctx, field, obj)
		case "modelSource":
			out.Values[i] = ec._Model_modelSource(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var modelMutationImplementors = []string{"ModelMutation"}

func (ec *executionContext) _ModelMutation(ctx context.Context, sel ast.SelectionSet, obj *ModelMutation) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, modelMutationImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ModelMutation")
		case "createModel":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._ModelMutation_createModel(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "updateModel":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._ModelMutation_updateModel(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "deleteModels":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._ModelMutation_deleteModels(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var modelQueryImplementors = []string{"ModelQuery"}

func (ec *executionContext) _ModelQuery(ctx context.Context, sel ast.SelectionSet, obj *ModelQuery) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, modelQueryImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ModelQuery")
		case "getModel":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._ModelQuery_getModel(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "listModels":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._ModelQuery_listModels(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var modelServiceImplementors = []string{"ModelService", "PageNode"}

func (ec *executionContext) _ModelService(ctx context.Context, sel ast.SelectionSet, obj *ModelService) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, modelServiceImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ModelService")
		case "id":
			out.Values[i] = ec._ModelService_id(ctx, field, obj)
		case "name":
			out.Values[i] = ec._ModelService_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "namespace":
			out.Values[i] = ec._ModelService_namespace(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "labels":
			out.Values[i] = ec._ModelService_labels(ctx, field, obj)
		case "annotations":
			out.Values[i] = ec._ModelService_annotations(ctx, field, obj)
		case "creator":
			out.Values[i] = ec._ModelService_creator(ctx, field, obj)
		case "displayName":
			out.Values[i] = ec._ModelService_displayName(ctx, field, obj)
		case "description":
			out.Values[i] = ec._ModelService_description(ctx, field, obj)
		case "creationTimestamp":
			out.Values[i] = ec._ModelService_creationTimestamp(ctx, field, obj)
		case "updateTimestamp":
			out.Values[i] = ec._ModelService_updateTimestamp(ctx, field, obj)
		case "providerType":
			out.Values[i] = ec._ModelService_providerType(ctx, field, obj)
		case "types":
			out.Values[i] = ec._ModelService_types(ctx, field, obj)
		case "apiType":
			out.Values[i] = ec._ModelService_apiType(ctx, field, obj)
		case "llmModels":
			out.Values[i] = ec._ModelService_llmModels(ctx, field, obj)
		case "embeddingModels":
			out.Values[i] = ec._ModelService_embeddingModels(ctx, field, obj)
		case "baseUrl":
			out.Values[i] = ec._ModelService_baseUrl(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "status":
			out.Values[i] = ec._ModelService_status(ctx, field, obj)
		case "message":
			out.Values[i] = ec._ModelService_message(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var modelServiceMutationImplementors = []string{"ModelServiceMutation"}

func (ec *executionContext) _ModelServiceMutation(ctx context.Context, sel ast.SelectionSet, obj *ModelServiceMutation) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, modelServiceMutationImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ModelServiceMutation")
		case "createModelService":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._ModelServiceMutation_createModelService(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "updateModelService":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._ModelServiceMutation_updateModelService(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "deleteModelService":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._ModelServiceMutation_deleteModelService(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var modelServiceQueryImplementors = []string{"ModelServiceQuery"}

func (ec *executionContext) _ModelServiceQuery(ctx context.Context, sel ast.SelectionSet, obj *ModelServiceQuery) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, modelServiceQueryImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ModelServiceQuery")
		case "getModelService":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._ModelServiceQuery_getModelService(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "listModelServices":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._ModelServiceQuery_listModelServices(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "checkModelService":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._ModelServiceQuery_checkModelService(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var mutationImplementors = []string{"Mutation"}

func (ec *executionContext) _Mutation(ctx context.Context, sel ast.SelectionSet) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, mutationImplementors)
	ctx = graphql.WithFieldContext(ctx, &graphql.FieldContext{
		Object: "Mutation",
	})

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		innerCtx := graphql.WithRootFieldContext(ctx, &graphql.RootFieldContext{
			Object: field.Name,
			Field:  field,
		})

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Mutation")
		case "hello":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_hello(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "Application":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_Application(ctx, field)
			})
		case "dataProcess":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_dataProcess(ctx, field)
			})
		case "Dataset":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_Dataset(ctx, field)
			})
		case "Datasource":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_Datasource(ctx, field)
			})
		case "Embedder":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_Embedder(ctx, field)
			})
		case "KnowledgeBase":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_KnowledgeBase(ctx, field)
			})
		case "Model":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_Model(ctx, field)
			})
		case "ModelService":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_ModelService(ctx, field)
			})
		case "RAG":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_RAG(ctx, field)
			})
		case "VersionedDataset":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_VersionedDataset(ctx, field)
			})
		case "Worker":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_Worker(ctx, field)
			})
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var nodeSelectorRequirementImplementors = []string{"NodeSelectorRequirement"}

func (ec *executionContext) _NodeSelectorRequirement(ctx context.Context, sel ast.SelectionSet, obj *NodeSelectorRequirement) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, nodeSelectorRequirementImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("NodeSelectorRequirement")
		case "key":
			out.Values[i] = ec._NodeSelectorRequirement_key(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "operator":
			out.Values[i] = ec._NodeSelectorRequirement_operator(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "values":
			out.Values[i] = ec._NodeSelectorRequirement_values(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var ossImplementors = []string{"Oss"}

func (ec *executionContext) _Oss(ctx context.Context, sel ast.SelectionSet, obj *Oss) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, ossImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Oss")
		case "bucket":
			out.Values[i] = ec._Oss_bucket(ctx, field, obj)
		case "object":
			out.Values[i] = ec._Oss_object(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var paginatedDataProcessItemImplementors = []string{"PaginatedDataProcessItem"}

func (ec *executionContext) _PaginatedDataProcessItem(ctx context.Context, sel ast.SelectionSet, obj *PaginatedDataProcessItem) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, paginatedDataProcessItemImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("PaginatedDataProcessItem")
		case "status":
			out.Values[i] = ec._PaginatedDataProcessItem_status(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "data":
			out.Values[i] = ec._PaginatedDataProcessItem_data(ctx, field, obj)
		case "message":
			out.Values[i] = ec._PaginatedDataProcessItem_message(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var paginatedResultImplementors = []string{"PaginatedResult"}

func (ec *executionContext) _PaginatedResult(ctx context.Context, sel ast.SelectionSet, obj *PaginatedResult) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, paginatedResultImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("PaginatedResult")
		case "hasNextPage":
			out.Values[i] = ec._PaginatedResult_hasNextPage(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "nodes":
			out.Values[i] = ec._PaginatedResult_nodes(ctx, field, obj)
		case "page":
			out.Values[i] = ec._PaginatedResult_page(ctx, field, obj)
		case "pageSize":
			out.Values[i] = ec._PaginatedResult_pageSize(ctx, field, obj)
		case "totalCount":
			out.Values[i] = ec._PaginatedResult_totalCount(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var parameterImplementors = []string{"Parameter"}

func (ec *executionContext) _Parameter(ctx context.Context, sel ast.SelectionSet, obj *Parameter) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, parameterImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Parameter")
		case "key":
			out.Values[i] = ec._Parameter_key(ctx, field, obj)
		case "value":
			out.Values[i] = ec._Parameter_value(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var persistentVolumeClaimSpecImplementors = []string{"PersistentVolumeClaimSpec"}

func (ec *executionContext) _PersistentVolumeClaimSpec(ctx context.Context, sel ast.SelectionSet, obj *PersistentVolumeClaimSpec) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, persistentVolumeClaimSpecImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("PersistentVolumeClaimSpec")
		case "accessModes":
			out.Values[i] = ec._PersistentVolumeClaimSpec_accessModes(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "selector":
			out.Values[i] = ec._PersistentVolumeClaimSpec_selector(ctx, field, obj)
		case "resources":
			out.Values[i] = ec._PersistentVolumeClaimSpec_resources(ctx, field, obj)
		case "volumeName":
			out.Values[i] = ec._PersistentVolumeClaimSpec_volumeName(ctx, field, obj)
		case "storageClassName":
			out.Values[i] = ec._PersistentVolumeClaimSpec_storageClassName(ctx, field, obj)
		case "volumeMode":
			out.Values[i] = ec._PersistentVolumeClaimSpec_volumeMode(ctx, field, obj)
		case "datasource":
			out.Values[i] = ec._PersistentVolumeClaimSpec_datasource(ctx, field, obj)
		case "dataSourceRef":
			out.Values[i] = ec._PersistentVolumeClaimSpec_dataSourceRef(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var queryImplementors = []string{"Query"}

func (ec *executionContext) _Query(ctx context.Context, sel ast.SelectionSet) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, queryImplementors)
	ctx = graphql.WithFieldContext(ctx, &graphql.FieldContext{
		Object: "Query",
	})

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		innerCtx := graphql.WithRootFieldContext(ctx, &graphql.RootFieldContext{
			Object: field.Name,
			Field:  field,
		})

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Query")
		case "hello":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_hello(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "Application":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_Application(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "dataProcess":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_dataProcess(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "Dataset":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_Dataset(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "Datasource":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_Datasource(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "Embedder":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_Embedder(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "GPT":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_GPT(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "KnowledgeBase":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_KnowledgeBase(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "LLM":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_LLM(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "Model":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_Model(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "ModelService":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_ModelService(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "RAG":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_RAG(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "RayCluster":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_RayCluster(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "VersionedDataset":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_VersionedDataset(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "Worker":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_Worker(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "__type":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Query___type(ctx, field)
			})
		case "__schema":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Query___schema(ctx, field)
			})
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var rAGImplementors = []string{"RAG", "PageNode"}

func (ec *executionContext) _RAG(ctx context.Context, sel ast.SelectionSet, obj *Rag) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, rAGImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("RAG")
		case "name":
			out.Values[i] = ec._RAG_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "namespace":
			out.Values[i] = ec._RAG_namespace(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "labels":
			out.Values[i] = ec._RAG_labels(ctx, field, obj)
		case "annotations":
			out.Values[i] = ec._RAG_annotations(ctx, field, obj)
		case "creator":
			out.Values[i] = ec._RAG_creator(ctx, field, obj)
		case "displayName":
			out.Values[i] = ec._RAG_displayName(ctx, field, obj)
		case "description":
			out.Values[i] = ec._RAG_description(ctx, field, obj)
		case "creationTimestamp":
			out.Values[i] = ec._RAG_creationTimestamp(ctx, field, obj)
		case "completeTimestamp":
			out.Values[i] = ec._RAG_completeTimestamp(ctx, field, obj)
		case "application":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._RAG_application(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "datasets":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._RAG_datasets(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "judgeLLM":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._RAG_judgeLLM(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "metrics":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._RAG_metrics(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "storage":
			out.Values[i] = ec._RAG_storage(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "serviceAccountName":
			out.Values[i] = ec._RAG_serviceAccountName(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "suspend":
			out.Values[i] = ec._RAG_suspend(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "status":
			out.Values[i] = ec._RAG_status(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "phase":
			out.Values[i] = ec._RAG_phase(ctx, field, obj)
		case "phaseMessage":
			out.Values[i] = ec._RAG_phaseMessage(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var rAGDatasetImplementors = []string{"RAGDataset"}

func (ec *executionContext) _RAGDataset(ctx context.Context, sel ast.SelectionSet, obj *RAGDataset) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, rAGDatasetImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("RAGDataset")
		case "source":
			out.Values[i] = ec._RAGDataset_source(ctx, field, obj)
		case "files":
			out.Values[i] = ec._RAGDataset_files(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var rAGMetricImplementors = []string{"RAGMetric"}

func (ec *executionContext) _RAGMetric(ctx context.Context, sel ast.SelectionSet, obj *RAGMetric) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, rAGMetricImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("RAGMetric")
		case "metricKind":
			out.Values[i] = ec._RAGMetric_metricKind(ctx, field, obj)
		case "parameters":
			out.Values[i] = ec._RAGMetric_parameters(ctx, field, obj)
		case "toleranceThreshbold":
			out.Values[i] = ec._RAGMetric_toleranceThreshbold(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var rAGMutationImplementors = []string{"RAGMutation"}

func (ec *executionContext) _RAGMutation(ctx context.Context, sel ast.SelectionSet, obj *RAGMutation) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, rAGMutationImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("RAGMutation")
		case "createRAG":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._RAGMutation_createRAG(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "updateRAG":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._RAGMutation_updateRAG(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "deleteRAG":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._RAGMutation_deleteRAG(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "duplicateRAG":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._RAGMutation_duplicateRAG(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var rAGQueryImplementors = []string{"RAGQuery"}

func (ec *executionContext) _RAGQuery(ctx context.Context, sel ast.SelectionSet, obj *RAGQuery) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, rAGQueryImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("RAGQuery")
		case "getRAG":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._RAGQuery_getRAG(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "listRAG":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._RAGQuery_listRAG(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var rayClusterImplementors = []string{"RayCluster", "PageNode"}

func (ec *executionContext) _RayCluster(ctx context.Context, sel ast.SelectionSet, obj *RayCluster) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, rayClusterImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("RayCluster")
		case "index":
			out.Values[i] = ec._RayCluster_index(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "name":
			out.Values[i] = ec._RayCluster_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "headAddress":
			out.Values[i] = ec._RayCluster_headAddress(ctx, field, obj)
		case "dashboardHost":
			out.Values[i] = ec._RayCluster_dashboardHost(ctx, field, obj)
		case "pythonVersion":
			out.Values[i] = ec._RayCluster_pythonVersion(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var rayClusterQueryImplementors = []string{"RayClusterQuery"}

func (ec *executionContext) _RayClusterQuery(ctx context.Context, sel ast.SelectionSet, obj *RayClusterQuery) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, rayClusterQueryImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("RayClusterQuery")
		case "listRayClusters":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._RayClusterQuery_listRayClusters(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var removeDuplicateConfigItemImplementors = []string{"RemoveDuplicateConfigItem"}

func (ec *executionContext) _RemoveDuplicateConfigItem(ctx context.Context, sel ast.SelectionSet, obj *RemoveDuplicateConfigItem) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, removeDuplicateConfigItemImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("RemoveDuplicateConfigItem")
		case "embedding_name":
			out.Values[i] = ec._RemoveDuplicateConfigItem_embedding_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "embedding_namespace":
			out.Values[i] = ec._RemoveDuplicateConfigItem_embedding_namespace(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "embedding_model":
			out.Values[i] = ec._RemoveDuplicateConfigItem_embedding_model(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "embedding_provider":
			out.Values[i] = ec._RemoveDuplicateConfigItem_embedding_provider(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "similarity":
			out.Values[i] = ec._RemoveDuplicateConfigItem_similarity(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var resourceImplementors = []string{"Resource"}

func (ec *executionContext) _Resource(ctx context.Context, sel ast.SelectionSet, obj *Resource) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, resourceImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Resource")
		case "limits":
			out.Values[i] = ec._Resource_limits(ctx, field, obj)
		case "requests":
			out.Values[i] = ec._Resource_requests(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var resourcesImplementors = []string{"Resources"}

func (ec *executionContext) _Resources(ctx context.Context, sel ast.SelectionSet, obj *Resources) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, resourcesImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Resources")
		case "cpu":
			out.Values[i] = ec._Resources_cpu(ctx, field, obj)
		case "memory":
			out.Values[i] = ec._Resources_memory(ctx, field, obj)
		case "nvidiaGPU":
			out.Values[i] = ec._Resources_nvidiaGPU(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var selectorImplementors = []string{"Selector"}

func (ec *executionContext) _Selector(ctx context.Context, sel ast.SelectionSet, obj *Selector) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, selectorImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Selector")
		case "matchLabels":
			out.Values[i] = ec._Selector_matchLabels(ctx, field, obj)
		case "matchExpressions":
			out.Values[i] = ec._Selector_matchExpressions(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var toolImplementors = []string{"Tool"}

func (ec *executionContext) _Tool(ctx context.Context, sel ast.SelectionSet, obj *Tool) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, toolImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Tool")
		case "name":
			out.Values[i] = ec._Tool_name(ctx, field, obj)
		case "params":
			out.Values[i] = ec._Tool_params(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var typedObjectReferenceImplementors = []string{"TypedObjectReference"}

func (ec *executionContext) _TypedObjectReference(ctx context.Context, sel ast.SelectionSet, obj *TypedObjectReference) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, typedObjectReferenceImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("TypedObjectReference")
		case "apiGroup":
			out.Values[i] = ec._TypedObjectReference_apiGroup(ctx, field, obj)
		case "kind":
			out.Values[i] = ec._TypedObjectReference_kind(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "name":
			out.Values[i] = ec._TypedObjectReference_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "displayName":
			out.Values[i] = ec._TypedObjectReference_displayName(ctx, field, obj)
		case "namespace":
			out.Values[i] = ec._TypedObjectReference_namespace(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var versionedDatasetImplementors = []string{"VersionedDataset", "PageNode"}

func (ec *executionContext) _VersionedDataset(ctx context.Context, sel ast.SelectionSet, obj *VersionedDataset) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, versionedDatasetImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("VersionedDataset")
		case "id":
			out.Values[i] = ec._VersionedDataset_id(ctx, field, obj)
		case "name":
			out.Values[i] = ec._VersionedDataset_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "namespace":
			out.Values[i] = ec._VersionedDataset_namespace(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "labels":
			out.Values[i] = ec._VersionedDataset_labels(ctx, field, obj)
		case "annotations":
			out.Values[i] = ec._VersionedDataset_annotations(ctx, field, obj)
		case "creator":
			out.Values[i] = ec._VersionedDataset_creator(ctx, field, obj)
		case "displayName":
			out.Values[i] = ec._VersionedDataset_displayName(ctx, field, obj)
		case "description":
			out.Values[i] = ec._VersionedDataset_description(ctx, field, obj)
		case "dataset":
			out.Values[i] = ec._VersionedDataset_dataset(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "updateTimestamp":
			out.Values[i] = ec._VersionedDataset_updateTimestamp(ctx, field, obj)
		case "creationTimestamp":
			out.Values[i] = ec._VersionedDataset_creationTimestamp(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "files":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._VersionedDataset_files(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "version":
			out.Values[i] = ec._VersionedDataset_version(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "released":
			out.Values[i] = ec._VersionedDataset_released(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "syncStatus":
			out.Values[i] = ec._VersionedDataset_syncStatus(ctx, field, obj)
		case "syncMsg":
			out.Values[i] = ec._VersionedDataset_syncMsg(ctx, field, obj)
		case "dataProcessStatus":
			out.Values[i] = ec._VersionedDataset_dataProcessStatus(ctx, field, obj)
		case "dataProcessMsg":
			out.Values[i] = ec._VersionedDataset_dataProcessMsg(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var versionedDatasetMutationImplementors = []string{"VersionedDatasetMutation"}

func (ec *executionContext) _VersionedDatasetMutation(ctx context.Context, sel ast.SelectionSet, obj *VersionedDatasetMutation) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, versionedDatasetMutationImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("VersionedDatasetMutation")
		case "createVersionedDataset":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._VersionedDatasetMutation_createVersionedDataset(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "updateVersionedDataset":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._VersionedDatasetMutation_updateVersionedDataset(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "deleteVersionedDatasets":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._VersionedDatasetMutation_deleteVersionedDatasets(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var versionedDatasetQueryImplementors = []string{"VersionedDatasetQuery"}

func (ec *executionContext) _VersionedDatasetQuery(ctx context.Context, sel ast.SelectionSet, obj *VersionedDatasetQuery) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, versionedDatasetQueryImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("VersionedDatasetQuery")
		case "getVersionedDataset":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._VersionedDatasetQuery_getVersionedDataset(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "listVersionedDatasets":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._VersionedDatasetQuery_listVersionedDatasets(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var webImplementors = []string{"Web"}

func (ec *executionContext) _Web(ctx context.Context, sel ast.SelectionSet, obj *Web) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, webImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Web")
		case "recommendIntervalTime":
			out.Values[i] = ec._Web_recommendIntervalTime(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var workerImplementors = []string{"Worker", "PageNode"}

func (ec *executionContext) _Worker(ctx context.Context, sel ast.SelectionSet, obj *Worker) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, workerImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Worker")
		case "id":
			out.Values[i] = ec._Worker_id(ctx, field, obj)
		case "name":
			out.Values[i] = ec._Worker_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "namespace":
			out.Values[i] = ec._Worker_namespace(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "labels":
			out.Values[i] = ec._Worker_labels(ctx, field, obj)
		case "annotations":
			out.Values[i] = ec._Worker_annotations(ctx, field, obj)
		case "creator":
			out.Values[i] = ec._Worker_creator(ctx, field, obj)
		case "displayName":
			out.Values[i] = ec._Worker_displayName(ctx, field, obj)
		case "description":
			out.Values[i] = ec._Worker_description(ctx, field, obj)
		case "creationTimestamp":
			out.Values[i] = ec._Worker_creationTimestamp(ctx, field, obj)
		case "updateTimestamp":
			out.Values[i] = ec._Worker_updateTimestamp(ctx, field, obj)
		case "type":
			out.Values[i] = ec._Worker_type(ctx, field, obj)
		case "model":
			out.Values[i] = ec._Worker_model(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "modelTypes":
			out.Values[i] = ec._Worker_modelTypes(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "replicas":
			out.Values[i] = ec._Worker_replicas(ctx, field, obj)
		case "resources":
			out.Values[i] = ec._Worker_resources(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "status":
			out.Values[i] = ec._Worker_status(ctx, field, obj)
		case "message":
			out.Values[i] = ec._Worker_message(ctx, field, obj)
		case "api":
			out.Values[i] = ec._Worker_api(ctx, field, obj)
		case "matchExpressions":
			out.Values[i] = ec._Worker_matchExpressions(ctx, field, obj)
		case "additionalEnvs":
			out.Values[i] = ec._Worker_additionalEnvs(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var workerMutationImplementors = []string{"WorkerMutation"}

func (ec *executionContext) _WorkerMutation(ctx context.Context, sel ast.SelectionSet, obj *WorkerMutation) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, workerMutationImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("WorkerMutation")
		case "createWorker":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._WorkerMutation_createWorker(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "updateWorker":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._WorkerMutation_updateWorker(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "deleteWorkers":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._WorkerMutation_deleteWorkers(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var workerQueryImplementors = []string{"WorkerQuery"}

func (ec *executionContext) _WorkerQuery(ctx context.Context, sel ast.SelectionSet, obj *WorkerQuery) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, workerQueryImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("WorkerQuery")
		case "getWorker":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._WorkerQuery_getWorker(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "listWorkers":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._WorkerQuery_listWorkers(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var __DirectiveImplementors = []string{"__Directive"}

func (ec *executionContext) ___Directive(ctx context.Context, sel ast.SelectionSet, obj *introspection.Directive) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __DirectiveImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__Directive")
		case "name":
			out.Values[i] = ec.___Directive_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "description":
			out.Values[i] = ec.___Directive_description(ctx, field, obj)
		case "locations":
			out.Values[i] = ec.___Directive_locations(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "args":
			out.Values[i] = ec.___Directive_args(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "isRepeatable":
			out.Values[i] = ec.___Directive_isRepeatable(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var __EnumValueImplementors = []string{"__EnumValue"}

func (ec *executionContext) ___EnumValue(ctx context.Context, sel ast.SelectionSet, obj *introspection.EnumValue) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __EnumValueImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__EnumValue")
		case "name":
			out.Values[i] = ec.___EnumValue_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "description":
			out.Values[i] = ec.___EnumValue_description(ctx, field, obj)
		case "isDeprecated":
			out.Values[i] = ec.___EnumValue_isDeprecated(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "deprecationReason":
			out.Values[i] = ec.___EnumValue_deprecationReason(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var __FieldImplementors = []string{"__Field"}

func (ec *executionContext) ___Field(ctx context.Context, sel ast.SelectionSet, obj *introspection.Field) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __FieldImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__Field")
		case "name":
			out.Values[i] = ec.___Field_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "description":
			out.Values[i] = ec.___Field_description(ctx, field, obj)
		case "args":
			out.Values[i] = ec.___Field_args(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "type":
			out.Values[i] = ec.___Field_type(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "isDeprecated":
			out.Values[i] = ec.___Field_isDeprecated(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "deprecationReason":
			out.Values[i] = ec.___Field_deprecationReason(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var __InputValueImplementors = []string{"__InputValue"}

func (ec *executionContext) ___InputValue(ctx context.Context, sel ast.SelectionSet, obj *introspection.InputValue) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __InputValueImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__InputValue")
		case "name":
			out.Values[i] = ec.___InputValue_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "description":
			out.Values[i] = ec.___InputValue_description(ctx, field, obj)
		case "type":
			out.Values[i] = ec.___InputValue_type(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "defaultValue":
			out.Values[i] = ec.___InputValue_defaultValue(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var __SchemaImplementors = []string{"__Schema"}

func (ec *executionContext) ___Schema(ctx context.Context, sel ast.SelectionSet, obj *introspection.Schema) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __SchemaImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__Schema")
		case "description":
			out.Values[i] = ec.___Schema_description(ctx, field, obj)
		case "types":
			out.Values[i] = ec.___Schema_types(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "queryType":
			out.Values[i] = ec.___Schema_queryType(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "mutationType":
			out.Values[i] = ec.___Schema_mutationType(ctx, field, obj)
		case "subscriptionType":
			out.Values[i] = ec.___Schema_subscriptionType(ctx, field, obj)
		case "directives":
			out.Values[i] = ec.___Schema_directives(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var __TypeImplementors = []string{"__Type"}

func (ec *executionContext) ___Type(ctx context.Context, sel ast.SelectionSet, obj *introspection.Type) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __TypeImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__Type")
		case "kind":
			out.Values[i] = ec.___Type_kind(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "name":
			out.Values[i] = ec.___Type_name(ctx, field, obj)
		case "description":
			out.Values[i] = ec.___Type_description(ctx, field, obj)
		case "fields":
			out.Values[i] = ec.___Type_fields(ctx, field, obj)
		case "interfaces":
			out.Values[i] = ec.___Type_interfaces(ctx, field, obj)
		case "possibleTypes":
			out.Values[i] = ec.___Type_possibleTypes(ctx, field, obj)
		case "enumValues":
			out.Values[i] = ec.___Type_enumValues(ctx, field, obj)
		case "inputFields":
			out.Values[i] = ec.___Type_inputFields(ctx, field, obj)
		case "ofType":
			out.Values[i] = ec.___Type_ofType(ctx, field, obj)
		case "specifiedByURL":
			out.Values[i] = ec.___Type_specifiedByURL(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var filedetailImplementors = []string{"filedetail"}

func (ec *executionContext) _filedetail(ctx context.Context, sel ast.SelectionSet, obj *Filedetail) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, filedetailImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("filedetail")
		case "path":
			out.Values[i] = ec._filedetail_path(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "fileType":
			out.Values[i] = ec._filedetail_fileType(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "count":
			out.Values[i] = ec._filedetail_count(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "size":
			out.Values[i] = ec._filedetail_size(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "updateTimestamp":
			out.Values[i] = ec._filedetail_updateTimestamp(ctx, field, obj)
		case "timeCost":
			out.Values[i] = ec._filedetail_timeCost(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "phase":
			out.Values[i] = ec._filedetail_phase(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var filegroupImplementors = []string{"filegroup"}

func (ec *executionContext) _filegroup(ctx context.Context, sel ast.SelectionSet, obj *Filegroup) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, filegroupImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("filegroup")
		case "source":
			out.Values[i] = ec._filegroup_source(ctx, field, obj)
		case "path":
			out.Values[i] = ec._filegroup_path(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var filegroupdetailImplementors = []string{"filegroupdetail"}

func (ec *executionContext) _filegroupdetail(ctx context.Context, sel ast.SelectionSet, obj *Filegroupdetail) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, filegroupdetailImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("filegroupdetail")
		case "source":
			out.Values[i] = ec._filegroupdetail_source(ctx, field, obj)
		case "filedetails":
			out.Values[i] = ec._filegroupdetail_filedetails(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

// endregion **************************** object.gotpl ****************************

// region    ***************************** type.gotpl *****************************

func (ec *executionContext) marshalNApplication2githubcomkubeagiarcadiaapiservergraphgeneratedApplication(ctx context.Context, sel ast.SelectionSet, v Application) graphql.Marshaler {
	return ec._Application(ctx, sel, &v)
}

func (ec *executionContext) marshalNApplication2githubcomkubeagiarcadiaapiservergraphgeneratedApplication(ctx context.Context, sel ast.SelectionSet, v *Application) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._Application(ctx, sel, v)
}

func (ec *executionContext) marshalNApplicationMetadata2githubcomkubeagiarcadiaapiservergraphgeneratedApplicationMetadata(ctx context.Context, sel ast.SelectionSet, v ApplicationMetadata) graphql.Marshaler {
	return ec._ApplicationMetadata(ctx, sel, &v)
}

func (ec *executionContext) marshalNApplicationMetadata2githubcomkubeagiarcadiaapiservergraphgeneratedApplicationMetadata(ctx context.Context, sel ast.SelectionSet, v *ApplicationMetadata) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._ApplicationMetadata(ctx, sel, v)
}

func (ec *executionContext) unmarshalNBoolean2bool(ctx context.Context, v interface{}) (bool, error) {
	res, err := graphql.UnmarshalBoolean(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNBoolean2bool(ctx context.Context, sel ast.SelectionSet, v bool) graphql.Marshaler {
	res := graphql.MarshalBoolean(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) unmarshalNCreateApplicationMetadataInput2githubcomkubeagiarcadiaapiservergraphgeneratedCreateApplicationMetadataInput(ctx context.Context, v interface{}) (CreateApplicationMetadataInput, error) {
	res, err := ec.unmarshalInputCreateApplicationMetadataInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNCreateDatasourceInput2githubcomkubeagiarcadiaapiservergraphgeneratedCreateDatasourceInput(ctx context.Context, v interface{}) (CreateDatasourceInput, error) {
	res, err := ec.unmarshalInputCreateDatasourceInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNCreateEmbedderInput2githubcomkubeagiarcadiaapiservergraphgeneratedCreateEmbedderInput(ctx context.Context, v interface{}) (CreateEmbedderInput, error) {
	res, err := ec.unmarshalInputCreateEmbedderInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNCreateKnowledgeBaseInput2githubcomkubeagiarcadiaapiservergraphgeneratedCreateKnowledgeBaseInput(ctx context.Context, v interface{}) (CreateKnowledgeBaseInput, error) {
	res, err := ec.unmarshalInputCreateKnowledgeBaseInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNCreateModelInput2githubcomkubeagiarcadiaapiservergraphgeneratedCreateModelInput(ctx context.Context, v interface{}) (CreateModelInput, error) {
	res, err := ec.unmarshalInputCreateModelInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNCreateModelServiceInput2githubcomkubeagiarcadiaapiservergraphgeneratedCreateModelServiceInput(ctx context.Context, v interface{}) (CreateModelServiceInput, error) {
	res, err := ec.unmarshalInputCreateModelServiceInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNCreateRAGInput2githubcomkubeagiarcadiaapiservergraphgeneratedCreateRAGInput(ctx context.Context, v interface{}) (CreateRAGInput, error) {
	res, err := ec.unmarshalInputCreateRAGInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNCreateVersionedDatasetInput2githubcomkubeagiarcadiaapiservergraphgeneratedCreateVersionedDatasetInput(ctx context.Context, v interface{}) (CreateVersionedDatasetInput, error) {
	res, err := ec.unmarshalInputCreateVersionedDatasetInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNCreateWorkerInput2githubcomkubeagiarcadiaapiservergraphgeneratedCreateWorkerInput(ctx context.Context, v interface{}) (CreateWorkerInput, error) {
	res, err := ec.unmarshalInputCreateWorkerInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNDataProcessConfig2githubcomkubeagiarcadiaapiservergraphgeneratedDataProcessConfig(ctx context.Context, sel ast.SelectionSet, v *DataProcessConfig) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._DataProcessConfig(ctx, sel, v)
}

func (ec *executionContext) marshalNDataProcessConfigInfo2githubcomkubeagiarcadiaapiservergraphgeneratedDataProcessConfigInfo(ctx context.Context, sel ast.SelectionSet, v *DataProcessConfigInfo) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._DataProcessConfigInfo(ctx, sel, v)
}

func (ec *executionContext) unmarshalNDataProcessConfigItem2githubcomkubeagiarcadiaapiservergraphgeneratedDataProcessConfigItem(ctx context.Context, v interface{}) (*DataProcessConfigItem, error) {
	res, err := ec.unmarshalInputDataProcessConfigItem(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNDataProcessDetailsItem2githubcomkubeagiarcadiaapiservergraphgeneratedDataProcessDetailsItem(ctx context.Context, sel ast.SelectionSet, v DataProcessDetailsItem) graphql.Marshaler {
	return ec._DataProcessDetailsItem(ctx, sel, &v)
}

func (ec *executionContext) marshalNDataProcessItem2githubcomkubeagiarcadiaapiservergraphgeneratedDataProcessItem(ctx context.Context, sel ast.SelectionSet, v *DataProcessItem) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._DataProcessItem(ctx, sel, v)
}

func (ec *executionContext) marshalNDataProcessSupportTypeChildren2githubcomkubeagiarcadiaapiservergraphgeneratedDataProcessSupportTypeChildren(ctx context.Context, sel ast.SelectionSet, v *DataProcessSupportTypeChildren) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._DataProcessSupportTypeChildren(ctx, sel, v)
}

func (ec *executionContext) marshalNDataProcessSupportTypeItem2githubcomkubeagiarcadiaapiservergraphgeneratedDataProcessSupportTypeItem(ctx context.Context, sel ast.SelectionSet, v *DataProcessSupportTypeItem) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._DataProcessSupportTypeItem(ctx, sel, v)
}

func (ec *executionContext) marshalNDataset2githubcomkubeagiarcadiaapiservergraphgeneratedDataset(ctx context.Context, sel ast.SelectionSet, v Dataset) graphql.Marshaler {
	return ec._Dataset(ctx, sel, &v)
}

func (ec *executionContext) marshalNDataset2githubcomkubeagiarcadiaapiservergraphgeneratedDataset(ctx context.Context, sel ast.SelectionSet, v *Dataset) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._Dataset(ctx, sel, v)
}

func (ec *executionContext) marshalNDatasource2githubcomkubeagiarcadiaapiservergraphgeneratedDatasource(ctx context.Context, sel ast.SelectionSet, v Datasource) graphql.Marshaler {
	return ec._Datasource(ctx, sel, &v)
}

func (ec *executionContext) marshalNDatasource2githubcomkubeagiarcadiaapiservergraphgeneratedDatasource(ctx context.Context, sel ast.SelectionSet, v *Datasource) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._Datasource(ctx, sel, v)
}

func (ec *executionContext) unmarshalNDeleteCommonInput2githubcomkubeagiarcadiaapiservergraphgeneratedDeleteCommonInput(ctx context.Context, v interface{}) (DeleteCommonInput, error) {
	res, err := ec.unmarshalInputDeleteCommonInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNDeleteRAGInput2githubcomkubeagiarcadiaapiservergraphgeneratedDeleteRAGInput(ctx context.Context, v interface{}) (DeleteRAGInput, error) {
	res, err := ec.unmarshalInputDeleteRAGInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNDeleteVersionedDatasetInput2githubcomkubeagiarcadiaapiservergraphgeneratedDeleteVersionedDatasetInput(ctx context.Context, v interface{}) (DeleteVersionedDatasetInput, error) {
	res, err := ec.unmarshalInputDeleteVersionedDatasetInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNDuplicateRAGInput2githubcomkubeagiarcadiaapiservergraphgeneratedDuplicateRAGInput(ctx context.Context, v interface{}) (DuplicateRAGInput, error) {
	res, err := ec.unmarshalInputDuplicateRAGInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNEmbedder2githubcomkubeagiarcadiaapiservergraphgeneratedEmbedder(ctx context.Context, sel ast.SelectionSet, v Embedder) graphql.Marshaler {
	return ec._Embedder(ctx, sel, &v)
}

func (ec *executionContext) marshalNEmbedder2githubcomkubeagiarcadiaapiservergraphgeneratedEmbedder(ctx context.Context, sel ast.SelectionSet, v *Embedder) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._Embedder(ctx, sel, v)
}

func (ec *executionContext) unmarshalNEndpointInput2githubcomkubeagiarcadiaapiservergraphgeneratedEndpointInput(ctx context.Context, v interface{}) (EndpointInput, error) {
	res, err := ec.unmarshalInputEndpointInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNF2githubcomkubeagiarcadiaapiservergraphgeneratedF(ctx context.Context, sel ast.SelectionSet, v *F) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._F(ctx, sel, v)
}

func (ec *executionContext) unmarshalNFileGroup2githubcomkubeagiarcadiaapiservergraphgeneratedFileGroup(ctx context.Context, v interface{}) (*FileGroup, error) {
	res, err := ec.unmarshalInputFileGroup(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNFileItem2githubcomkubeagiarcadiaapiservergraphgeneratedFileItem(ctx context.Context, v interface{}) (*FileItem, error) {
	res, err := ec.unmarshalInputFileItem(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNGPT2githubcomkubeagiarcadiaapiservergraphgeneratedGpt(ctx context.Context, sel ast.SelectionSet, v Gpt) graphql.Marshaler {
	return ec._GPT(ctx, sel, &v)
}

func (ec *executionContext) marshalNGPT2githubcomkubeagiarcadiaapiservergraphgeneratedGpt(ctx context.Context, sel ast.SelectionSet, v *Gpt) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._GPT(ctx, sel, v)
}

func (ec *executionContext) unmarshalNInt2int(ctx context.Context, v interface{}) (int, error) {
	res, err := graphql.UnmarshalInt(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNInt2int(ctx context.Context, sel ast.SelectionSet, v int) graphql.Marshaler {
	res := graphql.MarshalInt(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) marshalNKnowledgeBase2githubcomkubeagiarcadiaapiservergraphgeneratedKnowledgeBase(ctx context.Context, sel ast.SelectionSet, v KnowledgeBase) graphql.Marshaler {
	return ec._KnowledgeBase(ctx, sel, &v)
}

func (ec *executionContext) marshalNKnowledgeBase2githubcomkubeagiarcadiaapiservergraphgeneratedKnowledgeBase(ctx context.Context, sel ast.SelectionSet, v *KnowledgeBase) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._KnowledgeBase(ctx, sel, v)
}

func (ec *executionContext) marshalNLLM2githubcomkubeagiarcadiaapiservergraphgeneratedLlm(ctx context.Context, sel ast.SelectionSet, v Llm) graphql.Marshaler {
	return ec._LLM(ctx, sel, &v)
}

func (ec *executionContext) marshalNLLM2githubcomkubeagiarcadiaapiservergraphgeneratedLlm(ctx context.Context, sel ast.SelectionSet, v *Llm) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._LLM(ctx, sel, v)
}

func (ec *executionContext) unmarshalNListCommonInput2githubcomkubeagiarcadiaapiservergraphgeneratedListCommonInput(ctx context.Context, v interface{}) (ListCommonInput, error) {
	res, err := ec.unmarshalInputListCommonInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNListGPTInput2githubcomkubeagiarcadiaapiservergraphgeneratedListGPTInput(ctx context.Context, v interface{}) (ListGPTInput, error) {
	res, err := ec.unmarshalInputListGPTInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNListKnowledgeBaseInput2githubcomkubeagiarcadiaapiservergraphgeneratedListKnowledgeBaseInput(ctx context.Context, v interface{}) (ListKnowledgeBaseInput, error) {
	res, err := ec.unmarshalInputListKnowledgeBaseInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNListModelInput2githubcomkubeagiarcadiaapiservergraphgeneratedListModelInput(ctx context.Context, v interface{}) (ListModelInput, error) {
	res, err := ec.unmarshalInputListModelInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNListRAGInput2githubcomkubeagiarcadiaapiservergraphgeneratedListRAGInput(ctx context.Context, v interface{}) (ListRAGInput, error) {
	res, err := ec.unmarshalInputListRAGInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNListVersionedDatasetInput2githubcomkubeagiarcadiaapiservergraphgeneratedListVersionedDatasetInput(ctx context.Context, v interface{}) (ListVersionedDatasetInput, error) {
	res, err := ec.unmarshalInputListVersionedDatasetInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNListWorkerInput2githubcomkubeagiarcadiaapiservergraphgeneratedListWorkerInput(ctx context.Context, v interface{}) (ListWorkerInput, error) {
	res, err := ec.unmarshalInputListWorkerInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNModel2githubcomkubeagiarcadiaapiservergraphgeneratedModel(ctx context.Context, sel ast.SelectionSet, v Model) graphql.Marshaler {
	return ec._Model(ctx, sel, &v)
}

func (ec *executionContext) marshalNModel2githubcomkubeagiarcadiaapiservergraphgeneratedModel(ctx context.Context, sel ast.SelectionSet, v *Model) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._Model(ctx, sel, v)
}

func (ec *executionContext) marshalNModelService2githubcomkubeagiarcadiaapiservergraphgeneratedModelService(ctx context.Context, sel ast.SelectionSet, v ModelService) graphql.Marshaler {
	return ec._ModelService(ctx, sel, &v)
}

func (ec *executionContext) marshalNModelService2githubcomkubeagiarcadiaapiservergraphgeneratedModelService(ctx context.Context, sel ast.SelectionSet, v *ModelService) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._ModelService(ctx, sel, v)
}

func (ec *executionContext) marshalNPageNode2githubcomkubeagiarcadiaapiservergraphgeneratedPageNode(ctx context.Context, sel ast.SelectionSet, v PageNode) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._PageNode(ctx, sel, v)
}

func (ec *executionContext) marshalNPaginatedResult2githubcomkubeagiarcadiaapiservergraphgeneratedPaginatedResult(ctx context.Context, sel ast.SelectionSet, v PaginatedResult) graphql.Marshaler {
	return ec._PaginatedResult(ctx, sel, &v)
}

func (ec *executionContext) marshalNPaginatedResult2githubcomkubeagiarcadiaapiservergraphgeneratedPaginatedResult(ctx context.Context, sel ast.SelectionSet, v *PaginatedResult) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._PaginatedResult(ctx, sel, v)
}

func (ec *executionContext) marshalNParameter2githubcomkubeagiarcadiaapiservergraphgeneratedParameter(ctx context.Context, sel ast.SelectionSet, v *Parameter) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._Parameter(ctx, sel, v)
}

func (ec *executionContext) unmarshalNParameterInput2githubcomkubeagiarcadiaapiservergraphgeneratedParameterInput(ctx context.Context, v interface{}) (*ParameterInput, error) {
	res, err := ec.unmarshalInputParameterInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNPersistentVolumeClaimSpec2githubcomkubeagiarcadiaapiservergraphgeneratedPersistentVolumeClaimSpec(ctx context.Context, sel ast.SelectionSet, v PersistentVolumeClaimSpec) graphql.Marshaler {
	return ec._PersistentVolumeClaimSpec(ctx, sel, &v)
}

func (ec *executionContext) marshalNRAG2githubcomkubeagiarcadiaapiservergraphgeneratedRag(ctx context.Context, sel ast.SelectionSet, v Rag) graphql.Marshaler {
	return ec._RAG(ctx, sel, &v)
}

func (ec *executionContext) marshalNRAG2githubcomkubeagiarcadiaapiservergraphgeneratedRag(ctx context.Context, sel ast.SelectionSet, v *Rag) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._RAG(ctx, sel, v)
}

func (ec *executionContext) marshalNRAGDataset2githubcomkubeagiarcadiaapiservergraphgeneratedRAGDataset(ctx context.Context, sel ast.SelectionSet, v []*RAGDataset) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNRAGDataset2githubcomkubeagiarcadiaapiservergraphgeneratedRAGDataset(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNRAGDataset2githubcomkubeagiarcadiaapiservergraphgeneratedRAGDataset(ctx context.Context, sel ast.SelectionSet, v *RAGDataset) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._RAGDataset(ctx, sel, v)
}

func (ec *executionContext) unmarshalNRAGDatasetInput2githubcomkubeagiarcadiaapiservergraphgeneratedRAGDatasetInput(ctx context.Context, v interface{}) ([]*RAGDatasetInput, error) {
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]*RAGDatasetInput, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNRAGDatasetInput2githubcomkubeagiarcadiaapiservergraphgeneratedRAGDatasetInput(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalNRAGDatasetInput2githubcomkubeagiarcadiaapiservergraphgeneratedRAGDatasetInput(ctx context.Context, v interface{}) (*RAGDatasetInput, error) {
	res, err := ec.unmarshalInputRAGDatasetInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNRAGMetric2githubcomkubeagiarcadiaapiservergraphgeneratedRAGMetric(ctx context.Context, sel ast.SelectionSet, v []*RAGMetric) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNRAGMetric2githubcomkubeagiarcadiaapiservergraphgeneratedRAGMetric(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNRAGMetric2githubcomkubeagiarcadiaapiservergraphgeneratedRAGMetric(ctx context.Context, sel ast.SelectionSet, v *RAGMetric) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._RAGMetric(ctx, sel, v)
}

func (ec *executionContext) unmarshalNRAGMetricInput2githubcomkubeagiarcadiaapiservergraphgeneratedRAGMetricInput(ctx context.Context, v interface{}) ([]*RAGMetricInput, error) {
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]*RAGMetricInput, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNRAGMetricInput2githubcomkubeagiarcadiaapiservergraphgeneratedRAGMetricInput(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalNRAGMetricInput2githubcomkubeagiarcadiaapiservergraphgeneratedRAGMetricInput(ctx context.Context, v interface{}) (*RAGMetricInput, error) {
	res, err := ec.unmarshalInputRAGMetricInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNResources2githubcomkubeagiarcadiaapiservergraphgeneratedResources(ctx context.Context, sel ast.SelectionSet, v Resources) graphql.Marshaler {
	return ec._Resources(ctx, sel, &v)
}

func (ec *executionContext) unmarshalNResourcesInput2githubcomkubeagiarcadiaapiservergraphgeneratedResourcesInput(ctx context.Context, v interface{}) (ResourcesInput, error) {
	res, err := ec.unmarshalInputResourcesInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNString2string(ctx context.Context, v interface{}) (string, error) {
	res, err := graphql.UnmarshalString(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNString2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler {
	res := graphql.MarshalString(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) unmarshalNString2string(ctx context.Context, v interface{}) ([]string, error) {
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]string, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNString2string(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalNString2string(ctx context.Context, sel ast.SelectionSet, v []string) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	for i := range v {
		ret[i] = ec.marshalNString2string(ctx, sel, v[i])
	}

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalNTime2timeTime(ctx context.Context, v interface{}) (time.Time, error) {
	res, err := graphql.UnmarshalTime(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNTime2timeTime(ctx context.Context, sel ast.SelectionSet, v time.Time) graphql.Marshaler {
	res := graphql.MarshalTime(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) marshalNTypedObjectReference2githubcomkubeagiarcadiaapiservergraphgeneratedTypedObjectReference(ctx context.Context, sel ast.SelectionSet, v TypedObjectReference) graphql.Marshaler {
	return ec._TypedObjectReference(ctx, sel, &v)
}

func (ec *executionContext) unmarshalNTypedObjectReferenceInput2githubcomkubeagiarcadiaapiservergraphgeneratedTypedObjectReferenceInput(ctx context.Context, v interface{}) (TypedObjectReferenceInput, error) {
	res, err := ec.unmarshalInputTypedObjectReferenceInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNUpdateApplicationConfigInput2githubcomkubeagiarcadiaapiservergraphgeneratedUpdateApplicationConfigInput(ctx context.Context, v interface{}) (UpdateApplicationConfigInput, error) {
	res, err := ec.unmarshalInputUpdateApplicationConfigInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNUpdateApplicationMetadataInput2githubcomkubeagiarcadiaapiservergraphgeneratedUpdateApplicationMetadataInput(ctx context.Context, v interface{}) (UpdateApplicationMetadataInput, error) {
	res, err := ec.unmarshalInputUpdateApplicationMetadataInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNUpdateRAGInput2githubcomkubeagiarcadiaapiservergraphgeneratedUpdateRAGInput(ctx context.Context, v interface{}) (UpdateRAGInput, error) {
	res, err := ec.unmarshalInputUpdateRAGInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNUpdateVersionedDatasetInput2githubcomkubeagiarcadiaapiservergraphgeneratedUpdateVersionedDatasetInput(ctx context.Context, v interface{}) (UpdateVersionedDatasetInput, error) {
	res, err := ec.unmarshalInputUpdateVersionedDatasetInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNVersionedDataset2githubcomkubeagiarcadiaapiservergraphgeneratedVersionedDataset(ctx context.Context, sel ast.SelectionSet, v VersionedDataset) graphql.Marshaler {
	return ec._VersionedDataset(ctx, sel, &v)
}

func (ec *executionContext) marshalNVersionedDataset2githubcomkubeagiarcadiaapiservergraphgeneratedVersionedDataset(ctx context.Context, sel ast.SelectionSet, v *VersionedDataset) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._VersionedDataset(ctx, sel, v)
}

func (ec *executionContext) marshalNWorker2githubcomkubeagiarcadiaapiservergraphgeneratedWorker(ctx context.Context, sel ast.SelectionSet, v Worker) graphql.Marshaler {
	return ec._Worker(ctx, sel, &v)
}

func (ec *executionContext) marshalNWorker2githubcomkubeagiarcadiaapiservergraphgeneratedWorker(ctx context.Context, sel ast.SelectionSet, v *Worker) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._Worker(ctx, sel, v)
}

func (ec *executionContext) marshalN__Directive2githubcom99designsgqlgengraphqlintrospectionDirective(ctx context.Context, sel ast.SelectionSet, v introspection.Directive) graphql.Marshaler {
	return ec.___Directive(ctx, sel, &v)
}

func (ec *executionContext) marshalN__Directive2githubcom99designsgqlgengraphqlintrospectionDirective(ctx context.Context, sel ast.SelectionSet, v []introspection.Directive) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__Directive2githubcom99designsgqlgengraphqlintrospectionDirective(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalN__DirectiveLocation2string(ctx context.Context, v interface{}) (string, error) {
	res, err := graphql.UnmarshalString(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalN__DirectiveLocation2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler {
	res := graphql.MarshalString(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) unmarshalN__DirectiveLocation2string(ctx context.Context, v interface{}) ([]string, error) {
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]string, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalN__DirectiveLocation2string(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalN__DirectiveLocation2string(ctx context.Context, sel ast.SelectionSet, v []string) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__DirectiveLocation2string(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalN__EnumValue2githubcom99designsgqlgengraphqlintrospectionEnumValue(ctx context.Context, sel ast.SelectionSet, v introspection.EnumValue) graphql.Marshaler {
	return ec.___EnumValue(ctx, sel, &v)
}

func (ec *executionContext) marshalN__Field2githubcom99designsgqlgengraphqlintrospectionField(ctx context.Context, sel ast.SelectionSet, v introspection.Field) graphql.Marshaler {
	return ec.___Field(ctx, sel, &v)
}

func (ec *executionContext) marshalN__InputValue2githubcom99designsgqlgengraphqlintrospectionInputValue(ctx context.Context, sel ast.SelectionSet, v introspection.InputValue) graphql.Marshaler {
	return ec.___InputValue(ctx, sel, &v)
}

func (ec *executionContext) marshalN__InputValue2githubcom99designsgqlgengraphqlintrospectionInputValue(ctx context.Context, sel ast.SelectionSet, v []introspection.InputValue) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__InputValue2githubcom99designsgqlgengraphqlintrospectionInputValue(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalN__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx context.Context, sel ast.SelectionSet, v introspection.Type) graphql.Marshaler {
	return ec.___Type(ctx, sel, &v)
}

func (ec *executionContext) marshalN__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx context.Context, sel ast.SelectionSet, v []introspection.Type) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalN__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx context.Context, sel ast.SelectionSet, v *introspection.Type) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec.___Type(ctx, sel, v)
}

func (ec *executionContext) unmarshalN__TypeKind2string(ctx context.Context, v interface{}) (string, error) {
	res, err := graphql.UnmarshalString(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalN__TypeKind2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler {
	res := graphql.MarshalString(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) unmarshalNfilegroupinput2githubcomkubeagiarcadiaapiservergraphgeneratedFilegroupinput(ctx context.Context, v interface{}) (*Filegroupinput, error) {
	res, err := ec.unmarshalInputfilegroupinput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalOAddDataProcessInput2githubcomkubeagiarcadiaapiservergraphgeneratedAddDataProcessInput(ctx context.Context, v interface{}) (*AddDataProcessInput, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputAddDataProcessInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalOAllDataProcessListByCountInput2githubcomkubeagiarcadiaapiservergraphgeneratedAllDataProcessListByCountInput(ctx context.Context, v interface{}) (*AllDataProcessListByCountInput, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputAllDataProcessListByCountInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalOAllDataProcessListByPageInput2githubcomkubeagiarcadiaapiservergraphgeneratedAllDataProcessListByPageInput(ctx context.Context, v interface{}) (*AllDataProcessListByPageInput, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputAllDataProcessListByPageInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOApplicationMetadata2githubcomkubeagiarcadiaapiservergraphgeneratedApplicationMetadata(ctx context.Context, sel ast.SelectionSet, v *ApplicationMetadata) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._ApplicationMetadata(ctx, sel, v)
}

func (ec *executionContext) marshalOApplicationMutation2githubcomkubeagiarcadiaapiservergraphgeneratedApplicationMutation(ctx context.Context, sel ast.SelectionSet, v *ApplicationMutation) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._ApplicationMutation(ctx, sel, v)
}

func (ec *executionContext) marshalOApplicationQuery2githubcomkubeagiarcadiaapiservergraphgeneratedApplicationQuery(ctx context.Context, sel ast.SelectionSet, v *ApplicationQuery) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._ApplicationQuery(ctx, sel, v)
}

func (ec *executionContext) unmarshalOBoolean2bool(ctx context.Context, v interface{}) (bool, error) {
	res, err := graphql.UnmarshalBoolean(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOBoolean2bool(ctx context.Context, sel ast.SelectionSet, v bool) graphql.Marshaler {
	res := graphql.MarshalBoolean(v)
	return res
}

func (ec *executionContext) unmarshalOBoolean2bool(ctx context.Context, v interface{}) (*bool, error) {
	if v == nil {
		return nil, nil
	}
	res, err := graphql.UnmarshalBoolean(v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOBoolean2bool(ctx context.Context, sel ast.SelectionSet, v *bool) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	res := graphql.MarshalBoolean(*v)
	return res
}

func (ec *executionContext) unmarshalOCheckDataProcessTaskNameInput2githubcomkubeagiarcadiaapiservergraphgeneratedCheckDataProcessTaskNameInput(ctx context.Context, v interface{}) (*CheckDataProcessTaskNameInput, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputCheckDataProcessTaskNameInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOCountDataProcessItem2githubcomkubeagiarcadiaapiservergraphgeneratedCountDataProcessItem(ctx context.Context, sel ast.SelectionSet, v *CountDataProcessItem) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._CountDataProcessItem(ctx, sel, v)
}

func (ec *executionContext) unmarshalOCreateDatasetInput2githubcomkubeagiarcadiaapiservergraphgeneratedCreateDatasetInput(ctx context.Context, v interface{}) (*CreateDatasetInput, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputCreateDatasetInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalODataProcessConfig2githubcomkubeagiarcadiaapiservergraphgeneratedDataProcessConfig(ctx context.Context, sel ast.SelectionSet, v []*DataProcessConfig) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNDataProcessConfig2githubcomkubeagiarcadiaapiservergraphgeneratedDataProcessConfig(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalODataProcessConfigChildren2githubcomkubeagiarcadiaapiservergraphgeneratedDataProcessConfigChildren(ctx context.Context, sel ast.SelectionSet, v []*DataProcessConfigChildren) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalODataProcessConfigChildren2githubcomkubeagiarcadiaapiservergraphgeneratedDataProcessConfigChildren(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	return ret
}

func (ec *executionContext) marshalODataProcessConfigChildren2githubcomkubeagiarcadiaapiservergraphgeneratedDataProcessConfigChildren(ctx context.Context, sel ast.SelectionSet, v *DataProcessConfigChildren) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._DataProcessConfigChildren(ctx, sel, v)
}

func (ec *executionContext) marshalODataProcessConfigInfo2githubcomkubeagiarcadiaapiservergraphgeneratedDataProcessConfigInfo(ctx context.Context, sel ast.SelectionSet, v []*DataProcessConfigInfo) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNDataProcessConfigInfo2githubcomkubeagiarcadiaapiservergraphgeneratedDataProcessConfigInfo(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalODataProcessConfigItem2githubcomkubeagiarcadiaapiservergraphgeneratedDataProcessConfigItem(ctx context.Context, v interface{}) ([]*DataProcessConfigItem, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]*DataProcessConfigItem, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNDataProcessConfigItem2githubcomkubeagiarcadiaapiservergraphgeneratedDataProcessConfigItem(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalODataProcessConfigpreFileProgress2githubcomkubeagiarcadiaapiservergraphgeneratedDataProcessConfigpreFileProgress(ctx context.Context, sel ast.SelectionSet, v []*DataProcessConfigpreFileProgress) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalODataProcessConfigpreFileProgress2githubcomkubeagiarcadiaapiservergraphgeneratedDataProcessConfigpreFileProgress(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	return ret
}

func (ec *executionContext) marshalODataProcessConfigpreFileProgress2githubcomkubeagiarcadiaapiservergraphgeneratedDataProcessConfigpreFileProgress(ctx context.Context, sel ast.SelectionSet, v *DataProcessConfigpreFileProgress) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._DataProcessConfigpreFileProgress(ctx, sel, v)
}

func (ec *executionContext) marshalODataProcessConfigpreView2githubcomkubeagiarcadiaapiservergraphgeneratedDataProcessConfigpreView(ctx context.Context, sel ast.SelectionSet, v []*DataProcessConfigpreView) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalODataProcessConfigpreView2githubcomkubeagiarcadiaapiservergraphgeneratedDataProcessConfigpreView(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	return ret
}

func (ec *executionContext) marshalODataProcessConfigpreView2githubcomkubeagiarcadiaapiservergraphgeneratedDataProcessConfigpreView(ctx context.Context, sel ast.SelectionSet, v *DataProcessConfigpreView) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._DataProcessConfigpreView(ctx, sel, v)
}

func (ec *executionContext) marshalODataProcessConfigpreViewContent2githubcomkubeagiarcadiaapiservergraphgeneratedDataProcessConfigpreViewContent(ctx context.Context, sel ast.SelectionSet, v []*DataProcessConfigpreViewContent) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalODataProcessConfigpreViewContent2githubcomkubeagiarcadiaapiservergraphgeneratedDataProcessConfigpreViewContent(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	return ret
}

func (ec *executionContext) marshalODataProcessConfigpreViewContent2githubcomkubeagiarcadiaapiservergraphgeneratedDataProcessConfigpreViewContent(ctx context.Context, sel ast.SelectionSet, v *DataProcessConfigpreViewContent) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._DataProcessConfigpreViewContent(ctx, sel, v)
}

func (ec *executionContext) marshalODataProcessDetails2githubcomkubeagiarcadiaapiservergraphgeneratedDataProcessDetails(ctx context.Context, sel ast.SelectionSet, v *DataProcessDetails) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._DataProcessDetails(ctx, sel, v)
}

func (ec *executionContext) unmarshalODataProcessDetailsInput2githubcomkubeagiarcadiaapiservergraphgeneratedDataProcessDetailsInput(ctx context.Context, v interface{}) (*DataProcessDetailsInput, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputDataProcessDetailsInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalODataProcessFileLogInput2githubcomkubeagiarcadiaapiservergraphgeneratedDataProcessFileLogInput(ctx context.Context, v interface{}) (*DataProcessFileLogInput, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputDataProcessFileLogInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalODataProcessItem2githubcomkubeagiarcadiaapiservergraphgeneratedDataProcessItem(ctx context.Context, sel ast.SelectionSet, v []*DataProcessItem) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNDataProcessItem2githubcomkubeagiarcadiaapiservergraphgeneratedDataProcessItem(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalODataProcessMutation2githubcomkubeagiarcadiaapiservergraphgeneratedDataProcessMutation(ctx context.Context, sel ast.SelectionSet, v *DataProcessMutation) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._DataProcessMutation(ctx, sel, v)
}

func (ec *executionContext) marshalODataProcessQuery2githubcomkubeagiarcadiaapiservergraphgeneratedDataProcessQuery(ctx context.Context, sel ast.SelectionSet, v *DataProcessQuery) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._DataProcessQuery(ctx, sel, v)
}

func (ec *executionContext) marshalODataProcessResponse2githubcomkubeagiarcadiaapiservergraphgeneratedDataProcessResponse(ctx context.Context, sel ast.SelectionSet, v *DataProcessResponse) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._DataProcessResponse(ctx, sel, v)
}

func (ec *executionContext) unmarshalODataProcessRetryInput2githubcomkubeagiarcadiaapiservergraphgeneratedDataProcessRetryInput(ctx context.Context, v interface{}) (*DataProcessRetryInput, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputDataProcessRetryInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalODataProcessSupportType2githubcomkubeagiarcadiaapiservergraphgeneratedDataProcessSupportType(ctx context.Context, sel ast.SelectionSet, v *DataProcessSupportType) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._DataProcessSupportType(ctx, sel, v)
}

func (ec *executionContext) marshalODataProcessSupportTypeChildren2githubcomkubeagiarcadiaapiservergraphgeneratedDataProcessSupportTypeChildren(ctx context.Context, sel ast.SelectionSet, v []*DataProcessSupportTypeChildren) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNDataProcessSupportTypeChildren2githubcomkubeagiarcadiaapiservergraphgeneratedDataProcessSupportTypeChildren(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalODataProcessSupportTypeItem2githubcomkubeagiarcadiaapiservergraphgeneratedDataProcessSupportTypeItem(ctx context.Context, sel ast.SelectionSet, v []*DataProcessSupportTypeItem) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNDataProcessSupportTypeItem2githubcomkubeagiarcadiaapiservergraphgeneratedDataProcessSupportTypeItem(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalODatasetMutation2githubcomkubeagiarcadiaapiservergraphgeneratedDatasetMutation(ctx context.Context, sel ast.SelectionSet, v *DatasetMutation) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._DatasetMutation(ctx, sel, v)
}

func (ec *executionContext) marshalODatasetQuery2githubcomkubeagiarcadiaapiservergraphgeneratedDatasetQuery(ctx context.Context, sel ast.SelectionSet, v *DatasetQuery) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._DatasetQuery(ctx, sel, v)
}

func (ec *executionContext) marshalODatasourceMutation2githubcomkubeagiarcadiaapiservergraphgeneratedDatasourceMutation(ctx context.Context, sel ast.SelectionSet, v *DatasourceMutation) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._DatasourceMutation(ctx, sel, v)
}

func (ec *executionContext) marshalODatasourceQuery2githubcomkubeagiarcadiaapiservergraphgeneratedDatasourceQuery(ctx context.Context, sel ast.SelectionSet, v *DatasourceQuery) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._DatasourceQuery(ctx, sel, v)
}

func (ec *executionContext) unmarshalODeleteCommonInput2githubcomkubeagiarcadiaapiservergraphgeneratedDeleteCommonInput(ctx context.Context, v interface{}) (*DeleteCommonInput, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputDeleteCommonInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalODeleteDataProcessInput2githubcomkubeagiarcadiaapiservergraphgeneratedDeleteDataProcessInput(ctx context.Context, v interface{}) (*DeleteDataProcessInput, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputDeleteDataProcessInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOEmbedderMutation2githubcomkubeagiarcadiaapiservergraphgeneratedEmbedderMutation(ctx context.Context, sel ast.SelectionSet, v *EmbedderMutation) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._EmbedderMutation(ctx, sel, v)
}

func (ec *executionContext) marshalOEmbedderQuery2githubcomkubeagiarcadiaapiservergraphgeneratedEmbedderQuery(ctx context.Context, sel ast.SelectionSet, v *EmbedderQuery) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._EmbedderQuery(ctx, sel, v)
}

func (ec *executionContext) marshalOEndpoint2githubcomkubeagiarcadiaapiservergraphgeneratedEndpoint(ctx context.Context, sel ast.SelectionSet, v *Endpoint) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._Endpoint(ctx, sel, v)
}

func (ec *executionContext) unmarshalOEndpointInput2githubcomkubeagiarcadiaapiservergraphgeneratedEndpointInput(ctx context.Context, v interface{}) (*EndpointInput, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputEndpointInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOF2githubcomkubeagiarcadiaapiservergraphgeneratedF(ctx context.Context, sel ast.SelectionSet, v []*F) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNF2githubcomkubeagiarcadiaapiservergraphgeneratedF(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalOFileFilter2githubcomkubeagiarcadiaapiservergraphgeneratedFileFilter(ctx context.Context, v interface{}) (*FileFilter, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputFileFilter(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalOFileGroup2githubcomkubeagiarcadiaapiservergraphgeneratedFileGroup(ctx context.Context, v interface{}) ([]*FileGroup, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]*FileGroup, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalOFileGroup2githubcomkubeagiarcadiaapiservergraphgeneratedFileGroup(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalOFileGroup2githubcomkubeagiarcadiaapiservergraphgeneratedFileGroup(ctx context.Context, v interface{}) ([]*FileGroup, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]*FileGroup, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNFileGroup2githubcomkubeagiarcadiaapiservergraphgeneratedFileGroup(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalOFileGroup2githubcomkubeagiarcadiaapiservergraphgeneratedFileGroup(ctx context.Context, v interface{}) (*FileGroup, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputFileGroup(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalOFileItem2githubcomkubeagiarcadiaapiservergraphgeneratedFileItem(ctx context.Context, v interface{}) ([]*FileItem, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]*FileItem, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNFileItem2githubcomkubeagiarcadiaapiservergraphgeneratedFileItem(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalOFloat2float64(ctx context.Context, v interface{}) (*float64, error) {
	if v == nil {
		return nil, nil
	}
	res, err := graphql.UnmarshalFloatContext(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOFloat2float64(ctx context.Context, sel ast.SelectionSet, v *float64) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	res := graphql.MarshalFloatContext(*v)
	return graphql.WrapContextMarshaler(ctx, res)
}

func (ec *executionContext) marshalOGPTQuery2githubcomkubeagiarcadiaapiservergraphgeneratedGPTQuery(ctx context.Context, sel ast.SelectionSet, v *GPTQuery) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._GPTQuery(ctx, sel, v)
}

func (ec *executionContext) unmarshalOInt2int(ctx context.Context, v interface{}) (*int, error) {
	if v == nil {
		return nil, nil
	}
	res, err := graphql.UnmarshalInt(v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOInt2int(ctx context.Context, sel ast.SelectionSet, v *int) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	res := graphql.MarshalInt(*v)
	return res
}

func (ec *executionContext) unmarshalOInt642int64(ctx context.Context, v interface{}) (*int64, error) {
	if v == nil {
		return nil, nil
	}
	res, err := graphql.UnmarshalInt64(v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOInt642int64(ctx context.Context, sel ast.SelectionSet, v *int64) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	res := graphql.MarshalInt64(*v)
	return res
}

func (ec *executionContext) marshalOKnowledgeBaseMutation2githubcomkubeagiarcadiaapiservergraphgeneratedKnowledgeBaseMutation(ctx context.Context, sel ast.SelectionSet, v *KnowledgeBaseMutation) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._KnowledgeBaseMutation(ctx, sel, v)
}

func (ec *executionContext) marshalOKnowledgeBaseQuery2githubcomkubeagiarcadiaapiservergraphgeneratedKnowledgeBaseQuery(ctx context.Context, sel ast.SelectionSet, v *KnowledgeBaseQuery) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._KnowledgeBaseQuery(ctx, sel, v)
}

func (ec *executionContext) marshalOLLMConfig2githubcomkubeagiarcadiaapiservergraphgeneratedLLMConfig(ctx context.Context, sel ast.SelectionSet, v *LLMConfig) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._LLMConfig(ctx, sel, v)
}

func (ec *executionContext) unmarshalOLLMConfigItem2githubcomkubeagiarcadiaapiservergraphgeneratedLLMConfigItem(ctx context.Context, v interface{}) (*LLMConfigItem, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputLLMConfigItem(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOLLMQuery2githubcomkubeagiarcadiaapiservergraphgeneratedLLMQuery(ctx context.Context, sel ast.SelectionSet, v *LLMQuery) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._LLMQuery(ctx, sel, v)
}

func (ec *executionContext) marshalOLabelSelectorRequirement2githubcomkubeagiarcadiaapiservergraphgeneratedLabelSelectorRequirement(ctx context.Context, sel ast.SelectionSet, v []*LabelSelectorRequirement) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalOLabelSelectorRequirement2githubcomkubeagiarcadiaapiservergraphgeneratedLabelSelectorRequirement(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	return ret
}

func (ec *executionContext) marshalOLabelSelectorRequirement2githubcomkubeagiarcadiaapiservergraphgeneratedLabelSelectorRequirement(ctx context.Context, sel ast.SelectionSet, v *LabelSelectorRequirement) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._LabelSelectorRequirement(ctx, sel, v)
}

func (ec *executionContext) unmarshalOLabelSelectorRequirementInput2githubcomkubeagiarcadiaapiservergraphgeneratedLabelSelectorRequirementInput(ctx context.Context, v interface{}) ([]*LabelSelectorRequirementInput, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]*LabelSelectorRequirementInput, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalOLabelSelectorRequirementInput2githubcomkubeagiarcadiaapiservergraphgeneratedLabelSelectorRequirementInput(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalOLabelSelectorRequirementInput2githubcomkubeagiarcadiaapiservergraphgeneratedLabelSelectorRequirementInput(ctx context.Context, v interface{}) (*LabelSelectorRequirementInput, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputLabelSelectorRequirementInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalOListDatasetInput2githubcomkubeagiarcadiaapiservergraphgeneratedListDatasetInput(ctx context.Context, v interface{}) (*ListDatasetInput, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputListDatasetInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalOListModelServiceInput2githubcomkubeagiarcadiaapiservergraphgeneratedListModelServiceInput(ctx context.Context, v interface{}) (*ListModelServiceInput, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputListModelServiceInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalOMap2map(ctx context.Context, v interface{}) (map[string]interface{}, error) {
	if v == nil {
		return nil, nil
	}
	res, err := graphql.UnmarshalMap(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOMap2map(ctx context.Context, sel ast.SelectionSet, v map[string]interface{}) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	res := graphql.MarshalMap(v)
	return res
}

func (ec *executionContext) marshalOModelMutation2githubcomkubeagiarcadiaapiservergraphgeneratedModelMutation(ctx context.Context, sel ast.SelectionSet, v *ModelMutation) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._ModelMutation(ctx, sel, v)
}

func (ec *executionContext) marshalOModelQuery2githubcomkubeagiarcadiaapiservergraphgeneratedModelQuery(ctx context.Context, sel ast.SelectionSet, v *ModelQuery) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._ModelQuery(ctx, sel, v)
}

func (ec *executionContext) marshalOModelServiceMutation2githubcomkubeagiarcadiaapiservergraphgeneratedModelServiceMutation(ctx context.Context, sel ast.SelectionSet, v *ModelServiceMutation) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._ModelServiceMutation(ctx, sel, v)
}

func (ec *executionContext) marshalOModelServiceQuery2githubcomkubeagiarcadiaapiservergraphgeneratedModelServiceQuery(ctx context.Context, sel ast.SelectionSet, v *ModelServiceQuery) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._ModelServiceQuery(ctx, sel, v)
}

func (ec *executionContext) marshalONodeSelectorRequirement2githubcomkubeagiarcadiaapiservergraphgeneratedNodeSelectorRequirement(ctx context.Context, sel ast.SelectionSet, v []*NodeSelectorRequirement) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalONodeSelectorRequirement2githubcomkubeagiarcadiaapiservergraphgeneratedNodeSelectorRequirement(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	return ret
}

func (ec *executionContext) marshalONodeSelectorRequirement2githubcomkubeagiarcadiaapiservergraphgeneratedNodeSelectorRequirement(ctx context.Context, sel ast.SelectionSet, v *NodeSelectorRequirement) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._NodeSelectorRequirement(ctx, sel, v)
}

func (ec *executionContext) unmarshalONodeSelectorRequirementInput2githubcomkubeagiarcadiaapiservergraphgeneratedNodeSelectorRequirementInput(ctx context.Context, v interface{}) ([]*NodeSelectorRequirementInput, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]*NodeSelectorRequirementInput, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalONodeSelectorRequirementInput2githubcomkubeagiarcadiaapiservergraphgeneratedNodeSelectorRequirementInput(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalONodeSelectorRequirementInput2githubcomkubeagiarcadiaapiservergraphgeneratedNodeSelectorRequirementInput(ctx context.Context, v interface{}) (*NodeSelectorRequirementInput, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputNodeSelectorRequirementInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOOss2githubcomkubeagiarcadiaapiservergraphgeneratedOss(ctx context.Context, sel ast.SelectionSet, v *Oss) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._Oss(ctx, sel, v)
}

func (ec *executionContext) unmarshalOOssInput2githubcomkubeagiarcadiaapiservergraphgeneratedOssInput(ctx context.Context, v interface{}) (*OssInput, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputOssInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOPageNode2githubcomkubeagiarcadiaapiservergraphgeneratedPageNode(ctx context.Context, sel ast.SelectionSet, v []PageNode) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNPageNode2githubcomkubeagiarcadiaapiservergraphgeneratedPageNode(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalOPaginatedDataProcessItem2githubcomkubeagiarcadiaapiservergraphgeneratedPaginatedDataProcessItem(ctx context.Context, sel ast.SelectionSet, v *PaginatedDataProcessItem) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._PaginatedDataProcessItem(ctx, sel, v)
}

func (ec *executionContext) marshalOParameter2githubcomkubeagiarcadiaapiservergraphgeneratedParameter(ctx context.Context, sel ast.SelectionSet, v []*Parameter) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNParameter2githubcomkubeagiarcadiaapiservergraphgeneratedParameter(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalOParameterInput2githubcomkubeagiarcadiaapiservergraphgeneratedParameterInput(ctx context.Context, v interface{}) ([]*ParameterInput, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]*ParameterInput, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNParameterInput2githubcomkubeagiarcadiaapiservergraphgeneratedParameterInput(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalOPersistentVolumeClaimSpecInput2githubcomkubeagiarcadiaapiservergraphgeneratedPersistentVolumeClaimSpecInput(ctx context.Context, v interface{}) (*PersistentVolumeClaimSpecInput, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputPersistentVolumeClaimSpecInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalORAGDatasetInput2githubcomkubeagiarcadiaapiservergraphgeneratedRAGDatasetInput(ctx context.Context, v interface{}) ([]*RAGDatasetInput, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]*RAGDatasetInput, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNRAGDatasetInput2githubcomkubeagiarcadiaapiservergraphgeneratedRAGDatasetInput(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalORAGMetricInput2githubcomkubeagiarcadiaapiservergraphgeneratedRAGMetricInput(ctx context.Context, v interface{}) ([]*RAGMetricInput, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]*RAGMetricInput, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNRAGMetricInput2githubcomkubeagiarcadiaapiservergraphgeneratedRAGMetricInput(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalORAGMutation2githubcomkubeagiarcadiaapiservergraphgeneratedRAGMutation(ctx context.Context, sel ast.SelectionSet, v *RAGMutation) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._RAGMutation(ctx, sel, v)
}

func (ec *executionContext) marshalORAGQuery2githubcomkubeagiarcadiaapiservergraphgeneratedRAGQuery(ctx context.Context, sel ast.SelectionSet, v *RAGQuery) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._RAGQuery(ctx, sel, v)
}

func (ec *executionContext) marshalORayClusterQuery2githubcomkubeagiarcadiaapiservergraphgeneratedRayClusterQuery(ctx context.Context, sel ast.SelectionSet, v *RayClusterQuery) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._RayClusterQuery(ctx, sel, v)
}

func (ec *executionContext) unmarshalORemoveDuplicateConfig2githubcomkubeagiarcadiaapiservergraphgeneratedRemoveDuplicateConfig(ctx context.Context, v interface{}) (*RemoveDuplicateConfig, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputRemoveDuplicateConfig(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalORemoveDuplicateConfigItem2githubcomkubeagiarcadiaapiservergraphgeneratedRemoveDuplicateConfigItem(ctx context.Context, sel ast.SelectionSet, v *RemoveDuplicateConfigItem) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._RemoveDuplicateConfigItem(ctx, sel, v)
}

func (ec *executionContext) marshalOResource2githubcomkubeagiarcadiaapiservergraphgeneratedResource(ctx context.Context, sel ast.SelectionSet, v *Resource) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._Resource(ctx, sel, v)
}

func (ec *executionContext) unmarshalOResourceInput2githubcomkubeagiarcadiaapiservergraphgeneratedResourceInput(ctx context.Context, v interface{}) (*ResourceInput, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputResourceInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalOResourcesInput2githubcomkubeagiarcadiaapiservergraphgeneratedResourcesInput(ctx context.Context, v interface{}) (*ResourcesInput, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputResourcesInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOSelector2githubcomkubeagiarcadiaapiservergraphgeneratedSelector(ctx context.Context, sel ast.SelectionSet, v *Selector) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._Selector(ctx, sel, v)
}

func (ec *executionContext) unmarshalOSelectorInput2githubcomkubeagiarcadiaapiservergraphgeneratedSelectorInput(ctx context.Context, v interface{}) (*SelectorInput, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputSelectorInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalOString2string(ctx context.Context, v interface{}) ([]string, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]string, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNString2string(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalOString2string(ctx context.Context, sel ast.SelectionSet, v []string) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	for i := range v {
		ret[i] = ec.marshalNString2string(ctx, sel, v[i])
	}

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalOString2string(ctx context.Context, v interface{}) ([]*string, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]*string, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalOString2string(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalOString2string(ctx context.Context, sel ast.SelectionSet, v []*string) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	for i := range v {
		ret[i] = ec.marshalOString2string(ctx, sel, v[i])
	}

	return ret
}

func (ec *executionContext) unmarshalOString2string(ctx context.Context, v interface{}) (*string, error) {
	if v == nil {
		return nil, nil
	}
	res, err := graphql.UnmarshalString(v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOString2string(ctx context.Context, sel ast.SelectionSet, v *string) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	res := graphql.MarshalString(*v)
	return res
}

func (ec *executionContext) unmarshalOTime2timeTime(ctx context.Context, v interface{}) (*time.Time, error) {
	if v == nil {
		return nil, nil
	}
	res, err := graphql.UnmarshalTime(v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOTime2timeTime(ctx context.Context, sel ast.SelectionSet, v *time.Time) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	res := graphql.MarshalTime(*v)
	return res
}

func (ec *executionContext) marshalOTool2githubcomkubeagiarcadiaapiservergraphgeneratedTool(ctx context.Context, sel ast.SelectionSet, v []*Tool) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalOTool2githubcomkubeagiarcadiaapiservergraphgeneratedTool(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	return ret
}

func (ec *executionContext) marshalOTool2githubcomkubeagiarcadiaapiservergraphgeneratedTool(ctx context.Context, sel ast.SelectionSet, v *Tool) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._Tool(ctx, sel, v)
}

func (ec *executionContext) unmarshalOToolInput2githubcomkubeagiarcadiaapiservergraphgeneratedToolInput(ctx context.Context, v interface{}) ([]*ToolInput, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]*ToolInput, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalOToolInput2githubcomkubeagiarcadiaapiservergraphgeneratedToolInput(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalOToolInput2githubcomkubeagiarcadiaapiservergraphgeneratedToolInput(ctx context.Context, v interface{}) (*ToolInput, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputToolInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOTypedObjectReference2githubcomkubeagiarcadiaapiservergraphgeneratedTypedObjectReference(ctx context.Context, sel ast.SelectionSet, v *TypedObjectReference) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._TypedObjectReference(ctx, sel, v)
}

func (ec *executionContext) unmarshalOTypedObjectReferenceInput2githubcomkubeagiarcadiaapiservergraphgeneratedTypedObjectReferenceInput(ctx context.Context, v interface{}) (*TypedObjectReferenceInput, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputTypedObjectReferenceInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalOUpdateDatasetInput2githubcomkubeagiarcadiaapiservergraphgeneratedUpdateDatasetInput(ctx context.Context, v interface{}) (*UpdateDatasetInput, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputUpdateDatasetInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalOUpdateDatasourceInput2githubcomkubeagiarcadiaapiservergraphgeneratedUpdateDatasourceInput(ctx context.Context, v interface{}) (*UpdateDatasourceInput, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputUpdateDatasourceInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalOUpdateEmbedderInput2githubcomkubeagiarcadiaapiservergraphgeneratedUpdateEmbedderInput(ctx context.Context, v interface{}) (*UpdateEmbedderInput, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputUpdateEmbedderInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalOUpdateKnowledgeBaseInput2githubcomkubeagiarcadiaapiservergraphgeneratedUpdateKnowledgeBaseInput(ctx context.Context, v interface{}) (*UpdateKnowledgeBaseInput, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputUpdateKnowledgeBaseInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalOUpdateModelInput2githubcomkubeagiarcadiaapiservergraphgeneratedUpdateModelInput(ctx context.Context, v interface{}) (*UpdateModelInput, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputUpdateModelInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalOUpdateModelServiceInput2githubcomkubeagiarcadiaapiservergraphgeneratedUpdateModelServiceInput(ctx context.Context, v interface{}) (*UpdateModelServiceInput, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputUpdateModelServiceInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalOUpdateWorkerInput2githubcomkubeagiarcadiaapiservergraphgeneratedUpdateWorkerInput(ctx context.Context, v interface{}) (*UpdateWorkerInput, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputUpdateWorkerInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOVersionedDatasetMutation2githubcomkubeagiarcadiaapiservergraphgeneratedVersionedDatasetMutation(ctx context.Context, sel ast.SelectionSet, v *VersionedDatasetMutation) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._VersionedDatasetMutation(ctx, sel, v)
}

func (ec *executionContext) marshalOVersionedDatasetQuery2githubcomkubeagiarcadiaapiservergraphgeneratedVersionedDatasetQuery(ctx context.Context, sel ast.SelectionSet, v *VersionedDatasetQuery) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._VersionedDatasetQuery(ctx, sel, v)
}

func (ec *executionContext) unmarshalOVoid2string(ctx context.Context, v interface{}) (*string, error) {
	if v == nil {
		return nil, nil
	}
	res, err := graphql.UnmarshalString(v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOVoid2string(ctx context.Context, sel ast.SelectionSet, v *string) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	res := graphql.MarshalString(*v)
	return res
}

func (ec *executionContext) marshalOWeb2githubcomkubeagiarcadiaapiservergraphgeneratedWeb(ctx context.Context, sel ast.SelectionSet, v *Web) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._Web(ctx, sel, v)
}

func (ec *executionContext) unmarshalOWebInput2githubcomkubeagiarcadiaapiservergraphgeneratedWebInput(ctx context.Context, v interface{}) (*WebInput, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputWebInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOWorkerMutation2githubcomkubeagiarcadiaapiservergraphgeneratedWorkerMutation(ctx context.Context, sel ast.SelectionSet, v *WorkerMutation) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._WorkerMutation(ctx, sel, v)
}

func (ec *executionContext) marshalOWorkerQuery2githubcomkubeagiarcadiaapiservergraphgeneratedWorkerQuery(ctx context.Context, sel ast.SelectionSet, v *WorkerQuery) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._WorkerQuery(ctx, sel, v)
}

func (ec *executionContext) marshalO__EnumValue2githubcom99designsgqlgengraphqlintrospectionEnumValue(ctx context.Context, sel ast.SelectionSet, v []introspection.EnumValue) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__EnumValue2githubcom99designsgqlgengraphqlintrospectionEnumValue(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalO__Field2githubcom99designsgqlgengraphqlintrospectionField(ctx context.Context, sel ast.SelectionSet, v []introspection.Field) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__Field2githubcom99designsgqlgengraphqlintrospectionField(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalO__InputValue2githubcom99designsgqlgengraphqlintrospectionInputValue(ctx context.Context, sel ast.SelectionSet, v []introspection.InputValue) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__InputValue2githubcom99designsgqlgengraphqlintrospectionInputValue(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalO__Schema2githubcom99designsgqlgengraphqlintrospectionSchema(ctx context.Context, sel ast.SelectionSet, v *introspection.Schema) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec.___Schema(ctx, sel, v)
}

func (ec *executionContext) marshalO__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx context.Context, sel ast.SelectionSet, v []introspection.Type) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalO__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx context.Context, sel ast.SelectionSet, v *introspection.Type) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec.___Type(ctx, sel, v)
}

func (ec *executionContext) marshalOfiledetail2githubcomkubeagiarcadiaapiservergraphgeneratedFiledetail(ctx context.Context, sel ast.SelectionSet, v []*Filedetail) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalOfiledetail2githubcomkubeagiarcadiaapiservergraphgeneratedFiledetail(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	return ret
}

func (ec *executionContext) marshalOfiledetail2githubcomkubeagiarcadiaapiservergraphgeneratedFiledetail(ctx context.Context, sel ast.SelectionSet, v *Filedetail) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._filedetail(ctx, sel, v)
}

func (ec *executionContext) marshalOfilegroupdetail2githubcomkubeagiarcadiaapiservergraphgeneratedFilegroupdetail(ctx context.Context, sel ast.SelectionSet, v []*Filegroupdetail) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalOfilegroupdetail2githubcomkubeagiarcadiaapiservergraphgeneratedFilegroupdetail(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	return ret
}

func (ec *executionContext) marshalOfilegroupdetail2githubcomkubeagiarcadiaapiservergraphgeneratedFilegroupdetail(ctx context.Context, sel ast.SelectionSet, v *Filegroupdetail) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._filegroupdetail(ctx, sel, v)
}

func (ec *executionContext) unmarshalOfilegroupinput2githubcomkubeagiarcadiaapiservergraphgeneratedFilegroupinput(ctx context.Context, v interface{}) ([]*Filegroupinput, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]*Filegroupinput, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNfilegroupinput2githubcomkubeagiarcadiaapiservergraphgeneratedFilegroupinput(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

// endregion ***************************** type.gotpl *****************************
